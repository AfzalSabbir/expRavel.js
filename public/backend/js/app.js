/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./public/backend/js/custom.js":
/*!*************************************!*\
  !*** ./public/backend/js/custom.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("$(document).ready(function () {\n  /**\r\n   * Delete alert\r\n   * @param parameter to delete\r\n   */\n  deleteMethod = function deleteMethod(encrypted_id) {\n    swal({\n      title: \"Are you sure?\",\n      text: \"This data will be deleted permanently!\",\n      icon: \"warning\",\n      buttons: true,\n      dangerMode: true\n    }).then(function (willDelete) {\n      if (willDelete) {\n        window.location = window.location.pathname + '/delete/' + encrypted_id;\n      }\n    });\n  };\n  /**\r\n   * Inactive alert\r\n   * @param parameter to inactive\r\n   */\n\n\n  inactiveMethod = function inactiveMethod(encrypted_id) {\n    swal({\n      title: \"Are you sure?\",\n      text: \"After Removing, You can recover by updating STATUS!\",\n      icon: \"warning\",\n      buttons: true,\n      dangerMode: true\n    }).then(function (willDelete) {\n      if (willDelete) {\n        window.location = window.location.pathname + '/inactive/' + encrypted_id;\n      }\n    });\n  };\n  /**\r\n   *  All About Search\r\n   */\n\n\n  $('#searchField').prop('selectedIndex', 0); // Reset Search Select\n\n  var searchItems = \"&nbsp;\" + \"disableed\";\n  var countSelect = 0;\n  $(\"select\").change(function () {\n    var newField = '&nbsp' + $(this).val() + '&nbsp';\n\n    if (newField != null && newField != \"\") {\n      var name = $(this).val();\n      var placeholder = $(\"#searchField option:selected\").text();\n      var html = \"<div style=\\\"margin: 4px 0;\\\" class=\\\"col-md-2\\\">\\n\" + \"<input id='search' type=\\\"text\\\" name=\\\"\" + name + \"\\\" placeholder=\\\"\" + placeholder + \"\\\" class=\\\"form-control\\\">\\n\" + \"</div>\";\n\n      if (searchItems.indexOf(newField) == -1) {\n        countSelect = countSelect + 1;\n        $(\".search-field\").append(html);\n        $(\"#searchForm\").show();\n        $(\"#searchButton\").show();\n        searchItems = searchItems + newField + '&nbsp;';\n\n        if (countSelect > 5) {\n          $(\"#searchButton\").css({//'margin-left': '5px',\n            //'margin-top': '5px'\n          });\n        }\n      }\n    }\n  });\n  /*\r\n  * Avro Bangla\r\n  */\n\n  $('input[type=text], input[type=number], input[type=email], input[type=search]').focus(function () {\n    if ($(this).hasClass('avro_bn')) {\n      $('.lang_pen').text('বাংলা ');\n      $('.lang_pen_parent').show();\n    } else {\n      $('.lang_pen').text('Eng ');\n      $('.lang_pen_parent').show();\n    }\n\n    $(this).blur(function () {\n      $('.lang_pen_parent').hide();\n    });\n  });\n  $('textarea').focus(function () {\n    if ($(this).hasClass('avro_bn')) {\n      $('.lang_pen').text('বাংলা ');\n      $('.lang_pen_parent').show();\n    } else {\n      $('.lang_pen').text('Eng ');\n      $('.lang_pen_parent').show();\n    }\n\n    $(this).blur(function () {\n      $('.lang_pen_parent').hide();\n    });\n  }); // alert($('h1').children('i').attr('class'));\n\n  $(window).scroll(function () {\n    if ($(window).width() >= 768) {\n      if ($(window).scrollTop() > $('.app-header').height() - 30 + $('.card-header').height() +\n      /*$('.app-title').height() +*/\n      parseInt($('.app-title').css('margin-bottom'))) {\n        $('.app-nav_custom_item').fadeIn().html('<i class=\"' + $('h1').children('i').attr('class') + '\"></i>' + $('.card-header .row .col-md-6 h2').text());\n      } else {\n        $('.app-nav_custom_item').fadeOut();\n      }\n    }\n  });\n});\nVue.config.productionTip = false;\n$(document).ready(function () {\n  var table = $('#datatable').DataTable({\n    // \"scrollY\": \"350px\",\n    \"paging\": true,\n    \"pageLength\": 50,\n    \"lengthMenu\": [[10, 25, 50, -1], [10, 25, 50, \"All\"]]\n  });\n  $('a.toggle-vis').on('click', function (e) {\n    e.preventDefault(); // Get the column API object\n\n    var column = table.column($(this).attr('data-column')); // Toggle the visibility\n\n    column.visible(!column.visible());\n  });\n});\n$(document).ready(function () {\n  $(\"body\").tooltip({\n    selector: '[data-toggle=tooltip]'\n  });\n  $(\".simplebar-content\").click(function () {\n    if ($(\".simplebar-offset\").css('bottom') == '-17px') {\n      document.getElementById('app-sidebar__toggle').click();\n    }\n  });\n  $(\".simplebar-content\").hover(function () {\n    if ($(\".simplebar-offset\").css('bottom') == '-17px') {\n      document.getElementById('app-sidebar__toggle').click();\n    }\n  });\n});\n/*javascript pluralize a string*/\n\nString.prototype.plural = function (revert) {\n  var plural = {\n    '(quiz)$': \"$1zes\",\n    '^(ox)$': \"$1en\",\n    '([m|l])ouse$': \"$1ice\",\n    '(matr|vert|ind)ix|ex$': \"$1ices\",\n    '(x|ch|ss|sh)$': \"$1es\",\n    '([^aeiouy]|qu)y$': \"$1ies\",\n    '(hive)$': \"$1s\",\n    '(?:([^f])fe|([lr])f)$': \"$1$2ves\",\n    '(shea|lea|loa|thie)f$': \"$1ves\",\n    'sis$': \"ses\",\n    '([ti])um$': \"$1a\",\n    '(tomat|potat|ech|her|vet)o$': \"$1oes\",\n    '(bu)s$': \"$1ses\",\n    '(alias)$': \"$1es\",\n    '(octop)us$': \"$1i\",\n    '(ax|test)is$': \"$1es\",\n    '(us)$': \"$1es\",\n    '([^s]+)$': \"$1s\"\n  };\n  var singular = {\n    '(quiz)zes$': \"$1\",\n    '(matr)ices$': \"$1ix\",\n    '(vert|ind)ices$': \"$1ex\",\n    '^(ox)en$': \"$1\",\n    '(alias)es$': \"$1\",\n    '(octop|vir)i$': \"$1us\",\n    '(cris|ax|test)es$': \"$1is\",\n    '(shoe)s$': \"$1\",\n    '(o)es$': \"$1\",\n    '(bus)es$': \"$1\",\n    '([m|l])ice$': \"$1ouse\",\n    '(x|ch|ss|sh)es$': \"$1\",\n    '(m)ovies$': \"$1ovie\",\n    '(s)eries$': \"$1eries\",\n    '([^aeiouy]|qu)ies$': \"$1y\",\n    '([lr])ves$': \"$1f\",\n    '(tive)s$': \"$1\",\n    '(hive)s$': \"$1\",\n    '(li|wi|kni)ves$': \"$1fe\",\n    '(shea|loa|lea|thie)ves$': \"$1f\",\n    '(^analy)ses$': \"$1sis\",\n    '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$': \"$1$2sis\",\n    '([ti])a$': \"$1um\",\n    '(n)ews$': \"$1ews\",\n    '(h|bl)ouses$': \"$1ouse\",\n    '(corpse)s$': \"$1\",\n    '(us)es$': \"$1\",\n    's$': \"\"\n  };\n  var irregular = {\n    'move': 'moves',\n    'foot': 'feet',\n    'goose': 'geese',\n    'sex': 'sexes',\n    'child': 'children',\n    'man': 'men',\n    'tooth': 'teeth',\n    'person': 'people'\n  };\n  var uncountable = ['sheep', 'fish', 'deer', 'moose', 'series', 'species', 'money', 'rice', 'information', 'equipment']; // save some time in the case that singular and plural are the same\n\n  if (uncountable.indexOf(this.toLowerCase()) >= 0) return this; // check for irregular forms\n\n  for (word in irregular) {\n    if (revert) {\n      var pattern = new RegExp(irregular[word] + '$', 'i');\n      var replace = word;\n    } else {\n      var pattern = new RegExp(word + '$', 'i');\n      var replace = irregular[word];\n    }\n\n    if (pattern.test(this)) return this.replace(pattern, replace);\n  }\n\n  if (revert) var array = singular;else var array = plural; // check for matches using regular expressions\n\n  for (reg in array) {\n    var pattern = new RegExp(reg, 'i');\n    if (pattern.test(this)) return this.replace(pattern, array[reg]);\n  }\n\n  return this;\n};\n\n$(document).ready(function () {\n  var table = '';\n  var a_index = 0;\n  var column = 0;\n  /*checking wheather datatable has been called or not*/\n\n  if ($('.card-body[data-my-table=\"table-1\"]').find('#datatable').length == 0) {\n    /*showing my pagination*/\n    $('.custom_pagination').show();\n    /*table search*/\n\n    $(\"#my-table-search\").on(\"keyup\", function () {\n      var value = $(this).val().toLowerCase();\n      $(\"#my-table tbody tr\").filter(function () {\n        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1);\n      });\n    });\n  }\n  /*coloring column title on hide/show*/\n\n\n  $('.toggle-vis').click(function (event) {\n    table = $(this).closest('.card').find('table');\n    if ($(this).hasClass('text-danger')) $(this).removeClass('text-danger');else $(this).addClass('text-danger'); //a_index = $(this).index();\n\n    column = parseInt($(this).closest('a').attr('data-column')) + 1; // console.log(column);\n\n    if (\n    /*document.getElementById('pagination_container') && */\n    table.attr('id') != 'datatable') {\n      table.find('td:nth-child(' + column + ')').each(function () {\n        $(this).toggle();\n      });\n      table.find('th:nth-child(' + column + ')').toggle();\n    }\n  });\n  $('.toggle-vis').each(function () {\n    if ($(this).hasClass('hide-on-load')) $(this).click();\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvYmFja2VuZC9qcy9jdXN0b20uanM/NDg4ZCJdLCJuYW1lcyI6WyIkIiwiZG9jdW1lbnQiLCJyZWFkeSIsImRlbGV0ZU1ldGhvZCIsImVuY3J5cHRlZF9pZCIsInN3YWwiLCJ0aXRsZSIsInRleHQiLCJpY29uIiwiYnV0dG9ucyIsImRhbmdlck1vZGUiLCJ0aGVuIiwid2lsbERlbGV0ZSIsIndpbmRvdyIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJpbmFjdGl2ZU1ldGhvZCIsInByb3AiLCJzZWFyY2hJdGVtcyIsImNvdW50U2VsZWN0IiwiY2hhbmdlIiwibmV3RmllbGQiLCJ2YWwiLCJuYW1lIiwicGxhY2Vob2xkZXIiLCJodG1sIiwiaW5kZXhPZiIsImFwcGVuZCIsInNob3ciLCJjc3MiLCJmb2N1cyIsImhhc0NsYXNzIiwiYmx1ciIsImhpZGUiLCJzY3JvbGwiLCJ3aWR0aCIsInNjcm9sbFRvcCIsImhlaWdodCIsInBhcnNlSW50IiwiZmFkZUluIiwiY2hpbGRyZW4iLCJhdHRyIiwiZmFkZU91dCIsIlZ1ZSIsImNvbmZpZyIsInByb2R1Y3Rpb25UaXAiLCJ0YWJsZSIsIkRhdGFUYWJsZSIsIm9uIiwiZSIsInByZXZlbnREZWZhdWx0IiwiY29sdW1uIiwidmlzaWJsZSIsInRvb2x0aXAiLCJzZWxlY3RvciIsImNsaWNrIiwiZ2V0RWxlbWVudEJ5SWQiLCJob3ZlciIsIlN0cmluZyIsInByb3RvdHlwZSIsInBsdXJhbCIsInJldmVydCIsInNpbmd1bGFyIiwiaXJyZWd1bGFyIiwidW5jb3VudGFibGUiLCJ0b0xvd2VyQ2FzZSIsIndvcmQiLCJwYXR0ZXJuIiwiUmVnRXhwIiwicmVwbGFjZSIsInRlc3QiLCJhcnJheSIsInJlZyIsImFfaW5kZXgiLCJmaW5kIiwibGVuZ3RoIiwidmFsdWUiLCJmaWx0ZXIiLCJ0b2dnbGUiLCJldmVudCIsImNsb3Nlc3QiLCJyZW1vdmVDbGFzcyIsImFkZENsYXNzIiwiZWFjaCJdLCJtYXBwaW5ncyI6IkFBQUFBLENBQUMsQ0FBQ0MsUUFBRCxDQUFELENBQVlDLEtBQVosQ0FBa0IsWUFBVTtBQUN4Qjs7OztBQUlDQyxjQUFZLEdBQUksc0JBQVVDLFlBQVYsRUFBd0I7QUFDckNDLFFBQUksQ0FBQztBQUNEQyxXQUFLLEVBQUUsZUFETjtBQUVEQyxVQUFJLEVBQUUsd0NBRkw7QUFHREMsVUFBSSxFQUFFLFNBSEw7QUFJREMsYUFBTyxFQUFFLElBSlI7QUFLREMsZ0JBQVUsRUFBRTtBQUxYLEtBQUQsQ0FBSixDQU1HQyxJQU5ILENBTVEsVUFBQ0MsVUFBRCxFQUFnQjtBQUNwQixVQUFJQSxVQUFKLEVBQWdCO0FBQ1pDLGNBQU0sQ0FBQ0MsUUFBUCxHQUFrQkQsTUFBTSxDQUFDQyxRQUFQLENBQWdCQyxRQUFoQixHQUF5QixVQUF6QixHQUFvQ1gsWUFBdEQ7QUFDSDtBQUNKLEtBVkQ7QUFXSCxHQVpBO0FBYUQ7Ozs7OztBQUlDWSxnQkFBYyxHQUFJLHdCQUFVWixZQUFWLEVBQXdCO0FBQ3ZDQyxRQUFJLENBQUM7QUFDREMsV0FBSyxFQUFFLGVBRE47QUFFREMsVUFBSSxFQUFFLHFEQUZMO0FBR0RDLFVBQUksRUFBRSxTQUhMO0FBSURDLGFBQU8sRUFBRSxJQUpSO0FBS0RDLGdCQUFVLEVBQUU7QUFMWCxLQUFELENBQUosQ0FNR0MsSUFOSCxDQU1RLFVBQUNDLFVBQUQsRUFBZ0I7QUFDcEIsVUFBSUEsVUFBSixFQUFnQjtBQUNaQyxjQUFNLENBQUNDLFFBQVAsR0FBa0JELE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsUUFBaEIsR0FBeUIsWUFBekIsR0FBc0NYLFlBQXhEO0FBQ0g7QUFDSixLQVZEO0FBV0gsR0FaQTtBQWNEOzs7OztBQUdBSixHQUFDLENBQUMsY0FBRCxDQUFELENBQWtCaUIsSUFBbEIsQ0FBdUIsZUFBdkIsRUFBdUMsQ0FBdkMsRUF2Q3dCLENBdUNtQjs7QUFDM0MsTUFBSUMsV0FBVyxHQUFHLFdBQVMsV0FBM0I7QUFDQSxNQUFJQyxXQUFXLEdBQUcsQ0FBbEI7QUFDQW5CLEdBQUMsQ0FBQyxRQUFELENBQUQsQ0FBWW9CLE1BQVosQ0FBbUIsWUFBVTtBQUN6QixRQUFJQyxRQUFRLEdBQUcsVUFBVXJCLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUXNCLEdBQVIsRUFBVixHQUEwQixPQUF6Qzs7QUFDQSxRQUFHRCxRQUFRLElBQUksSUFBWixJQUFvQkEsUUFBUSxJQUFJLEVBQW5DLEVBQXNDO0FBQ2xDLFVBQUlFLElBQUksR0FBR3ZCLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUXNCLEdBQVIsRUFBWDtBQUNBLFVBQUlFLFdBQVcsR0FBR3hCLENBQUMsQ0FBQyw4QkFBRCxDQUFELENBQWtDTyxJQUFsQyxFQUFsQjtBQUNBLFVBQUlrQixJQUFJLEdBQUcsd0RBQ1gsMENBRFcsR0FDa0NGLElBRGxDLEdBQ3lDLG1CQUR6QyxHQUMrREMsV0FEL0QsR0FDNkUsOEJBRDdFLEdBRVgsUUFGQTs7QUFHQSxVQUFHTixXQUFXLENBQUNRLE9BQVosQ0FBb0JMLFFBQXBCLEtBQWlDLENBQUMsQ0FBckMsRUFBdUM7QUFDbkNGLG1CQUFXLEdBQUdBLFdBQVcsR0FBRyxDQUE1QjtBQUNBbkIsU0FBQyxDQUFDLGVBQUQsQ0FBRCxDQUFtQjJCLE1BQW5CLENBQTBCRixJQUExQjtBQUNBekIsU0FBQyxDQUFDLGFBQUQsQ0FBRCxDQUFpQjRCLElBQWpCO0FBQ0E1QixTQUFDLENBQUMsZUFBRCxDQUFELENBQW1CNEIsSUFBbkI7QUFDQVYsbUJBQVcsR0FBR0EsV0FBVyxHQUFHRyxRQUFkLEdBQXlCLFFBQXZDOztBQUNBLFlBQUlGLFdBQVcsR0FBRyxDQUFsQixFQUFxQjtBQUNqQm5CLFdBQUMsQ0FBQyxlQUFELENBQUQsQ0FBbUI2QixHQUFuQixDQUF1QixDQUNuQjtBQUNBO0FBRm1CLFdBQXZCO0FBSUg7QUFDSjtBQUNKO0FBQ0osR0F0QkQ7QUF1QkE7Ozs7QUFJQTdCLEdBQUMsQ0FBQyw2RUFBRCxDQUFELENBQWlGOEIsS0FBakYsQ0FBdUYsWUFBVTtBQUM3RixRQUFJOUIsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRK0IsUUFBUixDQUFpQixTQUFqQixDQUFKLEVBQWlDO0FBQzdCL0IsT0FBQyxDQUFDLFdBQUQsQ0FBRCxDQUFlTyxJQUFmLENBQW9CLFFBQXBCO0FBQ0FQLE9BQUMsQ0FBQyxrQkFBRCxDQUFELENBQXNCNEIsSUFBdEI7QUFDSCxLQUhELE1BR0s7QUFDRDVCLE9BQUMsQ0FBQyxXQUFELENBQUQsQ0FBZU8sSUFBZixDQUFvQixNQUFwQjtBQUNBUCxPQUFDLENBQUMsa0JBQUQsQ0FBRCxDQUFzQjRCLElBQXRCO0FBQ0g7O0FBQ0Q1QixLQUFDLENBQUMsSUFBRCxDQUFELENBQVFnQyxJQUFSLENBQWEsWUFBVTtBQUNuQmhDLE9BQUMsQ0FBQyxrQkFBRCxDQUFELENBQXNCaUMsSUFBdEI7QUFDSCxLQUZEO0FBR0gsR0FYRDtBQVlBakMsR0FBQyxDQUFDLFVBQUQsQ0FBRCxDQUFjOEIsS0FBZCxDQUFvQixZQUFVO0FBQzFCLFFBQUk5QixDQUFDLENBQUMsSUFBRCxDQUFELENBQVErQixRQUFSLENBQWlCLFNBQWpCLENBQUosRUFBaUM7QUFDN0IvQixPQUFDLENBQUMsV0FBRCxDQUFELENBQWVPLElBQWYsQ0FBb0IsUUFBcEI7QUFDQVAsT0FBQyxDQUFDLGtCQUFELENBQUQsQ0FBc0I0QixJQUF0QjtBQUNILEtBSEQsTUFHSztBQUNENUIsT0FBQyxDQUFDLFdBQUQsQ0FBRCxDQUFlTyxJQUFmLENBQW9CLE1BQXBCO0FBQ0FQLE9BQUMsQ0FBQyxrQkFBRCxDQUFELENBQXNCNEIsSUFBdEI7QUFDSDs7QUFDRDVCLEtBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWdDLElBQVIsQ0FBYSxZQUFVO0FBQ25CaEMsT0FBQyxDQUFDLGtCQUFELENBQUQsQ0FBc0JpQyxJQUF0QjtBQUNILEtBRkQ7QUFHSCxHQVhELEVBakZ3QixDQWdHeEI7O0FBQ0FqQyxHQUFDLENBQUNhLE1BQUQsQ0FBRCxDQUFVcUIsTUFBVixDQUFpQixZQUFVO0FBQ3ZCLFFBQUlsQyxDQUFDLENBQUNhLE1BQUQsQ0FBRCxDQUFVc0IsS0FBVixNQUFxQixHQUF6QixFQUE4QjtBQUMxQixVQUFJbkMsQ0FBQyxDQUFDYSxNQUFELENBQUQsQ0FBVXVCLFNBQVYsS0FBd0JwQyxDQUFDLENBQUMsYUFBRCxDQUFELENBQWlCcUMsTUFBakIsS0FBNEIsRUFBNUIsR0FBaUNyQyxDQUFDLENBQUMsY0FBRCxDQUFELENBQWtCcUMsTUFBbEIsRUFBakM7QUFBOEQ7QUFBK0JDLGNBQVEsQ0FBQ3RDLENBQUMsQ0FBQyxZQUFELENBQUQsQ0FBZ0I2QixHQUFoQixDQUFvQixlQUFwQixDQUFELENBQWpJLEVBQXlLO0FBQ3JLN0IsU0FBQyxDQUFDLHNCQUFELENBQUQsQ0FBMEJ1QyxNQUExQixHQUFtQ2QsSUFBbkMsQ0FBd0MsZUFBYXpCLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUXdDLFFBQVIsQ0FBaUIsR0FBakIsRUFBc0JDLElBQXRCLENBQTJCLE9BQTNCLENBQWIsR0FBaUQsUUFBakQsR0FBMER6QyxDQUFDLENBQUMsZ0NBQUQsQ0FBRCxDQUFvQ08sSUFBcEMsRUFBbEc7QUFDSCxPQUZELE1BRU87QUFDSFAsU0FBQyxDQUFDLHNCQUFELENBQUQsQ0FBMEIwQyxPQUExQjtBQUNIO0FBQ0o7QUFDSixHQVJEO0FBVUgsQ0EzR0Q7QUE2R0FDLEdBQUcsQ0FBQ0MsTUFBSixDQUFXQyxhQUFYLEdBQTJCLEtBQTNCO0FBRUE3QyxDQUFDLENBQUNDLFFBQUQsQ0FBRCxDQUFZQyxLQUFaLENBQWtCLFlBQVc7QUFFNUIsTUFBSTRDLEtBQUssR0FBRzlDLENBQUMsQ0FBQyxZQUFELENBQUQsQ0FBZ0IrQyxTQUFoQixDQUEwQjtBQUMvQjtBQUNBLGNBQVUsSUFGcUI7QUFHL0Isa0JBQWMsRUFIaUI7QUFJL0Isa0JBQWMsQ0FBQyxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLENBQUMsQ0FBZCxDQUFELEVBQW1CLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxFQUFULEVBQWEsS0FBYixDQUFuQjtBQUppQixHQUExQixDQUFaO0FBT0EvQyxHQUFDLENBQUMsY0FBRCxDQUFELENBQWtCZ0QsRUFBbEIsQ0FBc0IsT0FBdEIsRUFBK0IsVUFBVUMsQ0FBVixFQUFhO0FBQzFDQSxLQUFDLENBQUNDLGNBQUYsR0FEMEMsQ0FHdkM7O0FBQ0EsUUFBSUMsTUFBTSxHQUFHTCxLQUFLLENBQUNLLE1BQU4sQ0FBY25ELENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUXlDLElBQVIsQ0FBYSxhQUFiLENBQWQsQ0FBYixDQUp1QyxDQU12Qzs7QUFDQVUsVUFBTSxDQUFDQyxPQUFQLENBQWdCLENBQUVELE1BQU0sQ0FBQ0MsT0FBUCxFQUFsQjtBQUNELEdBUko7QUFTQSxDQWxCRDtBQW1CQXBELENBQUMsQ0FBQ0MsUUFBRCxDQUFELENBQVlDLEtBQVosQ0FBa0IsWUFBVztBQUUzQkYsR0FBQyxDQUFDLE1BQUQsQ0FBRCxDQUFVcUQsT0FBVixDQUFrQjtBQUFFQyxZQUFRLEVBQUU7QUFBWixHQUFsQjtBQUVBdEQsR0FBQyxDQUFDLG9CQUFELENBQUQsQ0FBd0J1RCxLQUF4QixDQUE4QixZQUFVO0FBQ3RDLFFBQUl2RCxDQUFDLENBQUMsbUJBQUQsQ0FBRCxDQUF1QjZCLEdBQXZCLENBQTJCLFFBQTNCLEtBQXdDLE9BQTVDLEVBQXFEO0FBQ25ENUIsY0FBUSxDQUFDdUQsY0FBVCxDQUF3QixxQkFBeEIsRUFBK0NELEtBQS9DO0FBQ0Q7QUFDRixHQUpEO0FBS0F2RCxHQUFDLENBQUMsb0JBQUQsQ0FBRCxDQUF3QnlELEtBQXhCLENBQThCLFlBQVU7QUFDdEMsUUFBSXpELENBQUMsQ0FBQyxtQkFBRCxDQUFELENBQXVCNkIsR0FBdkIsQ0FBMkIsUUFBM0IsS0FBd0MsT0FBNUMsRUFBcUQ7QUFDbkQ1QixjQUFRLENBQUN1RCxjQUFULENBQXdCLHFCQUF4QixFQUErQ0QsS0FBL0M7QUFDRDtBQUNGLEdBSkQ7QUFNRCxDQWZEO0FBaUJBOztBQUNBRyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLE1BQWpCLEdBQTBCLFVBQVNDLE1BQVQsRUFBZ0I7QUFFeEMsTUFBSUQsTUFBTSxHQUFHO0FBQ1gsZUFBMEIsT0FEZjtBQUVYLGNBQTBCLE1BRmY7QUFHWCxvQkFBMEIsT0FIZjtBQUlYLDZCQUEwQixRQUpmO0FBS1gscUJBQTBCLE1BTGY7QUFNWCx3QkFBMEIsT0FOZjtBQU9YLGVBQTBCLEtBUGY7QUFRWCw2QkFBMEIsU0FSZjtBQVNYLDZCQUEwQixPQVRmO0FBVVgsWUFBMEIsS0FWZjtBQVdYLGlCQUEwQixLQVhmO0FBWVgsbUNBQStCLE9BWnBCO0FBYVgsY0FBMEIsT0FiZjtBQWNYLGdCQUEwQixNQWRmO0FBZVgsa0JBQTBCLEtBZmY7QUFnQlgsb0JBQTBCLE1BaEJmO0FBaUJYLGFBQTBCLE1BakJmO0FBa0JYLGdCQUEwQjtBQWxCZixHQUFiO0FBcUJBLE1BQUlFLFFBQVEsR0FBRztBQUNiLGtCQUEyQixJQURkO0FBRWIsbUJBQTJCLE1BRmQ7QUFHYix1QkFBMkIsTUFIZDtBQUliLGdCQUEyQixJQUpkO0FBS2Isa0JBQTJCLElBTGQ7QUFNYixxQkFBMkIsTUFOZDtBQU9iLHlCQUEyQixNQVBkO0FBUWIsZ0JBQTJCLElBUmQ7QUFTYixjQUEyQixJQVRkO0FBVWIsZ0JBQTJCLElBVmQ7QUFXYixtQkFBMkIsUUFYZDtBQVliLHVCQUEyQixJQVpkO0FBYWIsaUJBQTJCLFFBYmQ7QUFjYixpQkFBMkIsU0FkZDtBQWViLDBCQUEyQixLQWZkO0FBZ0JiLGtCQUEyQixLQWhCZDtBQWlCYixnQkFBMkIsSUFqQmQ7QUFrQmIsZ0JBQTJCLElBbEJkO0FBbUJiLHVCQUEyQixNQW5CZDtBQW9CYiwrQkFBMkIsS0FwQmQ7QUFxQmIsb0JBQTJCLE9BckJkO0FBc0JiLHFFQUFpRSxTQXRCcEQ7QUF1QmIsZ0JBQTJCLE1BdkJkO0FBd0JiLGVBQTJCLE9BeEJkO0FBeUJiLG9CQUEyQixRQXpCZDtBQTBCYixrQkFBMkIsSUExQmQ7QUEyQmIsZUFBMkIsSUEzQmQ7QUE0QmIsVUFBMkI7QUE1QmQsR0FBZjtBQStCQSxNQUFJQyxTQUFTLEdBQUc7QUFDZCxZQUFXLE9BREc7QUFFZCxZQUFXLE1BRkc7QUFHZCxhQUFXLE9BSEc7QUFJZCxXQUFXLE9BSkc7QUFLZCxhQUFXLFVBTEc7QUFNZCxXQUFXLEtBTkc7QUFPZCxhQUFXLE9BUEc7QUFRZCxjQUFXO0FBUkcsR0FBaEI7QUFXQSxNQUFJQyxXQUFXLEdBQUcsQ0FDbEIsT0FEa0IsRUFFbEIsTUFGa0IsRUFHbEIsTUFIa0IsRUFJbEIsT0FKa0IsRUFLbEIsUUFMa0IsRUFNbEIsU0FOa0IsRUFPbEIsT0FQa0IsRUFRbEIsTUFSa0IsRUFTbEIsYUFUa0IsRUFVbEIsV0FWa0IsQ0FBbEIsQ0FqRXdDLENBOEV4Qzs7QUFDQSxNQUFHQSxXQUFXLENBQUN0QyxPQUFaLENBQW9CLEtBQUt1QyxXQUFMLEVBQXBCLEtBQTJDLENBQTlDLEVBQ0UsT0FBTyxJQUFQLENBaEZzQyxDQWtGeEM7O0FBQ0EsT0FBSUMsSUFBSixJQUFZSCxTQUFaLEVBQXNCO0FBRXBCLFFBQUdGLE1BQUgsRUFBVTtBQUNSLFVBQUlNLE9BQU8sR0FBRyxJQUFJQyxNQUFKLENBQVdMLFNBQVMsQ0FBQ0csSUFBRCxDQUFULEdBQWdCLEdBQTNCLEVBQWdDLEdBQWhDLENBQWQ7QUFDQSxVQUFJRyxPQUFPLEdBQUdILElBQWQ7QUFDRCxLQUhELE1BR007QUFBRSxVQUFJQyxPQUFPLEdBQUcsSUFBSUMsTUFBSixDQUFXRixJQUFJLEdBQUMsR0FBaEIsRUFBcUIsR0FBckIsQ0FBZDtBQUNSLFVBQUlHLE9BQU8sR0FBR04sU0FBUyxDQUFDRyxJQUFELENBQXZCO0FBQ0Q7O0FBQ0QsUUFBR0MsT0FBTyxDQUFDRyxJQUFSLENBQWEsSUFBYixDQUFILEVBQ0UsT0FBTyxLQUFLRCxPQUFMLENBQWFGLE9BQWIsRUFBc0JFLE9BQXRCLENBQVA7QUFDSDs7QUFFRCxNQUFHUixNQUFILEVBQVcsSUFBSVUsS0FBSyxHQUFHVCxRQUFaLENBQVgsS0FDTSxJQUFJUyxLQUFLLEdBQUdYLE1BQVosQ0FoR29DLENBa0d4Qzs7QUFDQSxPQUFJWSxHQUFKLElBQVdELEtBQVgsRUFBaUI7QUFFZixRQUFJSixPQUFPLEdBQUcsSUFBSUMsTUFBSixDQUFXSSxHQUFYLEVBQWdCLEdBQWhCLENBQWQ7QUFFQSxRQUFHTCxPQUFPLENBQUNHLElBQVIsQ0FBYSxJQUFiLENBQUgsRUFDRSxPQUFPLEtBQUtELE9BQUwsQ0FBYUYsT0FBYixFQUFzQkksS0FBSyxDQUFDQyxHQUFELENBQTNCLENBQVA7QUFDSDs7QUFFRCxTQUFPLElBQVA7QUFDRCxDQTVHRDs7QUE4R0F4RSxDQUFDLENBQUNDLFFBQUQsQ0FBRCxDQUFZQyxLQUFaLENBQWtCLFlBQVc7QUFDM0IsTUFBSTRDLEtBQUssR0FBRyxFQUFaO0FBQ0EsTUFBSTJCLE9BQU8sR0FBRyxDQUFkO0FBQ0EsTUFBSXRCLE1BQU0sR0FBRyxDQUFiO0FBRUE7O0FBQ0EsTUFBR25ELENBQUMsQ0FBQyxxQ0FBRCxDQUFELENBQXlDMEUsSUFBekMsQ0FBOEMsWUFBOUMsRUFBNERDLE1BQTVELElBQXNFLENBQXpFLEVBQTRFO0FBQzFFO0FBQ0EzRSxLQUFDLENBQUMsb0JBQUQsQ0FBRCxDQUF3QjRCLElBQXhCO0FBRUE7O0FBQ0E1QixLQUFDLENBQUMsa0JBQUQsQ0FBRCxDQUFzQmdELEVBQXRCLENBQXlCLE9BQXpCLEVBQWtDLFlBQVc7QUFDM0MsVUFBSTRCLEtBQUssR0FBRzVFLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUXNCLEdBQVIsR0FBYzJDLFdBQWQsRUFBWjtBQUNBakUsT0FBQyxDQUFDLG9CQUFELENBQUQsQ0FBd0I2RSxNQUF4QixDQUErQixZQUFXO0FBQ3hDN0UsU0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFROEUsTUFBUixDQUFlOUUsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRTyxJQUFSLEdBQWUwRCxXQUFmLEdBQTZCdkMsT0FBN0IsQ0FBcUNrRCxLQUFyQyxJQUE4QyxDQUFDLENBQTlEO0FBQ0QsT0FGRDtBQUdELEtBTEQ7QUFNRDtBQUVEOzs7QUFDQTVFLEdBQUMsQ0FBQyxhQUFELENBQUQsQ0FBaUJ1RCxLQUFqQixDQUF1QixVQUFTd0IsS0FBVCxFQUFnQjtBQUVyQ2pDLFNBQUssR0FBRzlDLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWdGLE9BQVIsQ0FBZ0IsT0FBaEIsRUFBeUJOLElBQXpCLENBQThCLE9BQTlCLENBQVI7QUFFQSxRQUFHMUUsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRK0IsUUFBUixDQUFpQixhQUFqQixDQUFILEVBQ0UvQixDQUFDLENBQUMsSUFBRCxDQUFELENBQVFpRixXQUFSLENBQW9CLGFBQXBCLEVBREYsS0FHRWpGLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWtGLFFBQVIsQ0FBaUIsYUFBakIsRUFQbUMsQ0FTckM7O0FBQ0EvQixVQUFNLEdBQUdiLFFBQVEsQ0FBQ3RDLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWdGLE9BQVIsQ0FBZ0IsR0FBaEIsRUFBcUJ2QyxJQUFyQixDQUEwQixhQUExQixDQUFELENBQVIsR0FBbUQsQ0FBNUQsQ0FWcUMsQ0FXckM7O0FBRUE7QUFBSTtBQUF1REssU0FBSyxDQUFDTCxJQUFOLENBQVcsSUFBWCxLQUFvQixXQUEvRSxFQUE0RjtBQUMxRkssV0FBSyxDQUFDNEIsSUFBTixDQUFXLGtCQUFnQnZCLE1BQWhCLEdBQXVCLEdBQWxDLEVBQXVDZ0MsSUFBdkMsQ0FBNEMsWUFBVztBQUNuRG5GLFNBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUThFLE1BQVI7QUFDSCxPQUZEO0FBR0FoQyxXQUFLLENBQUM0QixJQUFOLENBQVcsa0JBQWdCdkIsTUFBaEIsR0FBdUIsR0FBbEMsRUFBdUMyQixNQUF2QztBQUNEO0FBQ0YsR0FuQkQ7QUFvQkE5RSxHQUFDLENBQUMsYUFBRCxDQUFELENBQWlCbUYsSUFBakIsQ0FBc0IsWUFBVTtBQUM5QixRQUFHbkYsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRK0IsUUFBUixDQUFpQixjQUFqQixDQUFILEVBQ0UvQixDQUFDLENBQUMsSUFBRCxDQUFELENBQVF1RCxLQUFSO0FBQ0gsR0FIRDtBQUlELENBNUNEIiwiZmlsZSI6Ii4vcHVibGljL2JhY2tlbmQvanMvY3VzdG9tLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIGFsZXJ0XHJcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyIHRvIGRlbGV0ZVxyXG4gICAgICovXHJcbiAgICAgZGVsZXRlTWV0aG9kID0gIGZ1bmN0aW9uIChlbmNyeXB0ZWRfaWQpIHtcclxuICAgICAgICBzd2FsKHtcclxuICAgICAgICAgICAgdGl0bGU6IFwiQXJlIHlvdSBzdXJlP1wiLFxyXG4gICAgICAgICAgICB0ZXh0OiBcIlRoaXMgZGF0YSB3aWxsIGJlIGRlbGV0ZWQgcGVybWFuZW50bHkhXCIsXHJcbiAgICAgICAgICAgIGljb246IFwid2FybmluZ1wiLFxyXG4gICAgICAgICAgICBidXR0b25zOiB0cnVlLFxyXG4gICAgICAgICAgICBkYW5nZXJNb2RlOiB0cnVlLFxyXG4gICAgICAgIH0pLnRoZW4oKHdpbGxEZWxldGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHdpbGxEZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSsnL2RlbGV0ZS8nK2VuY3J5cHRlZF9pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmFjdGl2ZSBhbGVydFxyXG4gICAgICogQHBhcmFtIHBhcmFtZXRlciB0byBpbmFjdGl2ZVxyXG4gICAgICovXHJcbiAgICAgaW5hY3RpdmVNZXRob2QgPSAgZnVuY3Rpb24gKGVuY3J5cHRlZF9pZCkge1xyXG4gICAgICAgIHN3YWwoe1xyXG4gICAgICAgICAgICB0aXRsZTogXCJBcmUgeW91IHN1cmU/XCIsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiQWZ0ZXIgUmVtb3ZpbmcsIFlvdSBjYW4gcmVjb3ZlciBieSB1cGRhdGluZyBTVEFUVVMhXCIsXHJcbiAgICAgICAgICAgIGljb246IFwid2FybmluZ1wiLFxyXG4gICAgICAgICAgICBidXR0b25zOiB0cnVlLFxyXG4gICAgICAgICAgICBkYW5nZXJNb2RlOiB0cnVlLFxyXG4gICAgICAgIH0pLnRoZW4oKHdpbGxEZWxldGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHdpbGxEZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSsnL2luYWN0aXZlLycrZW5jcnlwdGVkX2lkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogIEFsbCBBYm91dCBTZWFyY2hcclxuICAgICAqL1xyXG4gICAgJCgnI3NlYXJjaEZpZWxkJykucHJvcCgnc2VsZWN0ZWRJbmRleCcsMCk7IC8vIFJlc2V0IFNlYXJjaCBTZWxlY3RcclxuICAgIHZhciBzZWFyY2hJdGVtcyA9IFwiJm5ic3A7XCIrXCJkaXNhYmxlZWRcIjtcclxuICAgIHZhciBjb3VudFNlbGVjdCA9IDA7XHJcbiAgICAkKFwic2VsZWN0XCIpLmNoYW5nZShmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBuZXdGaWVsZCA9ICcmbmJzcCcgKyAkKHRoaXMpLnZhbCgpICsgJyZuYnNwJztcclxuICAgICAgICBpZihuZXdGaWVsZCAhPSBudWxsICYmIG5ld0ZpZWxkICE9IFwiXCIpe1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9ICQoXCIjc2VhcmNoRmllbGQgb3B0aW9uOnNlbGVjdGVkXCIpLnRleHQoKTtcclxuICAgICAgICAgICAgdmFyIGh0bWwgPSBcIjxkaXYgc3R5bGU9XFxcIm1hcmdpbjogNHB4IDA7XFxcIiBjbGFzcz1cXFwiY29sLW1kLTJcXFwiPlxcblwiICtcclxuICAgICAgICAgICAgXCI8aW5wdXQgaWQ9J3NlYXJjaCcgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwiXCIgKyBuYW1lICsgXCJcXFwiIHBsYWNlaG9sZGVyPVxcXCJcIiArIHBsYWNlaG9sZGVyICsgXCJcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiPlxcblwiICArXHJcbiAgICAgICAgICAgIFwiPC9kaXY+XCI7XHJcbiAgICAgICAgICAgIGlmKHNlYXJjaEl0ZW1zLmluZGV4T2YobmV3RmllbGQpID09IC0xKXtcclxuICAgICAgICAgICAgICAgIGNvdW50U2VsZWN0ID0gY291bnRTZWxlY3QgKyAxO1xyXG4gICAgICAgICAgICAgICAgJChcIi5zZWFyY2gtZmllbGRcIikuYXBwZW5kKGh0bWwpO1xyXG4gICAgICAgICAgICAgICAgJChcIiNzZWFyY2hGb3JtXCIpLnNob3coKTtcclxuICAgICAgICAgICAgICAgICQoXCIjc2VhcmNoQnV0dG9uXCIpLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHNlYXJjaEl0ZW1zID0gc2VhcmNoSXRlbXMgKyBuZXdGaWVsZCArICcmbmJzcDsnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50U2VsZWN0ID4gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICQoXCIjc2VhcmNoQnV0dG9uXCIpLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vJ21hcmdpbi1sZWZ0JzogJzVweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vJ21hcmdpbi10b3AnOiAnNXB4J1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKlxyXG4gICAgKiBBdnJvIEJhbmdsYVxyXG4gICAgKi9cclxuXHJcbiAgICAkKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPW51bWJlcl0sIGlucHV0W3R5cGU9ZW1haWxdLCBpbnB1dFt0eXBlPXNlYXJjaF0nKS5mb2N1cyhmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdhdnJvX2JuJykpIHtcclxuICAgICAgICAgICAgJCgnLmxhbmdfcGVuJykudGV4dCgn4Kas4Ka+4KaC4Kay4Ka+ICcpO1xyXG4gICAgICAgICAgICAkKCcubGFuZ19wZW5fcGFyZW50Jykuc2hvdygpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAkKCcubGFuZ19wZW4nKS50ZXh0KCdFbmcgJyk7XHJcbiAgICAgICAgICAgICQoJy5sYW5nX3Blbl9wYXJlbnQnKS5zaG93KCk7XHJcbiAgICAgICAgfSBcclxuICAgICAgICAkKHRoaXMpLmJsdXIoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgJCgnLmxhbmdfcGVuX3BhcmVudCcpLmhpZGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgJCgndGV4dGFyZWEnKS5mb2N1cyhmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdhdnJvX2JuJykpIHtcclxuICAgICAgICAgICAgJCgnLmxhbmdfcGVuJykudGV4dCgn4Kas4Ka+4KaC4Kay4Ka+ICcpO1xyXG4gICAgICAgICAgICAkKCcubGFuZ19wZW5fcGFyZW50Jykuc2hvdygpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAkKCcubGFuZ19wZW4nKS50ZXh0KCdFbmcgJyk7XHJcbiAgICAgICAgICAgICQoJy5sYW5nX3Blbl9wYXJlbnQnKS5zaG93KCk7XHJcbiAgICAgICAgfSBcclxuICAgICAgICAkKHRoaXMpLmJsdXIoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgJCgnLmxhbmdfcGVuX3BhcmVudCcpLmhpZGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBcclxuICAgIC8vIGFsZXJ0KCQoJ2gxJykuY2hpbGRyZW4oJ2knKS5hdHRyKCdjbGFzcycpKTtcclxuICAgICQod2luZG93KS5zY3JvbGwoZnVuY3Rpb24oKXtcclxuICAgICAgICBpZiAoJCh3aW5kb3cpLndpZHRoKCkgPj0gNzY4KSB7XHJcbiAgICAgICAgICAgIGlmICgkKHdpbmRvdykuc2Nyb2xsVG9wKCkgPiAkKCcuYXBwLWhlYWRlcicpLmhlaWdodCgpIC0gMzAgKyAkKCcuY2FyZC1oZWFkZXInKS5oZWlnaHQoKSArIC8qJCgnLmFwcC10aXRsZScpLmhlaWdodCgpICsqLyBwYXJzZUludCgkKCcuYXBwLXRpdGxlJykuY3NzKCdtYXJnaW4tYm90dG9tJykpKSB7XHJcbiAgICAgICAgICAgICAgICAkKCcuYXBwLW5hdl9jdXN0b21faXRlbScpLmZhZGVJbigpLmh0bWwoJzxpIGNsYXNzPVwiJyskKCdoMScpLmNoaWxkcmVuKCdpJykuYXR0cignY2xhc3MnKSsnXCI+PC9pPicrJCgnLmNhcmQtaGVhZGVyIC5yb3cgLmNvbC1tZC02IGgyJykudGV4dCgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICQoJy5hcHAtbmF2X2N1c3RvbV9pdGVtJykuZmFkZU91dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxufSk7XHJcblxyXG5WdWUuY29uZmlnLnByb2R1Y3Rpb25UaXAgPSBmYWxzZTtcclxuXHJcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cclxuIHZhciB0YWJsZSA9ICQoJyNkYXRhdGFibGUnKS5EYXRhVGFibGUoe1xyXG4gICAgICAgIC8vIFwic2Nyb2xsWVwiOiBcIjM1MHB4XCIsXHJcbiAgICAgICAgXCJwYWdpbmdcIjogdHJ1ZSxcclxuICAgICAgICBcInBhZ2VMZW5ndGhcIjogNTAsXHJcbiAgICAgICAgXCJsZW5ndGhNZW51XCI6IFtbMTAsIDI1LCA1MCwgLTFdLCBbMTAsIDI1LCA1MCwgXCJBbGxcIl1dXHJcbiAgICAgIH0pO1xyXG5cclxuICQoJ2EudG9nZ2xlLXZpcycpLm9uKCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAvLyBHZXQgdGhlIGNvbHVtbiBBUEkgb2JqZWN0XHJcbiAgICAgIHZhciBjb2x1bW4gPSB0YWJsZS5jb2x1bW4oICQodGhpcykuYXR0cignZGF0YS1jb2x1bW4nKSApO1xyXG5cclxuICAgICAgLy8gVG9nZ2xlIHRoZSB2aXNpYmlsaXR5XHJcbiAgICAgIGNvbHVtbi52aXNpYmxlKCAhIGNvbHVtbi52aXNpYmxlKCkgKTtcclxuICAgIH0pO1xyXG59KTtcclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblxyXG4gICQoXCJib2R5XCIpLnRvb2x0aXAoeyBzZWxlY3RvcjogJ1tkYXRhLXRvZ2dsZT10b29sdGlwXScgfSk7XHJcblxyXG4gICQoXCIuc2ltcGxlYmFyLWNvbnRlbnRcIikuY2xpY2soZnVuY3Rpb24oKXtcclxuICAgIGlmICgkKFwiLnNpbXBsZWJhci1vZmZzZXRcIikuY3NzKCdib3R0b20nKSA9PSAnLTE3cHgnKSB7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAtc2lkZWJhcl9fdG9nZ2xlJykuY2xpY2soKTtcclxuICAgIH1cclxuICB9KTtcclxuICAkKFwiLnNpbXBsZWJhci1jb250ZW50XCIpLmhvdmVyKGZ1bmN0aW9uKCl7XHJcbiAgICBpZiAoJChcIi5zaW1wbGViYXItb2Zmc2V0XCIpLmNzcygnYm90dG9tJykgPT0gJy0xN3B4Jykge1xyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwLXNpZGViYXJfX3RvZ2dsZScpLmNsaWNrKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG59KTtcclxuXHJcbi8qamF2YXNjcmlwdCBwbHVyYWxpemUgYSBzdHJpbmcqL1xyXG5TdHJpbmcucHJvdG90eXBlLnBsdXJhbCA9IGZ1bmN0aW9uKHJldmVydCl7XHJcblxyXG4gIHZhciBwbHVyYWwgPSB7XHJcbiAgICAnKHF1aXopJCcgICAgICAgICAgICAgICA6IFwiJDF6ZXNcIixcclxuICAgICdeKG94KSQnICAgICAgICAgICAgICAgIDogXCIkMWVuXCIsXHJcbiAgICAnKFttfGxdKW91c2UkJyAgICAgICAgICA6IFwiJDFpY2VcIixcclxuICAgICcobWF0cnx2ZXJ0fGluZClpeHxleCQnIDogXCIkMWljZXNcIixcclxuICAgICcoeHxjaHxzc3xzaCkkJyAgICAgICAgIDogXCIkMWVzXCIsXHJcbiAgICAnKFteYWVpb3V5XXxxdSl5JCcgICAgICA6IFwiJDFpZXNcIixcclxuICAgICcoaGl2ZSkkJyAgICAgICAgICAgICAgIDogXCIkMXNcIixcclxuICAgICcoPzooW15mXSlmZXwoW2xyXSlmKSQnIDogXCIkMSQydmVzXCIsXHJcbiAgICAnKHNoZWF8bGVhfGxvYXx0aGllKWYkJyA6IFwiJDF2ZXNcIixcclxuICAgICdzaXMkJyAgICAgICAgICAgICAgICAgIDogXCJzZXNcIixcclxuICAgICcoW3RpXSl1bSQnICAgICAgICAgICAgIDogXCIkMWFcIixcclxuICAgICcodG9tYXR8cG90YXR8ZWNofGhlcnx2ZXQpbyQnOiBcIiQxb2VzXCIsXHJcbiAgICAnKGJ1KXMkJyAgICAgICAgICAgICAgICA6IFwiJDFzZXNcIixcclxuICAgICcoYWxpYXMpJCcgICAgICAgICAgICAgIDogXCIkMWVzXCIsXHJcbiAgICAnKG9jdG9wKXVzJCcgICAgICAgICAgICA6IFwiJDFpXCIsXHJcbiAgICAnKGF4fHRlc3QpaXMkJyAgICAgICAgICA6IFwiJDFlc1wiLFxyXG4gICAgJyh1cykkJyAgICAgICAgICAgICAgICAgOiBcIiQxZXNcIixcclxuICAgICcoW15zXSspJCcgICAgICAgICAgICAgIDogXCIkMXNcIlxyXG4gIH07XHJcblxyXG4gIHZhciBzaW5ndWxhciA9IHtcclxuICAgICcocXVpeil6ZXMkJyAgICAgICAgICAgICA6IFwiJDFcIixcclxuICAgICcobWF0cilpY2VzJCcgICAgICAgICAgICA6IFwiJDFpeFwiLFxyXG4gICAgJyh2ZXJ0fGluZClpY2VzJCcgICAgICAgIDogXCIkMWV4XCIsXHJcbiAgICAnXihveCllbiQnICAgICAgICAgICAgICAgOiBcIiQxXCIsXHJcbiAgICAnKGFsaWFzKWVzJCcgICAgICAgICAgICAgOiBcIiQxXCIsXHJcbiAgICAnKG9jdG9wfHZpcilpJCcgICAgICAgICAgOiBcIiQxdXNcIixcclxuICAgICcoY3Jpc3xheHx0ZXN0KWVzJCcgICAgICA6IFwiJDFpc1wiLFxyXG4gICAgJyhzaG9lKXMkJyAgICAgICAgICAgICAgIDogXCIkMVwiLFxyXG4gICAgJyhvKWVzJCcgICAgICAgICAgICAgICAgIDogXCIkMVwiLFxyXG4gICAgJyhidXMpZXMkJyAgICAgICAgICAgICAgIDogXCIkMVwiLFxyXG4gICAgJyhbbXxsXSlpY2UkJyAgICAgICAgICAgIDogXCIkMW91c2VcIixcclxuICAgICcoeHxjaHxzc3xzaCllcyQnICAgICAgICA6IFwiJDFcIixcclxuICAgICcobSlvdmllcyQnICAgICAgICAgICAgICA6IFwiJDFvdmllXCIsXHJcbiAgICAnKHMpZXJpZXMkJyAgICAgICAgICAgICAgOiBcIiQxZXJpZXNcIixcclxuICAgICcoW15hZWlvdXldfHF1KWllcyQnICAgICA6IFwiJDF5XCIsXHJcbiAgICAnKFtscl0pdmVzJCcgICAgICAgICAgICAgOiBcIiQxZlwiLFxyXG4gICAgJyh0aXZlKXMkJyAgICAgICAgICAgICAgIDogXCIkMVwiLFxyXG4gICAgJyhoaXZlKXMkJyAgICAgICAgICAgICAgIDogXCIkMVwiLFxyXG4gICAgJyhsaXx3aXxrbmkpdmVzJCcgICAgICAgIDogXCIkMWZlXCIsXHJcbiAgICAnKHNoZWF8bG9hfGxlYXx0aGllKXZlcyQnOiBcIiQxZlwiLFxyXG4gICAgJyheYW5hbHkpc2VzJCcgICAgICAgICAgIDogXCIkMXNpc1wiLFxyXG4gICAgJygoYSluYWx5fChiKWF8KGQpaWFnbm98KHApYXJlbnRoZXwocClyb2dub3wocyl5bm9wfCh0KWhlKXNlcyQnOiBcIiQxJDJzaXNcIiwgICAgICAgIFxyXG4gICAgJyhbdGldKWEkJyAgICAgICAgICAgICAgIDogXCIkMXVtXCIsXHJcbiAgICAnKG4pZXdzJCcgICAgICAgICAgICAgICAgOiBcIiQxZXdzXCIsXHJcbiAgICAnKGh8Ymwpb3VzZXMkJyAgICAgICAgICAgOiBcIiQxb3VzZVwiLFxyXG4gICAgJyhjb3Jwc2UpcyQnICAgICAgICAgICAgIDogXCIkMVwiLFxyXG4gICAgJyh1cyllcyQnICAgICAgICAgICAgICAgIDogXCIkMVwiLFxyXG4gICAgJ3MkJyAgICAgICAgICAgICAgICAgICAgIDogXCJcIlxyXG4gIH07XHJcblxyXG4gIHZhciBpcnJlZ3VsYXIgPSB7XHJcbiAgICAnbW92ZScgICA6ICdtb3ZlcycsXHJcbiAgICAnZm9vdCcgICA6ICdmZWV0JyxcclxuICAgICdnb29zZScgIDogJ2dlZXNlJyxcclxuICAgICdzZXgnICAgIDogJ3NleGVzJyxcclxuICAgICdjaGlsZCcgIDogJ2NoaWxkcmVuJyxcclxuICAgICdtYW4nICAgIDogJ21lbicsXHJcbiAgICAndG9vdGgnICA6ICd0ZWV0aCcsXHJcbiAgICAncGVyc29uJyA6ICdwZW9wbGUnXHJcbiAgfTtcclxuXHJcbiAgdmFyIHVuY291bnRhYmxlID0gW1xyXG4gICdzaGVlcCcsIFxyXG4gICdmaXNoJyxcclxuICAnZGVlcicsXHJcbiAgJ21vb3NlJyxcclxuICAnc2VyaWVzJyxcclxuICAnc3BlY2llcycsXHJcbiAgJ21vbmV5JyxcclxuICAncmljZScsXHJcbiAgJ2luZm9ybWF0aW9uJyxcclxuICAnZXF1aXBtZW50J1xyXG4gIF07XHJcblxyXG4gIC8vIHNhdmUgc29tZSB0aW1lIGluIHRoZSBjYXNlIHRoYXQgc2luZ3VsYXIgYW5kIHBsdXJhbCBhcmUgdGhlIHNhbWVcclxuICBpZih1bmNvdW50YWJsZS5pbmRleE9mKHRoaXMudG9Mb3dlckNhc2UoKSkgPj0gMClcclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyBjaGVjayBmb3IgaXJyZWd1bGFyIGZvcm1zXHJcbiAgZm9yKHdvcmQgaW4gaXJyZWd1bGFyKXtcclxuXHJcbiAgICBpZihyZXZlcnQpe1xyXG4gICAgICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoaXJyZWd1bGFyW3dvcmRdKyckJywgJ2knKTtcclxuICAgICAgdmFyIHJlcGxhY2UgPSB3b3JkO1xyXG4gICAgfSBlbHNleyB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAod29yZCsnJCcsICdpJyk7XHJcbiAgICB2YXIgcmVwbGFjZSA9IGlycmVndWxhclt3b3JkXTtcclxuICB9XHJcbiAgaWYocGF0dGVybi50ZXN0KHRoaXMpKVxyXG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlKTtcclxufVxyXG5cclxuaWYocmV2ZXJ0KSB2YXIgYXJyYXkgPSBzaW5ndWxhcjtcclxuZWxzZSAgdmFyIGFycmF5ID0gcGx1cmFsO1xyXG5cclxuICAvLyBjaGVjayBmb3IgbWF0Y2hlcyB1c2luZyByZWd1bGFyIGV4cHJlc3Npb25zXHJcbiAgZm9yKHJlZyBpbiBhcnJheSl7XHJcblxyXG4gICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHJlZywgJ2knKTtcclxuXHJcbiAgICBpZihwYXR0ZXJuLnRlc3QodGhpcykpXHJcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UocGF0dGVybiwgYXJyYXlbcmVnXSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHRhYmxlID0gJyc7XHJcbiAgdmFyIGFfaW5kZXggPSAwO1xyXG4gIHZhciBjb2x1bW4gPSAwO1xyXG5cclxuICAvKmNoZWNraW5nIHdoZWF0aGVyIGRhdGF0YWJsZSBoYXMgYmVlbiBjYWxsZWQgb3Igbm90Ki9cclxuICBpZigkKCcuY2FyZC1ib2R5W2RhdGEtbXktdGFibGU9XCJ0YWJsZS0xXCJdJykuZmluZCgnI2RhdGF0YWJsZScpLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAvKnNob3dpbmcgbXkgcGFnaW5hdGlvbiovXHJcbiAgICAkKCcuY3VzdG9tX3BhZ2luYXRpb24nKS5zaG93KCk7XHJcblxyXG4gICAgLyp0YWJsZSBzZWFyY2gqL1xyXG4gICAgJChcIiNteS10YWJsZS1zZWFyY2hcIikub24oXCJrZXl1cFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHZhbHVlID0gJCh0aGlzKS52YWwoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAkKFwiI215LXRhYmxlIHRib2R5IHRyXCIpLmZpbHRlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAkKHRoaXMpLnRvZ2dsZSgkKHRoaXMpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsdWUpID4gLTEpXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKmNvbG9yaW5nIGNvbHVtbiB0aXRsZSBvbiBoaWRlL3Nob3cqL1xyXG4gICQoJy50b2dnbGUtdmlzJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcclxuXHJcbiAgICB0YWJsZSA9ICQodGhpcykuY2xvc2VzdCgnLmNhcmQnKS5maW5kKCd0YWJsZScpO1xyXG5cclxuICAgIGlmKCQodGhpcykuaGFzQ2xhc3MoJ3RleHQtZGFuZ2VyJykpXHJcbiAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ3RleHQtZGFuZ2VyJyk7XHJcbiAgICBlbHNlXHJcbiAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3RleHQtZGFuZ2VyJyk7XHJcblxyXG4gICAgLy9hX2luZGV4ID0gJCh0aGlzKS5pbmRleCgpO1xyXG4gICAgY29sdW1uID0gcGFyc2VJbnQoJCh0aGlzKS5jbG9zZXN0KCdhJykuYXR0cignZGF0YS1jb2x1bW4nKSkrMTtcclxuICAgIC8vIGNvbnNvbGUubG9nKGNvbHVtbik7XHJcblxyXG4gICAgaWYgKC8qZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhZ2luYXRpb25fY29udGFpbmVyJykgJiYgKi90YWJsZS5hdHRyKCdpZCcpICE9ICdkYXRhdGFibGUnKSB7XHJcbiAgICAgIHRhYmxlLmZpbmQoJ3RkOm50aC1jaGlsZCgnK2NvbHVtbisnKScpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAkKHRoaXMpLnRvZ2dsZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgdGFibGUuZmluZCgndGg6bnRoLWNoaWxkKCcrY29sdW1uKycpJykudG9nZ2xlKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgJCgnLnRvZ2dsZS12aXMnKS5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICBpZigkKHRoaXMpLmhhc0NsYXNzKCdoaWRlLW9uLWxvYWQnKSlcclxuICAgICAgJCh0aGlzKS5jbGljaygpO1xyXG4gIH0pO1xyXG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/backend/js/custom.js\n");

/***/ }),

/***/ "./public/backend/js/main.js":
/*!***********************************!*\
  !*** ./public/backend/js/main.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function () {\n  \"use strict\";\n\n  var treeviewMenu = $('.app-menu'); // Toggle Sidebar\n\n  $('[data-toggle=\"sidebar\"]').click(function (event) {\n    event.preventDefault();\n    $('.app').toggleClass('sidenav-toggled');\n  }); // Activate sidebar treeview toggle\n\n  $(\"[data-toggle='treeview']\").click(function (event) {\n    event.preventDefault();\n\n    if (!$(this).parent().hasClass('is-expanded')) {\n      treeviewMenu.find(\"[data-toggle='treeview']\").parent().removeClass('is-expanded');\n    }\n\n    $(this).parent().toggleClass('is-expanded');\n  }); // Set initial active toggle\n\n  $(\"[data-toggle='treeview.'].is-expanded\").parent().toggleClass('is-expanded'); //Activate bootstrip tooltips\n\n  $(\"[data-toggle='tooltip']\").tooltip();\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvYmFja2VuZC9qcy9tYWluLmpzPzE0OGQiXSwibmFtZXMiOlsidHJlZXZpZXdNZW51IiwiJCIsImNsaWNrIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInRvZ2dsZUNsYXNzIiwicGFyZW50IiwiaGFzQ2xhc3MiLCJmaW5kIiwicmVtb3ZlQ2xhc3MiLCJ0b29sdGlwIl0sIm1hcHBpbmdzIjoiQUFBQSxDQUFDLFlBQVk7QUFDWjs7QUFDQSxNQUFJQSxZQUFZLEdBQUdDLENBQUMsQ0FBQyxXQUFELENBQXBCLENBRlksQ0FJWjs7QUFDQUEsR0FBQyxDQUFDLHlCQUFELENBQUQsQ0FBNkJDLEtBQTdCLENBQW1DLFVBQVNDLEtBQVQsRUFBZ0I7QUFDbERBLFNBQUssQ0FBQ0MsY0FBTjtBQUNBSCxLQUFDLENBQUMsTUFBRCxDQUFELENBQVVJLFdBQVYsQ0FBc0IsaUJBQXRCO0FBQ0EsR0FIRCxFQUxZLENBVVo7O0FBQ0FKLEdBQUMsQ0FBQywwQkFBRCxDQUFELENBQThCQyxLQUE5QixDQUFvQyxVQUFTQyxLQUFULEVBQWdCO0FBQ25EQSxTQUFLLENBQUNDLGNBQU47O0FBQ0EsUUFBRyxDQUFDSCxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFLLE1BQVIsR0FBaUJDLFFBQWpCLENBQTBCLGFBQTFCLENBQUosRUFBOEM7QUFDN0NQLGtCQUFZLENBQUNRLElBQWIsQ0FBa0IsMEJBQWxCLEVBQThDRixNQUE5QyxHQUF1REcsV0FBdkQsQ0FBbUUsYUFBbkU7QUFDQTs7QUFDRFIsS0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRSyxNQUFSLEdBQWlCRCxXQUFqQixDQUE2QixhQUE3QjtBQUNBLEdBTkQsRUFYWSxDQW1CWjs7QUFDQUosR0FBQyxDQUFDLHVDQUFELENBQUQsQ0FBMkNLLE1BQTNDLEdBQW9ERCxXQUFwRCxDQUFnRSxhQUFoRSxFQXBCWSxDQXNCWjs7QUFDQUosR0FBQyxDQUFDLHlCQUFELENBQUQsQ0FBNkJTLE9BQTdCO0FBRUEsQ0F6QkQiLCJmaWxlIjoiLi9wdWJsaWMvYmFja2VuZC9qcy9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uICgpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHR2YXIgdHJlZXZpZXdNZW51ID0gJCgnLmFwcC1tZW51Jyk7XHJcblxyXG5cdC8vIFRvZ2dsZSBTaWRlYmFyXHJcblx0JCgnW2RhdGEtdG9nZ2xlPVwic2lkZWJhclwiXScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0JCgnLmFwcCcpLnRvZ2dsZUNsYXNzKCdzaWRlbmF2LXRvZ2dsZWQnKTtcclxuXHR9KTtcclxuXHJcblx0Ly8gQWN0aXZhdGUgc2lkZWJhciB0cmVldmlldyB0b2dnbGVcclxuXHQkKFwiW2RhdGEtdG9nZ2xlPSd0cmVldmlldyddXCIpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0aWYoISQodGhpcykucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWV4cGFuZGVkJykpIHtcclxuXHRcdFx0dHJlZXZpZXdNZW51LmZpbmQoXCJbZGF0YS10b2dnbGU9J3RyZWV2aWV3J11cIikucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2lzLWV4cGFuZGVkJyk7XHJcblx0XHR9XHJcblx0XHQkKHRoaXMpLnBhcmVudCgpLnRvZ2dsZUNsYXNzKCdpcy1leHBhbmRlZCcpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBTZXQgaW5pdGlhbCBhY3RpdmUgdG9nZ2xlXHJcblx0JChcIltkYXRhLXRvZ2dsZT0ndHJlZXZpZXcuJ10uaXMtZXhwYW5kZWRcIikucGFyZW50KCkudG9nZ2xlQ2xhc3MoJ2lzLWV4cGFuZGVkJyk7XHJcblxyXG5cdC8vQWN0aXZhdGUgYm9vdHN0cmlwIHRvb2x0aXBzXHJcblx0JChcIltkYXRhLXRvZ2dsZT0ndG9vbHRpcCddXCIpLnRvb2x0aXAoKTtcclxuXHJcbn0pKCk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./public/backend/js/main.js\n");

/***/ }),

/***/ "./public/backend/js/simplebar.js":
/*!****************************************!*\
  !*** ./public/backend/js/simplebar.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * SimpleBar.js - v5.1.0\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var O = 'object';\n\n  var check = function check(it) {\n    return it && it.Math == Math && it;\n  }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\n\n  var global_1 = // eslint-disable-next-line no-undef\n  check((typeof globalThis === \"undefined\" ? \"undefined\" : _typeof(globalThis)) == O && globalThis) || check((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == O && window) || check((typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == O && self) || check(_typeof(commonjsGlobal) == O && commonjsGlobal) || // eslint-disable-next-line no-new-func\n  Function('return this')();\n\n  var fails = function fails(exec) {\n    try {\n      return !!exec();\n    } catch (error) {\n      return true;\n    }\n  }; // Thank's IE8 for his funny defineProperty\n\n\n  var descriptors = !fails(function () {\n    return Object.defineProperty({}, 'a', {\n      get: function get() {\n        return 7;\n      }\n    }).a != 7;\n  });\n  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug\n\n  var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({\n    1: 2\n  }, 1); // `Object.prototype.propertyIsEnumerable` method implementation\n  // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable\n\n  var f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n    var descriptor = getOwnPropertyDescriptor(this, V);\n    return !!descriptor && descriptor.enumerable;\n  } : nativePropertyIsEnumerable;\n  var objectPropertyIsEnumerable = {\n    f: f\n  };\n\n  var createPropertyDescriptor = function createPropertyDescriptor(bitmap, value) {\n    return {\n      enumerable: !(bitmap & 1),\n      configurable: !(bitmap & 2),\n      writable: !(bitmap & 4),\n      value: value\n    };\n  };\n\n  var toString = {}.toString;\n\n  var classofRaw = function classofRaw(it) {\n    return toString.call(it).slice(8, -1);\n  };\n\n  var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings\n\n  var indexedObject = fails(function () {\n    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n    // eslint-disable-next-line no-prototype-builtins\n    return !Object('z').propertyIsEnumerable(0);\n  }) ? function (it) {\n    return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n  } : Object; // `RequireObjectCoercible` abstract operation\n  // https://tc39.github.io/ecma262/#sec-requireobjectcoercible\n\n  var requireObjectCoercible = function requireObjectCoercible(it) {\n    if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n    return it;\n  }; // toObject with fallback for non-array-like ES3 strings\n\n\n  var toIndexedObject = function toIndexedObject(it) {\n    return indexedObject(requireObjectCoercible(it));\n  };\n\n  var isObject = function isObject(it) {\n    return _typeof(it) === 'object' ? it !== null : typeof it === 'function';\n  }; // `ToPrimitive` abstract operation\n  // https://tc39.github.io/ecma262/#sec-toprimitive\n  // instead of the ES6 spec version, we didn't implement @@toPrimitive case\n  // and the second argument - flag - preferred type is a string\n\n\n  var toPrimitive = function toPrimitive(input, PREFERRED_STRING) {\n    if (!isObject(input)) return input;\n    var fn, val;\n    if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n    if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n    if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n    throw TypeError(\"Can't convert object to primitive value\");\n  };\n\n  var hasOwnProperty = {}.hasOwnProperty;\n\n  var has = function has(it, key) {\n    return hasOwnProperty.call(it, key);\n  };\n\n  var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE\n\n  var EXISTS = isObject(document$1) && isObject(document$1.createElement);\n\n  var documentCreateElement = function documentCreateElement(it) {\n    return EXISTS ? document$1.createElement(it) : {};\n  }; // Thank's IE8 for his funny defineProperty\n\n\n  var ie8DomDefine = !descriptors && !fails(function () {\n    return Object.defineProperty(documentCreateElement('div'), 'a', {\n      get: function get() {\n        return 7;\n      }\n    }).a != 7;\n  });\n  var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\n\n  var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n    O = toIndexedObject(O);\n    P = toPrimitive(P, true);\n    if (ie8DomDefine) try {\n      return nativeGetOwnPropertyDescriptor(O, P);\n    } catch (error) {\n      /* empty */\n    }\n    if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n  };\n  var objectGetOwnPropertyDescriptor = {\n    f: f$1\n  };\n\n  var anObject = function anObject(it) {\n    if (!isObject(it)) {\n      throw TypeError(String(it) + ' is not an object');\n    }\n\n    return it;\n  };\n\n  var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method\n  // https://tc39.github.io/ecma262/#sec-object.defineproperty\n\n  var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n    anObject(O);\n    P = toPrimitive(P, true);\n    anObject(Attributes);\n    if (ie8DomDefine) try {\n      return nativeDefineProperty(O, P, Attributes);\n    } catch (error) {\n      /* empty */\n    }\n    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n    if ('value' in Attributes) O[P] = Attributes.value;\n    return O;\n  };\n  var objectDefineProperty = {\n    f: f$2\n  };\n  var hide = descriptors ? function (object, key, value) {\n    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n  } : function (object, key, value) {\n    object[key] = value;\n    return object;\n  };\n\n  var setGlobal = function setGlobal(key, value) {\n    try {\n      hide(global_1, key, value);\n    } catch (error) {\n      global_1[key] = value;\n    }\n\n    return value;\n  };\n\n  var shared = createCommonjsModule(function (module) {\n    var SHARED = '__core-js_shared__';\n    var store = global_1[SHARED] || setGlobal(SHARED, {});\n    (module.exports = function (key, value) {\n      return store[key] || (store[key] = value !== undefined ? value : {});\n    })('versions', []).push({\n      version: '3.2.1',\n      mode: 'global',\n      copyright: '© 2019 Denis Pushkarev (zloirock.ru)'\n    });\n  });\n  var functionToString = shared('native-function-to-string', Function.toString);\n  var WeakMap$1 = global_1.WeakMap;\n  var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(functionToString.call(WeakMap$1));\n  var id = 0;\n  var postfix = Math.random();\n\n  var uid = function uid(key) {\n    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n  };\n\n  var keys = shared('keys');\n\n  var sharedKey = function sharedKey(key) {\n    return keys[key] || (keys[key] = uid(key));\n  };\n\n  var hiddenKeys = {};\n  var WeakMap$2 = global_1.WeakMap;\n  var set, get, has$1;\n\n  var enforce = function enforce(it) {\n    return has$1(it) ? get(it) : set(it, {});\n  };\n\n  var getterFor = function getterFor(TYPE) {\n    return function (it) {\n      var state;\n\n      if (!isObject(it) || (state = get(it)).type !== TYPE) {\n        throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n      }\n\n      return state;\n    };\n  };\n\n  if (nativeWeakMap) {\n    var store = new WeakMap$2();\n    var wmget = store.get;\n    var wmhas = store.has;\n    var wmset = store.set;\n\n    set = function set(it, metadata) {\n      wmset.call(store, it, metadata);\n      return metadata;\n    };\n\n    get = function get(it) {\n      return wmget.call(store, it) || {};\n    };\n\n    has$1 = function has$1(it) {\n      return wmhas.call(store, it);\n    };\n  } else {\n    var STATE = sharedKey('state');\n    hiddenKeys[STATE] = true;\n\n    set = function set(it, metadata) {\n      hide(it, STATE, metadata);\n      return metadata;\n    };\n\n    get = function get(it) {\n      return has(it, STATE) ? it[STATE] : {};\n    };\n\n    has$1 = function has$1(it) {\n      return has(it, STATE);\n    };\n  }\n\n  var internalState = {\n    set: set,\n    get: get,\n    has: has$1,\n    enforce: enforce,\n    getterFor: getterFor\n  };\n  var redefine = createCommonjsModule(function (module) {\n    var getInternalState = internalState.get;\n    var enforceInternalState = internalState.enforce;\n    var TEMPLATE = String(functionToString).split('toString');\n    shared('inspectSource', function (it) {\n      return functionToString.call(it);\n    });\n    (module.exports = function (O, key, value, options) {\n      var unsafe = options ? !!options.unsafe : false;\n      var simple = options ? !!options.enumerable : false;\n      var noTargetGet = options ? !!options.noTargetGet : false;\n\n      if (typeof value == 'function') {\n        if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);\n        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');\n      }\n\n      if (O === global_1) {\n        if (simple) O[key] = value;else setGlobal(key, value);\n        return;\n      } else if (!unsafe) {\n        delete O[key];\n      } else if (!noTargetGet && O[key]) {\n        simple = true;\n      }\n\n      if (simple) O[key] = value;else hide(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n    })(Function.prototype, 'toString', function toString() {\n      return typeof this == 'function' && getInternalState(this).source || functionToString.call(this);\n    });\n  });\n  var path = global_1;\n\n  var aFunction = function aFunction(variable) {\n    return typeof variable == 'function' ? variable : undefined;\n  };\n\n  var getBuiltIn = function getBuiltIn(namespace, method) {\n    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n  };\n\n  var ceil = Math.ceil;\n  var floor = Math.floor; // `ToInteger` abstract operation\n  // https://tc39.github.io/ecma262/#sec-tointeger\n\n  var toInteger = function toInteger(argument) {\n    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n  };\n\n  var min = Math.min; // `ToLength` abstract operation\n  // https://tc39.github.io/ecma262/#sec-tolength\n\n  var toLength = function toLength(argument) {\n    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n  };\n\n  var max = Math.max;\n  var min$1 = Math.min; // Helper for a popular repeating case of the spec:\n  // Let integer be ? ToInteger(index).\n  // If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\n\n  var toAbsoluteIndex = function toAbsoluteIndex(index, length) {\n    var integer = toInteger(index);\n    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n  }; // `Array.prototype.{ indexOf, includes }` methods implementation\n\n\n  var createMethod = function createMethod(IS_INCLUDES) {\n    return function ($this, el, fromIndex) {\n      var O = toIndexedObject($this);\n      var length = toLength(O.length);\n      var index = toAbsoluteIndex(fromIndex, length);\n      var value; // Array#includes uses SameValueZero equality algorithm\n      // eslint-disable-next-line no-self-compare\n\n      if (IS_INCLUDES && el != el) while (length > index) {\n        value = O[index++]; // eslint-disable-next-line no-self-compare\n\n        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not\n      } else for (; length > index; index++) {\n        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n      }\n      return !IS_INCLUDES && -1;\n    };\n  };\n\n  var arrayIncludes = {\n    // `Array.prototype.includes` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n    includes: createMethod(true),\n    // `Array.prototype.indexOf` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n    indexOf: createMethod(false)\n  };\n  var indexOf = arrayIncludes.indexOf;\n\n  var objectKeysInternal = function objectKeysInternal(object, names) {\n    var O = toIndexedObject(object);\n    var i = 0;\n    var result = [];\n    var key;\n\n    for (key in O) {\n      !has(hiddenKeys, key) && has(O, key) && result.push(key);\n    } // Don't enum bug & hidden keys\n\n\n    while (names.length > i) {\n      if (has(O, key = names[i++])) {\n        ~indexOf(result, key) || result.push(key);\n      }\n    }\n\n    return result;\n  }; // IE8- don't enum bug keys\n\n\n  var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];\n  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\n  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n    return objectKeysInternal(O, hiddenKeys$1);\n  };\n\n  var objectGetOwnPropertyNames = {\n    f: f$3\n  };\n  var f$4 = Object.getOwnPropertySymbols;\n  var objectGetOwnPropertySymbols = {\n    f: f$4\n  }; // all object keys, includes non-enumerable and symbols\n\n  var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n    var keys = objectGetOwnPropertyNames.f(anObject(it));\n    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n  };\n\n  var copyConstructorProperties = function copyConstructorProperties(target, source) {\n    var keys = ownKeys(source);\n    var defineProperty = objectDefineProperty.f;\n    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  };\n\n  var replacement = /#|\\.prototype\\./;\n\n  var isForced = function isForced(feature, detection) {\n    var value = data[normalize(feature)];\n    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;\n  };\n\n  var normalize = isForced.normalize = function (string) {\n    return String(string).replace(replacement, '.').toLowerCase();\n  };\n\n  var data = isForced.data = {};\n  var NATIVE = isForced.NATIVE = 'N';\n  var POLYFILL = isForced.POLYFILL = 'P';\n  var isForced_1 = isForced;\n  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n  /*\n    options.target      - name of the target object\n    options.global      - target is the global object\n    options.stat        - export as static methods of target\n    options.proto       - export as prototype methods of target\n    options.real        - real prototype method for the `pure` version\n    options.forced      - export even if the native feature is available\n    options.bind        - bind methods to the target, required for the `pure` version\n    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n    options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n    options.sham        - add a flag to not completely full polyfills\n    options.enumerable  - export as enumerable property\n    options.noTargetGet - prevent calling a getter on target\n  */\n\n  var _export = function _export(options, source) {\n    var TARGET = options.target;\n    var GLOBAL = options.global;\n    var STATIC = options.stat;\n    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\n    if (GLOBAL) {\n      target = global_1;\n    } else if (STATIC) {\n      target = global_1[TARGET] || setGlobal(TARGET, {});\n    } else {\n      target = (global_1[TARGET] || {}).prototype;\n    }\n\n    if (target) for (key in source) {\n      sourceProperty = source[key];\n\n      if (options.noTargetGet) {\n        descriptor = getOwnPropertyDescriptor$1(target, key);\n        targetProperty = descriptor && descriptor.value;\n      } else targetProperty = target[key];\n\n      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target\n\n      if (!FORCED && targetProperty !== undefined) {\n        if (_typeof(sourceProperty) === _typeof(targetProperty)) continue;\n        copyConstructorProperties(sourceProperty, targetProperty);\n      } // add a flag to not completely full polyfills\n\n\n      if (options.sham || targetProperty && targetProperty.sham) {\n        hide(sourceProperty, 'sham', true);\n      } // extend global\n\n\n      redefine(target, key, sourceProperty, options);\n    }\n  };\n\n  var aFunction$1 = function aFunction$1(it) {\n    if (typeof it != 'function') {\n      throw TypeError(String(it) + ' is not a function');\n    }\n\n    return it;\n  }; // optional / simple context binding\n\n\n  var bindContext = function bindContext(fn, that, length) {\n    aFunction$1(fn);\n    if (that === undefined) return fn;\n\n    switch (length) {\n      case 0:\n        return function () {\n          return fn.call(that);\n        };\n\n      case 1:\n        return function (a) {\n          return fn.call(that, a);\n        };\n\n      case 2:\n        return function (a, b) {\n          return fn.call(that, a, b);\n        };\n\n      case 3:\n        return function (a, b, c) {\n          return fn.call(that, a, b, c);\n        };\n    }\n\n    return function ()\n    /* ...args */\n    {\n      return fn.apply(that, arguments);\n    };\n  }; // `ToObject` abstract operation\n  // https://tc39.github.io/ecma262/#sec-toobject\n\n\n  var toObject = function toObject(argument) {\n    return Object(requireObjectCoercible(argument));\n  }; // `IsArray` abstract operation\n  // https://tc39.github.io/ecma262/#sec-isarray\n\n\n  var isArray = Array.isArray || function isArray(arg) {\n    return classofRaw(arg) == 'Array';\n  };\n\n  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n    // Chrome 38 Symbol has incorrect toString conversion\n    // eslint-disable-next-line no-undef\n    return !String(Symbol());\n  });\n  var Symbol$1 = global_1.Symbol;\n  var store$1 = shared('wks');\n\n  var wellKnownSymbol = function wellKnownSymbol(name) {\n    return store$1[name] || (store$1[name] = nativeSymbol && Symbol$1[name] || (nativeSymbol ? Symbol$1 : uid)('Symbol.' + name));\n  };\n\n  var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation\n  // https://tc39.github.io/ecma262/#sec-arrayspeciescreate\n\n  var arraySpeciesCreate = function arraySpeciesCreate(originalArray, length) {\n    var C;\n\n    if (isArray(originalArray)) {\n      C = originalArray.constructor; // cross-realm fallback\n\n      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {\n        C = C[SPECIES];\n        if (C === null) C = undefined;\n      }\n    }\n\n    return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n  };\n\n  var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation\n\n  var createMethod$1 = function createMethod$1(TYPE) {\n    var IS_MAP = TYPE == 1;\n    var IS_FILTER = TYPE == 2;\n    var IS_SOME = TYPE == 3;\n    var IS_EVERY = TYPE == 4;\n    var IS_FIND_INDEX = TYPE == 6;\n    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n    return function ($this, callbackfn, that, specificCreate) {\n      var O = toObject($this);\n      var self = indexedObject(O);\n      var boundFunction = bindContext(callbackfn, that, 3);\n      var length = toLength(self.length);\n      var index = 0;\n      var create = specificCreate || arraySpeciesCreate;\n      var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n      var value, result;\n\n      for (; length > index; index++) {\n        if (NO_HOLES || index in self) {\n          value = self[index];\n          result = boundFunction(value, index, O);\n\n          if (TYPE) {\n            if (IS_MAP) target[index] = result; // map\n            else if (result) switch (TYPE) {\n                case 3:\n                  return true;\n                // some\n\n                case 5:\n                  return value;\n                // find\n\n                case 6:\n                  return index;\n                // findIndex\n\n                case 2:\n                  push.call(target, value);\n                // filter\n              } else if (IS_EVERY) return false; // every\n          }\n        }\n      }\n\n      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n    };\n  };\n\n  var arrayIteration = {\n    // `Array.prototype.forEach` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n    forEach: createMethod$1(0),\n    // `Array.prototype.map` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.map\n    map: createMethod$1(1),\n    // `Array.prototype.filter` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.filter\n    filter: createMethod$1(2),\n    // `Array.prototype.some` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.some\n    some: createMethod$1(3),\n    // `Array.prototype.every` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.every\n    every: createMethod$1(4),\n    // `Array.prototype.find` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.find\n    find: createMethod$1(5),\n    // `Array.prototype.findIndex` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\n    findIndex: createMethod$1(6)\n  };\n\n  var sloppyArrayMethod = function sloppyArrayMethod(METHOD_NAME, argument) {\n    var method = [][METHOD_NAME];\n    return !method || !fails(function () {\n      // eslint-disable-next-line no-useless-call,no-throw-literal\n      method.call(null, argument || function () {\n        throw 1;\n      }, 1);\n    });\n  };\n\n  var $forEach = arrayIteration.forEach; // `Array.prototype.forEach` method implementation\n  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\n  var arrayForEach = sloppyArrayMethod('forEach') ? function forEach(callbackfn\n  /* , thisArg */\n  ) {\n    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  } : [].forEach; // `Array.prototype.forEach` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\n  _export({\n    target: 'Array',\n    proto: true,\n    forced: [].forEach != arrayForEach\n  }, {\n    forEach: arrayForEach\n  }); // iterable DOM collections\n  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n\n\n  var domIterables = {\n    CSSRuleList: 0,\n    CSSStyleDeclaration: 0,\n    CSSValueList: 0,\n    ClientRectList: 0,\n    DOMRectList: 0,\n    DOMStringList: 0,\n    DOMTokenList: 1,\n    DataTransferItemList: 0,\n    FileList: 0,\n    HTMLAllCollection: 0,\n    HTMLCollection: 0,\n    HTMLFormElement: 0,\n    HTMLSelectElement: 0,\n    MediaList: 0,\n    MimeTypeArray: 0,\n    NamedNodeMap: 0,\n    NodeList: 1,\n    PaintRequestList: 0,\n    Plugin: 0,\n    PluginArray: 0,\n    SVGLengthList: 0,\n    SVGNumberList: 0,\n    SVGPathSegList: 0,\n    SVGPointList: 0,\n    SVGStringList: 0,\n    SVGTransformList: 0,\n    SourceBufferList: 0,\n    StyleSheetList: 0,\n    TextTrackCueList: 0,\n    TextTrackList: 0,\n    TouchList: 0\n  };\n\n  for (var COLLECTION_NAME in domIterables) {\n    var Collection = global_1[COLLECTION_NAME];\n    var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList\n\n    if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {\n      hide(CollectionPrototype, 'forEach', arrayForEach);\n    } catch (error) {\n      CollectionPrototype.forEach = arrayForEach;\n    }\n  }\n\n  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n  var canUseDom = canUseDOM;\n  var SPECIES$1 = wellKnownSymbol('species');\n\n  var arrayMethodHasSpeciesSupport = function arrayMethodHasSpeciesSupport(METHOD_NAME) {\n    return !fails(function () {\n      var array = [];\n      var constructor = array.constructor = {};\n\n      constructor[SPECIES$1] = function () {\n        return {\n          foo: 1\n        };\n      };\n\n      return array[METHOD_NAME](Boolean).foo !== 1;\n    });\n  };\n\n  var $filter = arrayIteration.filter; // `Array.prototype.filter` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.filter\n  // with adding support of @@species\n\n  _export({\n    target: 'Array',\n    proto: true,\n    forced: !arrayMethodHasSpeciesSupport('filter')\n  }, {\n    filter: function filter(callbackfn\n    /* , thisArg */\n    ) {\n      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    }\n  }); // `Object.keys` method\n  // https://tc39.github.io/ecma262/#sec-object.keys\n\n\n  var objectKeys = Object.keys || function keys(O) {\n    return objectKeysInternal(O, enumBugKeys);\n  }; // `Object.defineProperties` method\n  // https://tc39.github.io/ecma262/#sec-object.defineproperties\n\n\n  var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n    anObject(O);\n    var keys = objectKeys(Properties);\n    var length = keys.length;\n    var index = 0;\n    var key;\n\n    while (length > index) {\n      objectDefineProperty.f(O, key = keys[index++], Properties[key]);\n    }\n\n    return O;\n  };\n  var html = getBuiltIn('document', 'documentElement');\n  var IE_PROTO = sharedKey('IE_PROTO');\n  var PROTOTYPE = 'prototype';\n\n  var Empty = function Empty() {\n    /* empty */\n  }; // Create object with fake `null` prototype: use iframe Object with cleared prototype\n\n\n  var _createDict = function createDict() {\n    // Thrash, waste and sodomy: IE GC bug\n    var iframe = documentCreateElement('iframe');\n    var length = enumBugKeys.length;\n    var lt = '<';\n    var script = 'script';\n    var gt = '>';\n    var js = 'java' + script + ':';\n    var iframeDocument;\n    iframe.style.display = 'none';\n    html.appendChild(iframe);\n    iframe.src = String(js);\n    iframeDocument = iframe.contentWindow.document;\n    iframeDocument.open();\n    iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);\n    iframeDocument.close();\n    _createDict = iframeDocument.F;\n\n    while (length--) {\n      delete _createDict[PROTOTYPE][enumBugKeys[length]];\n    }\n\n    return _createDict();\n  }; // `Object.create` method\n  // https://tc39.github.io/ecma262/#sec-object.create\n\n\n  var objectCreate = Object.create || function create(O, Properties) {\n    var result;\n\n    if (O !== null) {\n      Empty[PROTOTYPE] = anObject(O);\n      result = new Empty();\n      Empty[PROTOTYPE] = null; // add \"__proto__\" for Object.getPrototypeOf polyfill\n\n      result[IE_PROTO] = O;\n    } else result = _createDict();\n\n    return Properties === undefined ? result : objectDefineProperties(result, Properties);\n  };\n\n  hiddenKeys[IE_PROTO] = true;\n  var UNSCOPABLES = wellKnownSymbol('unscopables');\n  var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]\n  // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\n  if (ArrayPrototype[UNSCOPABLES] == undefined) {\n    hide(ArrayPrototype, UNSCOPABLES, objectCreate(null));\n  } // add a key to Array.prototype[@@unscopables]\n\n\n  var addToUnscopables = function addToUnscopables(key) {\n    ArrayPrototype[UNSCOPABLES][key] = true;\n  };\n\n  var iterators = {};\n  var correctPrototypeGetter = !fails(function () {\n    function F() {\n      /* empty */\n    }\n\n    F.prototype.constructor = null;\n    return Object.getPrototypeOf(new F()) !== F.prototype;\n  });\n  var IE_PROTO$1 = sharedKey('IE_PROTO');\n  var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method\n  // https://tc39.github.io/ecma262/#sec-object.getprototypeof\n\n  var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n    O = toObject(O);\n    if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];\n\n    if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n      return O.constructor.prototype;\n    }\n\n    return O instanceof Object ? ObjectPrototype : null;\n  };\n  var ITERATOR = wellKnownSymbol('iterator');\n  var BUGGY_SAFARI_ITERATORS = false;\n\n  var returnThis = function returnThis() {\n    return this;\n  }; // `%IteratorPrototype%` object\n  // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\n\n\n  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n  if ([].keys) {\n    arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`\n\n    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {\n      PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n    }\n  }\n\n  if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\n  if (!has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n  var iteratorsCore = {\n    IteratorPrototype: IteratorPrototype,\n    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n  };\n  var defineProperty = objectDefineProperty.f;\n  var TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\n  var setToStringTag = function setToStringTag(it, TAG, STATIC) {\n    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n      defineProperty(it, TO_STRING_TAG, {\n        configurable: true,\n        value: TAG\n      });\n    }\n  };\n\n  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\n  var returnThis$1 = function returnThis$1() {\n    return this;\n  };\n\n  var createIteratorConstructor = function createIteratorConstructor(IteratorConstructor, NAME, next) {\n    var TO_STRING_TAG = NAME + ' Iterator';\n    IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {\n      next: createPropertyDescriptor(1, next)\n    });\n    setToStringTag(IteratorConstructor, TO_STRING_TAG, false);\n    iterators[TO_STRING_TAG] = returnThis$1;\n    return IteratorConstructor;\n  };\n\n  var aPossiblePrototype = function aPossiblePrototype(it) {\n    if (!isObject(it) && it !== null) {\n      throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n    }\n\n    return it;\n  }; // `Object.setPrototypeOf` method\n  // https://tc39.github.io/ecma262/#sec-object.setprototypeof\n  // Works with __proto__ only. Old v8 can't work with null proto objects.\n\n  /* eslint-disable no-proto */\n\n\n  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n    var CORRECT_SETTER = false;\n    var test = {};\n    var setter;\n\n    try {\n      setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n      setter.call(test, []);\n      CORRECT_SETTER = test instanceof Array;\n    } catch (error) {\n      /* empty */\n    }\n\n    return function setPrototypeOf(O, proto) {\n      anObject(O);\n      aPossiblePrototype(proto);\n      if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;\n      return O;\n    };\n  }() : undefined);\n  var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\n  var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n  var ITERATOR$1 = wellKnownSymbol('iterator');\n  var KEYS = 'keys';\n  var VALUES = 'values';\n  var ENTRIES = 'entries';\n\n  var returnThis$2 = function returnThis$2() {\n    return this;\n  };\n\n  var defineIterator = function defineIterator(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n    createIteratorConstructor(IteratorConstructor, NAME, next);\n\n    var getIterationMethod = function getIterationMethod(KIND) {\n      if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n      if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];\n\n      switch (KIND) {\n        case KEYS:\n          return function keys() {\n            return new IteratorConstructor(this, KIND);\n          };\n\n        case VALUES:\n          return function values() {\n            return new IteratorConstructor(this, KIND);\n          };\n\n        case ENTRIES:\n          return function entries() {\n            return new IteratorConstructor(this, KIND);\n          };\n      }\n\n      return function () {\n        return new IteratorConstructor(this);\n      };\n    };\n\n    var TO_STRING_TAG = NAME + ' Iterator';\n    var INCORRECT_VALUES_NAME = false;\n    var IterablePrototype = Iterable.prototype;\n    var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];\n    var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n    var CurrentIteratorPrototype, methods, KEY; // fix native\n\n    if (anyNativeIterator) {\n      CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\n      if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {\n        if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {\n          if (objectSetPrototypeOf) {\n            objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);\n          } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {\n            hide(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);\n          }\n        } // Set @@toStringTag to native iterators\n\n\n        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);\n      }\n    } // fix Array#{values, @@iterator}.name in V8 / FF\n\n\n    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n      INCORRECT_VALUES_NAME = true;\n\n      defaultIterator = function values() {\n        return nativeIterator.call(this);\n      };\n    } // define iterator\n\n\n    if (IterablePrototype[ITERATOR$1] !== defaultIterator) {\n      hide(IterablePrototype, ITERATOR$1, defaultIterator);\n    }\n\n    iterators[NAME] = defaultIterator; // export additional methods\n\n    if (DEFAULT) {\n      methods = {\n        values: getIterationMethod(VALUES),\n        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n        entries: getIterationMethod(ENTRIES)\n      };\n      if (FORCED) for (KEY in methods) {\n        if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n          redefine(IterablePrototype, KEY, methods[KEY]);\n        }\n      } else _export({\n        target: NAME,\n        proto: true,\n        forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME\n      }, methods);\n    }\n\n    return methods;\n  };\n\n  var ARRAY_ITERATOR = 'Array Iterator';\n  var setInternalState = internalState.set;\n  var getInternalState = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.entries\n  // `Array.prototype.keys` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.keys\n  // `Array.prototype.values` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.values\n  // `Array.prototype[@@iterator]` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator\n  // `CreateArrayIterator` internal method\n  // https://tc39.github.io/ecma262/#sec-createarrayiterator\n\n  var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n    setInternalState(this, {\n      type: ARRAY_ITERATOR,\n      target: toIndexedObject(iterated),\n      // target\n      index: 0,\n      // next index\n      kind: kind // kind\n\n    }); // `%ArrayIteratorPrototype%.next` method\n    // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next\n  }, function () {\n    var state = getInternalState(this);\n    var target = state.target;\n    var kind = state.kind;\n    var index = state.index++;\n\n    if (!target || index >= target.length) {\n      state.target = undefined;\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (kind == 'keys') return {\n      value: index,\n      done: false\n    };\n    if (kind == 'values') return {\n      value: target[index],\n      done: false\n    };\n    return {\n      value: [index, target[index]],\n      done: false\n    };\n  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%\n  // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject\n  // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject\n\n  iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\n  addToUnscopables('keys');\n  addToUnscopables('values');\n  addToUnscopables('entries');\n  var nativeAssign = Object.assign; // `Object.assign` method\n  // https://tc39.github.io/ecma262/#sec-object.assign\n  // should work with symbols and should have deterministic property order (V8 bug)\n\n  var objectAssign = !nativeAssign || fails(function () {\n    var A = {};\n    var B = {}; // eslint-disable-next-line no-undef\n\n    var symbol = Symbol();\n    var alphabet = 'abcdefghijklmnopqrst';\n    A[symbol] = 7;\n    alphabet.split('').forEach(function (chr) {\n      B[chr] = chr;\n    });\n    return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n  }) ? function assign(target, source) {\n    // eslint-disable-line no-unused-vars\n    var T = toObject(target);\n    var argumentsLength = arguments.length;\n    var index = 1;\n    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n    var propertyIsEnumerable = objectPropertyIsEnumerable.f;\n\n    while (argumentsLength > index) {\n      var S = indexedObject(arguments[index++]);\n      var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n      var length = keys.length;\n      var j = 0;\n      var key;\n\n      while (length > j) {\n        key = keys[j++];\n        if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n      }\n    }\n\n    return T;\n  } : nativeAssign; // `Object.assign` method\n  // https://tc39.github.io/ecma262/#sec-object.assign\n\n  _export({\n    target: 'Object',\n    stat: true,\n    forced: Object.assign !== objectAssign\n  }, {\n    assign: objectAssign\n  });\n\n  var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here\n\n  var CORRECT_ARGUMENTS = classofRaw(function () {\n    return arguments;\n  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error\n\n  var tryGet = function tryGet(it, key) {\n    try {\n      return it[key];\n    } catch (error) {\n      /* empty */\n    }\n  }; // getting tag from ES6+ `Object.prototype.toString`\n\n\n  var classof = function classof(it) {\n    var O, tag, result;\n    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n  };\n\n  var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n  var test = {};\n  test[TO_STRING_TAG$2] = 'z'; // `Object.prototype.toString` method implementation\n  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n\n  var objectToString = String(test) !== '[object z]' ? function toString() {\n    return '[object ' + classof(this) + ']';\n  } : test.toString;\n  var ObjectPrototype$1 = Object.prototype; // `Object.prototype.toString` method\n  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n\n  if (objectToString !== ObjectPrototype$1.toString) {\n    redefine(ObjectPrototype$1, 'toString', objectToString, {\n      unsafe: true\n    });\n  } // a string of all valid unicode whitespaces\n  // eslint-disable-next-line max-len\n\n\n  var whitespaces = \"\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF\";\n  var whitespace = '[' + whitespaces + ']';\n  var ltrim = RegExp('^' + whitespace + whitespace + '*');\n  var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n\n  var createMethod$2 = function createMethod$2(TYPE) {\n    return function ($this) {\n      var string = String(requireObjectCoercible($this));\n      if (TYPE & 1) string = string.replace(ltrim, '');\n      if (TYPE & 2) string = string.replace(rtrim, '');\n      return string;\n    };\n  };\n\n  var stringTrim = {\n    // `String.prototype.{ trimLeft, trimStart }` methods\n    // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart\n    start: createMethod$2(1),\n    // `String.prototype.{ trimRight, trimEnd }` methods\n    // https://tc39.github.io/ecma262/#sec-string.prototype.trimend\n    end: createMethod$2(2),\n    // `String.prototype.trim` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.trim\n    trim: createMethod$2(3)\n  };\n  var trim = stringTrim.trim;\n  var nativeParseInt = global_1.parseInt;\n  var hex = /^[+-]?0[Xx]/;\n  var FORCED = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22; // `parseInt` method\n  // https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\n  var _parseInt = FORCED ? function parseInt(string, radix) {\n    var S = trim(String(string));\n    return nativeParseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));\n  } : nativeParseInt; // `parseInt` method\n  // https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\n\n  _export({\n    global: true,\n    forced: parseInt != _parseInt\n  }, {\n    parseInt: _parseInt\n  }); // `String.prototype.{ codePointAt, at }` methods implementation\n\n\n  var createMethod$3 = function createMethod$3(CONVERT_TO_STRING) {\n    return function ($this, pos) {\n      var S = String(requireObjectCoercible($this));\n      var position = toInteger(pos);\n      var size = S.length;\n      var first, second;\n      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n      first = S.charCodeAt(position);\n      return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n    };\n  };\n\n  var stringMultibyte = {\n    // `String.prototype.codePointAt` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat\n    codeAt: createMethod$3(false),\n    // `String.prototype.at` method\n    // https://github.com/mathiasbynens/String.prototype.at\n    charAt: createMethod$3(true)\n  };\n  var charAt = stringMultibyte.charAt;\n  var STRING_ITERATOR = 'String Iterator';\n  var setInternalState$1 = internalState.set;\n  var getInternalState$1 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method\n  // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator\n\n  defineIterator(String, 'String', function (iterated) {\n    setInternalState$1(this, {\n      type: STRING_ITERATOR,\n      string: String(iterated),\n      index: 0\n    }); // `%StringIteratorPrototype%.next` method\n    // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next\n  }, function next() {\n    var state = getInternalState$1(this);\n    var string = state.string;\n    var index = state.index;\n    var point;\n    if (index >= string.length) return {\n      value: undefined,\n      done: true\n    };\n    point = charAt(string, index);\n    state.index += point.length;\n    return {\n      value: point,\n      done: false\n    };\n  });\n\n  var redefineAll = function redefineAll(target, src, options) {\n    for (var key in src) {\n      redefine(target, key, src[key], options);\n    }\n\n    return target;\n  };\n\n  var freezing = !fails(function () {\n    return Object.isExtensible(Object.preventExtensions({}));\n  });\n  var internalMetadata = createCommonjsModule(function (module) {\n    var defineProperty = objectDefineProperty.f;\n    var METADATA = uid('meta');\n    var id = 0;\n\n    var isExtensible = Object.isExtensible || function () {\n      return true;\n    };\n\n    var setMetadata = function setMetadata(it) {\n      defineProperty(it, METADATA, {\n        value: {\n          objectID: 'O' + ++id,\n          // object ID\n          weakData: {} // weak collections IDs\n\n        }\n      });\n    };\n\n    var fastKey = function fastKey(it, create) {\n      // return a primitive with prefix\n      if (!isObject(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\n      if (!has(it, METADATA)) {\n        // can't set metadata to uncaught frozen object\n        if (!isExtensible(it)) return 'F'; // not necessary to add metadata\n\n        if (!create) return 'E'; // add missing metadata\n\n        setMetadata(it); // return object ID\n      }\n\n      return it[METADATA].objectID;\n    };\n\n    var getWeakData = function getWeakData(it, create) {\n      if (!has(it, METADATA)) {\n        // can't set metadata to uncaught frozen object\n        if (!isExtensible(it)) return true; // not necessary to add metadata\n\n        if (!create) return false; // add missing metadata\n\n        setMetadata(it); // return the store of weak collections IDs\n      }\n\n      return it[METADATA].weakData;\n    }; // add metadata on freeze-family methods calling\n\n\n    var onFreeze = function onFreeze(it) {\n      if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);\n      return it;\n    };\n\n    var meta = module.exports = {\n      REQUIRED: false,\n      fastKey: fastKey,\n      getWeakData: getWeakData,\n      onFreeze: onFreeze\n    };\n    hiddenKeys[METADATA] = true;\n  });\n  var internalMetadata_1 = internalMetadata.REQUIRED;\n  var internalMetadata_2 = internalMetadata.fastKey;\n  var internalMetadata_3 = internalMetadata.getWeakData;\n  var internalMetadata_4 = internalMetadata.onFreeze;\n  var ITERATOR$2 = wellKnownSymbol('iterator');\n  var ArrayPrototype$1 = Array.prototype; // check on default Array iterator\n\n  var isArrayIteratorMethod = function isArrayIteratorMethod(it) {\n    return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);\n  };\n\n  var ITERATOR$3 = wellKnownSymbol('iterator');\n\n  var getIteratorMethod = function getIteratorMethod(it) {\n    if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || iterators[classof(it)];\n  }; // call something on iterator step with safe closing on error\n\n\n  var callWithSafeIterationClosing = function callWithSafeIterationClosing(iterator, fn, value, ENTRIES) {\n    try {\n      return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)\n    } catch (error) {\n      var returnMethod = iterator['return'];\n      if (returnMethod !== undefined) anObject(returnMethod.call(iterator));\n      throw error;\n    }\n  };\n\n  var iterate_1 = createCommonjsModule(function (module) {\n    var Result = function Result(stopped, result) {\n      this.stopped = stopped;\n      this.result = result;\n    };\n\n    var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {\n      var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);\n      var iterator, iterFn, index, length, result, step;\n\n      if (IS_ITERATOR) {\n        iterator = iterable;\n      } else {\n        iterFn = getIteratorMethod(iterable);\n        if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators\n\n        if (isArrayIteratorMethod(iterFn)) {\n          for (index = 0, length = toLength(iterable.length); length > index; index++) {\n            result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);\n            if (result && result instanceof Result) return result;\n          }\n\n          return new Result(false);\n        }\n\n        iterator = iterFn.call(iterable);\n      }\n\n      while (!(step = iterator.next()).done) {\n        result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);\n        if (result && result instanceof Result) return result;\n      }\n\n      return new Result(false);\n    };\n\n    iterate.stop = function (result) {\n      return new Result(true, result);\n    };\n  });\n\n  var anInstance = function anInstance(it, Constructor, name) {\n    if (!(it instanceof Constructor)) {\n      throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n    }\n\n    return it;\n  };\n\n  var ITERATOR$4 = wellKnownSymbol('iterator');\n  var SAFE_CLOSING = false;\n\n  try {\n    var called = 0;\n    var iteratorWithReturn = {\n      next: function next() {\n        return {\n          done: !!called++\n        };\n      },\n      'return': function _return() {\n        SAFE_CLOSING = true;\n      }\n    };\n\n    iteratorWithReturn[ITERATOR$4] = function () {\n      return this;\n    }; // eslint-disable-next-line no-throw-literal\n\n\n    Array.from(iteratorWithReturn, function () {\n      throw 2;\n    });\n  } catch (error) {\n    /* empty */\n  }\n\n  var checkCorrectnessOfIteration = function checkCorrectnessOfIteration(exec, SKIP_CLOSING) {\n    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n    var ITERATION_SUPPORT = false;\n\n    try {\n      var object = {};\n\n      object[ITERATOR$4] = function () {\n        return {\n          next: function next() {\n            return {\n              done: ITERATION_SUPPORT = true\n            };\n          }\n        };\n      };\n\n      exec(object);\n    } catch (error) {\n      /* empty */\n    }\n\n    return ITERATION_SUPPORT;\n  }; // makes subclassing work correct for wrapped built-ins\n\n\n  var inheritIfRequired = function inheritIfRequired($this, dummy, Wrapper) {\n    var NewTarget, NewTargetPrototype;\n    if ( // it can work only with native `setPrototypeOf`\n    objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);\n    return $this;\n  };\n\n  var collection = function collection(CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {\n    var NativeConstructor = global_1[CONSTRUCTOR_NAME];\n    var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n    var Constructor = NativeConstructor;\n    var ADDER = IS_MAP ? 'set' : 'add';\n    var exported = {};\n\n    var fixMethod = function fixMethod(KEY) {\n      var nativeMethod = NativePrototype[KEY];\n      redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {\n        nativeMethod.call(this, value === 0 ? 0 : value);\n        return this;\n      } : KEY == 'delete' ? function (key) {\n        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : KEY == 'get' ? function get(key) {\n        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : KEY == 'has' ? function has(key) {\n        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : function set(key, value) {\n        nativeMethod.call(this, key === 0 ? 0 : key, value);\n        return this;\n      });\n    }; // eslint-disable-next-line max-len\n\n\n    if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n      new NativeConstructor().entries().next();\n    })))) {\n      // create collection constructor\n      Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n      internalMetadata.REQUIRED = true;\n    } else if (isForced_1(CONSTRUCTOR_NAME, true)) {\n      var instance = new Constructor(); // early implementations not supports chaining\n\n      var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false\n\n      var THROWS_ON_PRIMITIVES = fails(function () {\n        instance.has(1);\n      }); // most early implementations doesn't supports iterables, most modern - not close it correctly\n      // eslint-disable-next-line no-new\n\n      var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {\n        new NativeConstructor(iterable);\n      }); // for early implementations -0 and +0 not the same\n\n      var BUGGY_ZERO = !IS_WEAK && fails(function () {\n        // V8 ~ Chromium 42- fails only with 5+ elements\n        var $instance = new NativeConstructor();\n        var index = 5;\n\n        while (index--) {\n          $instance[ADDER](index, index);\n        }\n\n        return !$instance.has(-0);\n      });\n\n      if (!ACCEPT_ITERABLES) {\n        Constructor = wrapper(function (dummy, iterable) {\n          anInstance(dummy, Constructor, CONSTRUCTOR_NAME);\n          var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n          if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);\n          return that;\n        });\n        Constructor.prototype = NativePrototype;\n        NativePrototype.constructor = Constructor;\n      }\n\n      if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n        fixMethod('delete');\n        fixMethod('has');\n        IS_MAP && fixMethod('get');\n      }\n\n      if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method\n\n      if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;\n    }\n\n    exported[CONSTRUCTOR_NAME] = Constructor;\n\n    _export({\n      global: true,\n      forced: Constructor != NativeConstructor\n    }, exported);\n\n    setToStringTag(Constructor, CONSTRUCTOR_NAME);\n    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n    return Constructor;\n  };\n\n  var getWeakData = internalMetadata.getWeakData;\n  var setInternalState$2 = internalState.set;\n  var internalStateGetterFor = internalState.getterFor;\n  var find = arrayIteration.find;\n  var findIndex = arrayIteration.findIndex;\n  var id$1 = 0; // fallback for uncaught frozen keys\n\n  var uncaughtFrozenStore = function uncaughtFrozenStore(store) {\n    return store.frozen || (store.frozen = new UncaughtFrozenStore());\n  };\n\n  var UncaughtFrozenStore = function UncaughtFrozenStore() {\n    this.entries = [];\n  };\n\n  var findUncaughtFrozen = function findUncaughtFrozen(store, key) {\n    return find(store.entries, function (it) {\n      return it[0] === key;\n    });\n  };\n\n  UncaughtFrozenStore.prototype = {\n    get: function get(key) {\n      var entry = findUncaughtFrozen(this, key);\n      if (entry) return entry[1];\n    },\n    has: function has(key) {\n      return !!findUncaughtFrozen(this, key);\n    },\n    set: function set(key, value) {\n      var entry = findUncaughtFrozen(this, key);\n      if (entry) entry[1] = value;else this.entries.push([key, value]);\n    },\n    'delete': function _delete(key) {\n      var index = findIndex(this.entries, function (it) {\n        return it[0] === key;\n      });\n      if (~index) this.entries.splice(index, 1);\n      return !!~index;\n    }\n  };\n  var collectionWeak = {\n    getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n      var C = wrapper(function (that, iterable) {\n        anInstance(that, C, CONSTRUCTOR_NAME);\n        setInternalState$2(that, {\n          type: CONSTRUCTOR_NAME,\n          id: id$1++,\n          frozen: undefined\n        });\n        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);\n      });\n      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n      var define = function define(that, key, value) {\n        var state = getInternalState(that);\n        var data = getWeakData(anObject(key), true);\n        if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;\n        return that;\n      };\n\n      redefineAll(C.prototype, {\n        // 23.3.3.2 WeakMap.prototype.delete(key)\n        // 23.4.3.3 WeakSet.prototype.delete(value)\n        'delete': function _delete(key) {\n          var state = getInternalState(this);\n          if (!isObject(key)) return false;\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state)['delete'](key);\n          return data && has(data, state.id) && delete data[state.id];\n        },\n        // 23.3.3.4 WeakMap.prototype.has(key)\n        // 23.4.3.4 WeakSet.prototype.has(value)\n        has: function has$1(key) {\n          var state = getInternalState(this);\n          if (!isObject(key)) return false;\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state).has(key);\n          return data && has(data, state.id);\n        }\n      });\n      redefineAll(C.prototype, IS_MAP ? {\n        // 23.3.3.3 WeakMap.prototype.get(key)\n        get: function get(key) {\n          var state = getInternalState(this);\n\n          if (isObject(key)) {\n            var data = getWeakData(key);\n            if (data === true) return uncaughtFrozenStore(state).get(key);\n            return data ? data[state.id] : undefined;\n          }\n        },\n        // 23.3.3.5 WeakMap.prototype.set(key, value)\n        set: function set(key, value) {\n          return define(this, key, value);\n        }\n      } : {\n        // 23.4.3.1 WeakSet.prototype.add(value)\n        add: function add(value) {\n          return define(this, value, true);\n        }\n      });\n      return C;\n    }\n  };\n  var es_weakMap = createCommonjsModule(function (module) {\n    var enforceIternalState = internalState.enforce;\n    var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;\n    var isExtensible = Object.isExtensible;\n    var InternalWeakMap;\n\n    var wrapper = function wrapper(get) {\n      return function WeakMap() {\n        return get(this, arguments.length ? arguments[0] : undefined);\n      };\n    }; // `WeakMap` constructor\n    // https://tc39.github.io/ecma262/#sec-weakmap-constructor\n\n\n    var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak, true, true); // IE11 WeakMap frozen keys fix\n    // We can't use feature detection because it crash some old IE builds\n    // https://github.com/zloirock/core-js/issues/485\n\n    if (nativeWeakMap && IS_IE11) {\n      InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);\n      internalMetadata.REQUIRED = true;\n      var WeakMapPrototype = $WeakMap.prototype;\n      var nativeDelete = WeakMapPrototype['delete'];\n      var nativeHas = WeakMapPrototype.has;\n      var nativeGet = WeakMapPrototype.get;\n      var nativeSet = WeakMapPrototype.set;\n      redefineAll(WeakMapPrototype, {\n        'delete': function _delete(key) {\n          if (isObject(key) && !isExtensible(key)) {\n            var state = enforceIternalState(this);\n            if (!state.frozen) state.frozen = new InternalWeakMap();\n            return nativeDelete.call(this, key) || state.frozen['delete'](key);\n          }\n\n          return nativeDelete.call(this, key);\n        },\n        has: function has(key) {\n          if (isObject(key) && !isExtensible(key)) {\n            var state = enforceIternalState(this);\n            if (!state.frozen) state.frozen = new InternalWeakMap();\n            return nativeHas.call(this, key) || state.frozen.has(key);\n          }\n\n          return nativeHas.call(this, key);\n        },\n        get: function get(key) {\n          if (isObject(key) && !isExtensible(key)) {\n            var state = enforceIternalState(this);\n            if (!state.frozen) state.frozen = new InternalWeakMap();\n            return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);\n          }\n\n          return nativeGet.call(this, key);\n        },\n        set: function set(key, value) {\n          if (isObject(key) && !isExtensible(key)) {\n            var state = enforceIternalState(this);\n            if (!state.frozen) state.frozen = new InternalWeakMap();\n            nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);\n          } else nativeSet.call(this, key, value);\n\n          return this;\n        }\n      });\n    }\n  });\n  var ITERATOR$5 = wellKnownSymbol('iterator');\n  var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');\n  var ArrayValues = es_array_iterator.values;\n\n  for (var COLLECTION_NAME$1 in domIterables) {\n    var Collection$1 = global_1[COLLECTION_NAME$1];\n    var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;\n\n    if (CollectionPrototype$1) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype$1[ITERATOR$5] !== ArrayValues) try {\n        hide(CollectionPrototype$1, ITERATOR$5, ArrayValues);\n      } catch (error) {\n        CollectionPrototype$1[ITERATOR$5] = ArrayValues;\n      }\n      if (!CollectionPrototype$1[TO_STRING_TAG$3]) hide(CollectionPrototype$1, TO_STRING_TAG$3, COLLECTION_NAME$1);\n      if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {\n        // some Chrome versions have non-configurable methods on DOMTokenList\n        if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {\n          hide(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);\n        } catch (error) {\n          CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];\n        }\n      }\n    }\n  }\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n\n\n  var FUNC_ERROR_TEXT = 'Expected a function';\n  /** Used as references for various `Number` constants. */\n\n  var NAN = 0 / 0;\n  /** `Object#toString` result references. */\n\n  var symbolTag = '[object Symbol]';\n  /** Used to match leading and trailing whitespace. */\n\n  var reTrim = /^\\s+|\\s+$/g;\n  /** Used to detect bad signed hexadecimal string values. */\n\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n  /** Used to detect binary string values. */\n\n  var reIsBinary = /^0b[01]+$/i;\n  /** Used to detect octal string values. */\n\n  var reIsOctal = /^0o[0-7]+$/i;\n  /** Built-in method references without a dependency on `root`. */\n\n  var freeParseInt = parseInt;\n  /** Detect free variable `global` from Node.js. */\n\n  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n  /** Detect free variable `self`. */\n\n  var freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n  /** Used as a reference to the global object. */\n\n  var root = freeGlobal || freeSelf || Function('return this')();\n  /** Used for built-in method references. */\n\n  var objectProto = Object.prototype;\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n  var objectToString$1 = objectProto.toString;\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n  var nativeMax = Math.max,\n      nativeMin = Math.min;\n  /**\n   * Gets the timestamp of the number of milliseconds that have elapsed since\n   * the Unix epoch (1 January 1970 00:00:00 UTC).\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Date\n   * @returns {number} Returns the timestamp.\n   * @example\n   *\n   * _.defer(function(stamp) {\n   *   console.log(_.now() - stamp);\n   * }, _.now());\n   * // => Logs the number of milliseconds it took for the deferred invocation.\n   */\n\n  var now = function now() {\n    return root.Date.now();\n  };\n  /**\n   * Creates a debounced function that delays invoking `func` until after `wait`\n   * milliseconds have elapsed since the last time the debounced function was\n   * invoked. The debounced function comes with a `cancel` method to cancel\n   * delayed `func` invocations and a `flush` method to immediately invoke them.\n   * Provide `options` to indicate whether `func` should be invoked on the\n   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n   * with the last arguments provided to the debounced function. Subsequent\n   * calls to the debounced function return the result of the last `func`\n   * invocation.\n   *\n   * **Note:** If `leading` and `trailing` options are `true`, `func` is\n   * invoked on the trailing edge of the timeout only if the debounced function\n   * is invoked more than once during the `wait` timeout.\n   *\n   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n   * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n   *\n   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n   * for details over the differences between `_.debounce` and `_.throttle`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to debounce.\n   * @param {number} [wait=0] The number of milliseconds to delay.\n   * @param {Object} [options={}] The options object.\n   * @param {boolean} [options.leading=false]\n   *  Specify invoking on the leading edge of the timeout.\n   * @param {number} [options.maxWait]\n   *  The maximum time `func` is allowed to be delayed before it's invoked.\n   * @param {boolean} [options.trailing=true]\n   *  Specify invoking on the trailing edge of the timeout.\n   * @returns {Function} Returns the new debounced function.\n   * @example\n   *\n   * // Avoid costly calculations while the window size is in flux.\n   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n   *\n   * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n   * jQuery(element).on('click', _.debounce(sendMail, 300, {\n   *   'leading': true,\n   *   'trailing': false\n   * }));\n   *\n   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n   * var source = new EventSource('/stream');\n   * jQuery(source).on('message', debounced);\n   *\n   * // Cancel the trailing debounced invocation.\n   * jQuery(window).on('popstate', debounced.cancel);\n   */\n\n\n  function debounce(func, wait, options) {\n    var lastArgs,\n        lastThis,\n        maxWait,\n        result,\n        timerId,\n        lastCallTime,\n        lastInvokeTime = 0,\n        leading = false,\n        maxing = false,\n        trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n\n    wait = toNumber(wait) || 0;\n\n    if (isObject$1(options)) {\n      leading = !!options.leading;\n      maxing = 'maxWait' in options;\n      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n      var args = lastArgs,\n          thisArg = lastThis;\n      lastArgs = lastThis = undefined;\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args);\n      return result;\n    }\n\n    function leadingEdge(time) {\n      // Reset any `maxWait` timer.\n      lastInvokeTime = time; // Start the timer for the trailing edge.\n\n      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n      return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime,\n          result = wait - timeSinceLastCall;\n      return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n    }\n\n    function shouldInvoke(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n\n      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n\n    function timerExpired() {\n      var time = now();\n\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      } // Restart the timer.\n\n\n      timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    function cancel() {\n      if (timerId !== undefined) {\n        clearTimeout(timerId);\n      }\n\n      lastInvokeTime = 0;\n      lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n\n    function flush() {\n      return timerId === undefined ? result : trailingEdge(now());\n    }\n\n    function debounced() {\n      var time = now(),\n          isInvoking = shouldInvoke(time);\n      lastArgs = arguments;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          timerId = setTimeout(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n\n      if (timerId === undefined) {\n        timerId = setTimeout(timerExpired, wait);\n      }\n\n      return result;\n    }\n\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n  }\n  /**\n   * Creates a throttled function that only invokes `func` at most once per\n   * every `wait` milliseconds. The throttled function comes with a `cancel`\n   * method to cancel delayed `func` invocations and a `flush` method to\n   * immediately invoke them. Provide `options` to indicate whether `func`\n   * should be invoked on the leading and/or trailing edge of the `wait`\n   * timeout. The `func` is invoked with the last arguments provided to the\n   * throttled function. Subsequent calls to the throttled function return the\n   * result of the last `func` invocation.\n   *\n   * **Note:** If `leading` and `trailing` options are `true`, `func` is\n   * invoked on the trailing edge of the timeout only if the throttled function\n   * is invoked more than once during the `wait` timeout.\n   *\n   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n   * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n   *\n   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n   * for details over the differences between `_.throttle` and `_.debounce`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to throttle.\n   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n   * @param {Object} [options={}] The options object.\n   * @param {boolean} [options.leading=true]\n   *  Specify invoking on the leading edge of the timeout.\n   * @param {boolean} [options.trailing=true]\n   *  Specify invoking on the trailing edge of the timeout.\n   * @returns {Function} Returns the new throttled function.\n   * @example\n   *\n   * // Avoid excessively updating the position while scrolling.\n   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n   *\n   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n   * jQuery(element).on('click', throttled);\n   *\n   * // Cancel the trailing throttled invocation.\n   * jQuery(window).on('popstate', throttled.cancel);\n   */\n\n\n  function throttle(func, wait, options) {\n    var leading = true,\n        trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n\n    if (isObject$1(options)) {\n      leading = 'leading' in options ? !!options.leading : leading;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    return debounce(func, wait, {\n      'leading': leading,\n      'maxWait': wait,\n      'trailing': trailing\n    });\n  }\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n\n\n  function isObject$1(value) {\n    var type = _typeof(value);\n\n    return !!value && (type == 'object' || type == 'function');\n  }\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n\n  function isObjectLike(value) {\n    return !!value && _typeof(value) == 'object';\n  }\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n\n\n  function isSymbol(value) {\n    return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString$1.call(value) == symbolTag;\n  }\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n\n\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n\n    if (isSymbol(value)) {\n      return NAN;\n    }\n\n    if (isObject$1(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n      value = isObject$1(other) ? other + '' : other;\n    }\n\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n\n    value = value.replace(reTrim, '');\n    var isBinary = reIsBinary.test(value);\n    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n  }\n\n  var lodash_throttle = throttle;\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n\n  var FUNC_ERROR_TEXT$1 = 'Expected a function';\n  /** Used as references for various `Number` constants. */\n\n  var NAN$1 = 0 / 0;\n  /** `Object#toString` result references. */\n\n  var symbolTag$1 = '[object Symbol]';\n  /** Used to match leading and trailing whitespace. */\n\n  var reTrim$1 = /^\\s+|\\s+$/g;\n  /** Used to detect bad signed hexadecimal string values. */\n\n  var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;\n  /** Used to detect binary string values. */\n\n  var reIsBinary$1 = /^0b[01]+$/i;\n  /** Used to detect octal string values. */\n\n  var reIsOctal$1 = /^0o[0-7]+$/i;\n  /** Built-in method references without a dependency on `root`. */\n\n  var freeParseInt$1 = parseInt;\n  /** Detect free variable `global` from Node.js. */\n\n  var freeGlobal$1 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n  /** Detect free variable `self`. */\n\n  var freeSelf$1 = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n  /** Used as a reference to the global object. */\n\n  var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();\n  /** Used for built-in method references. */\n\n  var objectProto$1 = Object.prototype;\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n  var objectToString$2 = objectProto$1.toString;\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n  var nativeMax$1 = Math.max,\n      nativeMin$1 = Math.min;\n  /**\n   * Gets the timestamp of the number of milliseconds that have elapsed since\n   * the Unix epoch (1 January 1970 00:00:00 UTC).\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Date\n   * @returns {number} Returns the timestamp.\n   * @example\n   *\n   * _.defer(function(stamp) {\n   *   console.log(_.now() - stamp);\n   * }, _.now());\n   * // => Logs the number of milliseconds it took for the deferred invocation.\n   */\n\n  var now$1 = function now$1() {\n    return root$1.Date.now();\n  };\n  /**\n   * Creates a debounced function that delays invoking `func` until after `wait`\n   * milliseconds have elapsed since the last time the debounced function was\n   * invoked. The debounced function comes with a `cancel` method to cancel\n   * delayed `func` invocations and a `flush` method to immediately invoke them.\n   * Provide `options` to indicate whether `func` should be invoked on the\n   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n   * with the last arguments provided to the debounced function. Subsequent\n   * calls to the debounced function return the result of the last `func`\n   * invocation.\n   *\n   * **Note:** If `leading` and `trailing` options are `true`, `func` is\n   * invoked on the trailing edge of the timeout only if the debounced function\n   * is invoked more than once during the `wait` timeout.\n   *\n   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n   * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n   *\n   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n   * for details over the differences between `_.debounce` and `_.throttle`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to debounce.\n   * @param {number} [wait=0] The number of milliseconds to delay.\n   * @param {Object} [options={}] The options object.\n   * @param {boolean} [options.leading=false]\n   *  Specify invoking on the leading edge of the timeout.\n   * @param {number} [options.maxWait]\n   *  The maximum time `func` is allowed to be delayed before it's invoked.\n   * @param {boolean} [options.trailing=true]\n   *  Specify invoking on the trailing edge of the timeout.\n   * @returns {Function} Returns the new debounced function.\n   * @example\n   *\n   * // Avoid costly calculations while the window size is in flux.\n   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n   *\n   * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n   * jQuery(element).on('click', _.debounce(sendMail, 300, {\n   *   'leading': true,\n   *   'trailing': false\n   * }));\n   *\n   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n   * var source = new EventSource('/stream');\n   * jQuery(source).on('message', debounced);\n   *\n   * // Cancel the trailing debounced invocation.\n   * jQuery(window).on('popstate', debounced.cancel);\n   */\n\n\n  function debounce$1(func, wait, options) {\n    var lastArgs,\n        lastThis,\n        maxWait,\n        result,\n        timerId,\n        lastCallTime,\n        lastInvokeTime = 0,\n        leading = false,\n        maxing = false,\n        trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT$1);\n    }\n\n    wait = toNumber$1(wait) || 0;\n\n    if (isObject$2(options)) {\n      leading = !!options.leading;\n      maxing = 'maxWait' in options;\n      maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n      var args = lastArgs,\n          thisArg = lastThis;\n      lastArgs = lastThis = undefined;\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args);\n      return result;\n    }\n\n    function leadingEdge(time) {\n      // Reset any `maxWait` timer.\n      lastInvokeTime = time; // Start the timer for the trailing edge.\n\n      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n      return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime,\n          result = wait - timeSinceLastCall;\n      return maxing ? nativeMin$1(result, maxWait - timeSinceLastInvoke) : result;\n    }\n\n    function shouldInvoke(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n\n      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n\n    function timerExpired() {\n      var time = now$1();\n\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      } // Restart the timer.\n\n\n      timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    function cancel() {\n      if (timerId !== undefined) {\n        clearTimeout(timerId);\n      }\n\n      lastInvokeTime = 0;\n      lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n\n    function flush() {\n      return timerId === undefined ? result : trailingEdge(now$1());\n    }\n\n    function debounced() {\n      var time = now$1(),\n          isInvoking = shouldInvoke(time);\n      lastArgs = arguments;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          timerId = setTimeout(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n\n      if (timerId === undefined) {\n        timerId = setTimeout(timerExpired, wait);\n      }\n\n      return result;\n    }\n\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n  }\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n\n\n  function isObject$2(value) {\n    var type = _typeof(value);\n\n    return !!value && (type == 'object' || type == 'function');\n  }\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n\n  function isObjectLike$1(value) {\n    return !!value && _typeof(value) == 'object';\n  }\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n\n\n  function isSymbol$1(value) {\n    return _typeof(value) == 'symbol' || isObjectLike$1(value) && objectToString$2.call(value) == symbolTag$1;\n  }\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n\n\n  function toNumber$1(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n\n    if (isSymbol$1(value)) {\n      return NAN$1;\n    }\n\n    if (isObject$2(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n      value = isObject$2(other) ? other + '' : other;\n    }\n\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n\n    value = value.replace(reTrim$1, '');\n    var isBinary = reIsBinary$1.test(value);\n    return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;\n  }\n\n  var lodash_debounce = debounce$1;\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n\n  var FUNC_ERROR_TEXT$2 = 'Expected a function';\n  /** Used to stand-in for `undefined` hash values. */\n\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n  /** `Object#toString` result references. */\n\n  var funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]';\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n  /** Used to detect host constructors (Safari). */\n\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n  /** Detect free variable `global` from Node.js. */\n\n  var freeGlobal$2 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n  /** Detect free variable `self`. */\n\n  var freeSelf$2 = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n  /** Used as a reference to the global object. */\n\n  var root$2 = freeGlobal$2 || freeSelf$2 || Function('return this')();\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n  /**\n   * Checks if `value` is a host object in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n   */\n\n\n  function isHostObject(value) {\n    // Many host objects are `Object` objects that can coerce to strings\n    // despite having improperly defined `toString` methods.\n    var result = false;\n\n    if (value != null && typeof value.toString != 'function') {\n      try {\n        result = !!(value + '');\n      } catch (e) {}\n    }\n\n    return result;\n  }\n  /** Used for built-in method references. */\n\n\n  var arrayProto = Array.prototype,\n      funcProto = Function.prototype,\n      objectProto$2 = Object.prototype;\n  /** Used to detect overreaching core-js shims. */\n\n  var coreJsData = root$2['__core-js_shared__'];\n  /** Used to detect methods masquerading as native. */\n\n  var maskSrcKey = function () {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  }();\n  /** Used to resolve the decompiled source of functions. */\n\n\n  var funcToString = funcProto.toString;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n  var objectToString$3 = objectProto$2.toString;\n  /** Used to detect if a method is native. */\n\n  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$1).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n  /** Built-in value references. */\n\n  var splice = arrayProto.splice;\n  /* Built-in method references that are verified to be native. */\n\n  var Map$1 = getNative(root$2, 'Map'),\n      nativeCreate = getNative(Object, 'create');\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Hash(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n\n\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  }\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function hashDelete(key) {\n    return this.has(key) && delete this.__data__[key];\n  }\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function hashGet(key) {\n    var data = this.__data__;\n\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n\n    return hasOwnProperty$1.call(data, key) ? data[key] : undefined;\n  }\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty$1.call(data, key);\n  }\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n\n\n  function hashSet(key, value) {\n    var data = this.__data__;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n    return this;\n  } // Add methods to `Hash`.\n\n\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function ListCache(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n\n\n  function listCacheClear() {\n    this.__data__ = [];\n  }\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n\n    var lastIndex = data.length - 1;\n\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n\n    return true;\n  }\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    return index < 0 ? undefined : data[index][1];\n  }\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n\n\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n\n    return this;\n  } // Add methods to `ListCache`.\n\n\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function MapCache(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n\n\n  function mapCacheClear() {\n    this.__data__ = {\n      'hash': new Hash(),\n      'map': new (Map$1 || ListCache)(),\n      'string': new Hash()\n    };\n  }\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function mapCacheDelete(key) {\n    return getMapData(this, key)['delete'](key);\n  }\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n\n\n  function mapCacheSet(key, value) {\n    getMapData(this, key).set(key, value);\n    return this;\n  } // Add methods to `MapCache`.\n\n\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n\n  function assocIndexOf(array, key) {\n    var length = array.length;\n\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n\n\n  function baseIsNative(value) {\n    if (!isObject$3(value) || isMasked(value)) {\n      return false;\n    }\n\n    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n\n\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n  }\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n\n\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n\n\n  function isKeyable(value) {\n    var type = _typeof(value);\n\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n  }\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n\n\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to process.\n   * @returns {string} Returns the source code.\n   */\n\n\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n\n    return '';\n  }\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n\n\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || resolver && typeof resolver != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT$2);\n    }\n\n    var memoized = function memoized() {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result);\n      return result;\n    };\n\n    memoized.cache = new (memoize.Cache || MapCache)();\n    return memoized;\n  } // Assign cache to `_.memoize`.\n\n\n  memoize.Cache = MapCache;\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n\n\n  function isFunction(value) {\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 8-9 which returns 'object' for typed array and other constructors.\n    var tag = isObject$3(value) ? objectToString$3.call(value) : '';\n    return tag == funcTag || tag == genTag;\n  }\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n\n\n  function isObject$3(value) {\n    var type = _typeof(value);\n\n    return !!value && (type == 'object' || type == 'function');\n  }\n\n  var lodash_memoize = memoize;\n  /**\r\n   * A collection of shims that provide minimal functionality of the ES6 collections.\r\n   *\r\n   * These implementations are not meant to be used outside of the ResizeObserver\r\n   * modules as they cover only a limited range of use cases.\r\n   */\n\n  /* eslint-disable require-jsdoc, valid-jsdoc */\n\n  var MapShim = function () {\n    if (typeof Map !== 'undefined') {\n      return Map;\n    }\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\n\n\n    function getIndex(arr, key) {\n      var result = -1;\n      arr.some(function (entry, index) {\n        if (entry[0] === key) {\n          result = index;\n          return true;\n        }\n\n        return false;\n      });\n      return result;\n    }\n\n    return (\n      /** @class */\n      function () {\n        function class_1() {\n          this.__entries__ = [];\n        }\n\n        Object.defineProperty(class_1.prototype, \"size\", {\n          /**\r\n           * @returns {boolean}\r\n           */\n          get: function get() {\n            return this.__entries__.length;\n          },\n          enumerable: true,\n          configurable: true\n        });\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\n\n        class_1.prototype.get = function (key) {\n          var index = getIndex(this.__entries__, key);\n          var entry = this.__entries__[index];\n          return entry && entry[1];\n        };\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\n\n\n        class_1.prototype.set = function (key, value) {\n          var index = getIndex(this.__entries__, key);\n\n          if (~index) {\n            this.__entries__[index][1] = value;\n          } else {\n            this.__entries__.push([key, value]);\n          }\n        };\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n\n\n        class_1.prototype[\"delete\"] = function (key) {\n          var entries = this.__entries__;\n          var index = getIndex(entries, key);\n\n          if (~index) {\n            entries.splice(index, 1);\n          }\n        };\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n\n\n        class_1.prototype.has = function (key) {\n          return !!~getIndex(this.__entries__, key);\n        };\n        /**\r\n         * @returns {void}\r\n         */\n\n\n        class_1.prototype.clear = function () {\n          this.__entries__.splice(0);\n        };\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\n\n\n        class_1.prototype.forEach = function (callback, ctx) {\n          if (ctx === void 0) {\n            ctx = null;\n          }\n\n          for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n            var entry = _a[_i];\n            callback.call(ctx, entry[1], entry[0]);\n          }\n        };\n\n        return class_1;\n      }()\n    );\n  }();\n  /**\r\n   * Detects whether window and document objects are available in current environment.\r\n   */\n\n\n  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.\n\n  var global$1 = function () {\n    if (typeof global !== 'undefined' && global.Math === Math) {\n      return global;\n    }\n\n    if (typeof self !== 'undefined' && self.Math === Math) {\n      return self;\n    }\n\n    if (typeof window !== 'undefined' && window.Math === Math) {\n      return window;\n    } // eslint-disable-next-line no-new-func\n\n\n    return Function('return this')();\n  }();\n  /**\r\n   * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n   * first one is not supported.\r\n   *\r\n   * @returns {number} Requests' identifier.\r\n   */\n\n\n  var requestAnimationFrame$1 = function () {\n    if (typeof requestAnimationFrame === 'function') {\n      // It's required to use a bounded function because IE sometimes throws\n      // an \"Invalid calling object\" error if rAF is invoked without the global\n      // object on the left hand side.\n      return requestAnimationFrame.bind(global$1);\n    }\n\n    return function (callback) {\n      return setTimeout(function () {\n        return callback(Date.now());\n      }, 1000 / 60);\n    };\n  }(); // Defines minimum timeout before adding a trailing call.\n\n\n  var trailingTimeout = 2;\n  /**\r\n   * Creates a wrapper function which ensures that provided callback will be\r\n   * invoked only once during the specified delay period.\r\n   *\r\n   * @param {Function} callback - Function to be invoked after the delay period.\r\n   * @param {number} delay - Delay after which to invoke callback.\r\n   * @returns {Function}\r\n   */\n\n  function throttle$1(callback, delay) {\n    var leadingCall = false,\n        trailingCall = false,\n        lastCallTime = 0;\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\n\n    function resolvePending() {\n      if (leadingCall) {\n        leadingCall = false;\n        callback();\n      }\n\n      if (trailingCall) {\n        proxy();\n      }\n    }\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    function timeoutCallback() {\n      requestAnimationFrame$1(resolvePending);\n    }\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    function proxy() {\n      var timeStamp = Date.now();\n\n      if (leadingCall) {\n        // Reject immediately following calls.\n        if (timeStamp - lastCallTime < trailingTimeout) {\n          return;\n        } // Schedule new call to be in invoked when the pending one is resolved.\n        // This is important for \"transitions\" which never actually start\n        // immediately so there is a chance that we might miss one if change\n        // happens amids the pending invocation.\n\n\n        trailingCall = true;\n      } else {\n        leadingCall = true;\n        trailingCall = false;\n        setTimeout(timeoutCallback, delay);\n      }\n\n      lastCallTime = timeStamp;\n    }\n\n    return proxy;\n  } // Minimum delay before invoking the update of observers.\n\n\n  var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that\n  // might affect dimensions of observed elements.\n\n  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.\n\n  var mutationObserverSupported = typeof MutationObserver !== 'undefined';\n  /**\r\n   * Singleton controller class which handles updates of ResizeObserver instances.\r\n   */\n\n  var ResizeObserverController =\n  /** @class */\n  function () {\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\n    function ResizeObserverController() {\n      /**\r\n       * Indicates whether DOM listeners have been added.\r\n       *\r\n       * @private {boolean}\r\n       */\n      this.connected_ = false;\n      /**\r\n       * Tells that controller has subscribed for Mutation Events.\r\n       *\r\n       * @private {boolean}\r\n       */\n\n      this.mutationEventsAdded_ = false;\n      /**\r\n       * Keeps reference to the instance of MutationObserver.\r\n       *\r\n       * @private {MutationObserver}\r\n       */\n\n      this.mutationsObserver_ = null;\n      /**\r\n       * A list of connected observers.\r\n       *\r\n       * @private {Array<ResizeObserverSPI>}\r\n       */\n\n      this.observers_ = [];\n      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n      this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);\n    }\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverController.prototype.addObserver = function (observer) {\n      if (!~this.observers_.indexOf(observer)) {\n        this.observers_.push(observer);\n      } // Add listeners if they haven't been added yet.\n\n\n      if (!this.connected_) {\n        this.connect_();\n      }\n    };\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverController.prototype.removeObserver = function (observer) {\n      var observers = this.observers_;\n      var index = observers.indexOf(observer); // Remove observer if it's present in registry.\n\n      if (~index) {\n        observers.splice(index, 1);\n      } // Remove listeners if controller has no connected observers.\n\n\n      if (!observers.length && this.connected_) {\n        this.disconnect_();\n      }\n    };\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverController.prototype.refresh = function () {\n      var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might\n      // be future ones caused by CSS transitions.\n\n      if (changesDetected) {\n        this.refresh();\n      }\n    };\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\n\n\n    ResizeObserverController.prototype.updateObservers_ = function () {\n      // Collect observers that have active observations.\n      var activeObservers = this.observers_.filter(function (observer) {\n        return observer.gatherActive(), observer.hasActive();\n      }); // Deliver notifications in a separate cycle in order to avoid any\n      // collisions between observers, e.g. when multiple instances of\n      // ResizeObserver are tracking the same element and the callback of one\n      // of them changes content dimensions of the observed target. Sometimes\n      // this may result in notifications being blocked for the rest of observers.\n\n      activeObservers.forEach(function (observer) {\n        return observer.broadcastActive();\n      });\n      return activeObservers.length > 0;\n    };\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverController.prototype.connect_ = function () {\n      // Do nothing if running in a non-browser environment or if listeners\n      // have been already added.\n      if (!isBrowser || this.connected_) {\n        return;\n      } // Subscription to the \"Transitionend\" event is used as a workaround for\n      // delayed transitions. This way it's possible to capture at least the\n      // final state of an element.\n\n\n      document.addEventListener('transitionend', this.onTransitionEnd_);\n      window.addEventListener('resize', this.refresh);\n\n      if (mutationObserverSupported) {\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\n        this.mutationsObserver_.observe(document, {\n          attributes: true,\n          childList: true,\n          characterData: true,\n          subtree: true\n        });\n      } else {\n        document.addEventListener('DOMSubtreeModified', this.refresh);\n        this.mutationEventsAdded_ = true;\n      }\n\n      this.connected_ = true;\n    };\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverController.prototype.disconnect_ = function () {\n      // Do nothing if running in a non-browser environment or if listeners\n      // have been already removed.\n      if (!isBrowser || !this.connected_) {\n        return;\n      }\n\n      document.removeEventListener('transitionend', this.onTransitionEnd_);\n      window.removeEventListener('resize', this.refresh);\n\n      if (this.mutationsObserver_) {\n        this.mutationsObserver_.disconnect();\n      }\n\n      if (this.mutationEventsAdded_) {\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\n      }\n\n      this.mutationsObserver_ = null;\n      this.mutationEventsAdded_ = false;\n      this.connected_ = false;\n    };\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\n      var _b = _a.propertyName,\n          propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.\n\n      var isReflowProperty = transitionKeys.some(function (key) {\n        return !!~propertyName.indexOf(key);\n      });\n\n      if (isReflowProperty) {\n        this.refresh();\n      }\n    };\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\n\n\n    ResizeObserverController.getInstance = function () {\n      if (!this.instance_) {\n        this.instance_ = new ResizeObserverController();\n      }\n\n      return this.instance_;\n    };\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\n\n\n    ResizeObserverController.instance_ = null;\n    return ResizeObserverController;\n  }();\n  /**\r\n   * Defines non-writable/enumerable properties of the provided target object.\r\n   *\r\n   * @param {Object} target - Object for which to define properties.\r\n   * @param {Object} props - Properties to be defined.\r\n   * @returns {Object} Target object.\r\n   */\n\n\n  var defineConfigurable = function defineConfigurable(target, props) {\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n      var key = _a[_i];\n      Object.defineProperty(target, key, {\n        value: props[key],\n        enumerable: false,\n        writable: false,\n        configurable: true\n      });\n    }\n\n    return target;\n  };\n  /**\r\n   * Returns the global object associated with provided element.\r\n   *\r\n   * @param {Object} target\r\n   * @returns {Object}\r\n   */\n\n\n  var getWindowOf = function getWindowOf(target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from\n    // provided element.\n\n    return ownerGlobal || global$1;\n  }; // Placeholder of an empty content rectangle.\n\n\n  var emptyRect = createRectInit(0, 0, 0, 0);\n  /**\r\n   * Converts provided string to a number.\r\n   *\r\n   * @param {number|string} value\r\n   * @returns {number}\r\n   */\n\n  function toFloat(value) {\n    return parseFloat(value) || 0;\n  }\n  /**\r\n   * Extracts borders size from provided styles.\r\n   *\r\n   * @param {CSSStyleDeclaration} styles\r\n   * @param {...string} positions - Borders positions (top, right, ...)\r\n   * @returns {number}\r\n   */\n\n\n  function getBordersSize(styles) {\n    var positions = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      positions[_i - 1] = arguments[_i];\n    }\n\n    return positions.reduce(function (size, position) {\n      var value = styles['border-' + position + '-width'];\n      return size + toFloat(value);\n    }, 0);\n  }\n  /**\r\n   * Extracts paddings sizes from provided styles.\r\n   *\r\n   * @param {CSSStyleDeclaration} styles\r\n   * @returns {Object} Paddings box.\r\n   */\n\n\n  function getPaddings(styles) {\n    var positions = ['top', 'right', 'bottom', 'left'];\n    var paddings = {};\n\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n      var position = positions_1[_i];\n      var value = styles['padding-' + position];\n      paddings[position] = toFloat(value);\n    }\n\n    return paddings;\n  }\n  /**\r\n   * Calculates content rectangle of provided SVG element.\r\n   *\r\n   * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n   *      to be calculated.\r\n   * @returns {DOMRectInit}\r\n   */\n\n\n  function getSVGContentRect(target) {\n    var bbox = target.getBBox();\n    return createRectInit(0, 0, bbox.width, bbox.height);\n  }\n  /**\r\n   * Calculates content rectangle of provided HTMLElement.\r\n   *\r\n   * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n   * @returns {DOMRectInit}\r\n   */\n\n\n  function getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth,\n        clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n\n    if (!clientWidth && !clientHeight) {\n      return emptyRect;\n    }\n\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n\n    var width = toFloat(styles.width),\n        height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n\n    if (styles.boxSizing === 'border-box') {\n      // Following conditions are required to handle Internet Explorer which\n      // doesn't include paddings and borders to computed CSS dimensions.\n      //\n      // We can say that if CSS dimensions + paddings are equal to the \"client\"\n      // properties then it's either IE, and thus we don't need to subtract\n      // anything, or an element merely doesn't have paddings/borders styles.\n      if (Math.round(width + horizPad) !== clientWidth) {\n        width -= getBordersSize(styles, 'left', 'right') + horizPad;\n      }\n\n      if (Math.round(height + vertPad) !== clientHeight) {\n        height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n      }\n    } // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n\n\n    if (!isDocumentElement(target)) {\n      // In some browsers (only in Firefox, actually) CSS width & height\n      // include scroll bars size which can be removed at this step as scroll\n      // bars are the only difference between rounded dimensions + paddings\n      // and \"client\" properties, though that is not always true in Chrome.\n      var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n      var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of \"client\" properties.\n      // E.g. for an element with content width of 314.2px it sometimes gives\n      // the client width of 315px and for the width of 314.7px it may give\n      // 314px. And it doesn't happen all the time. So just ignore this delta\n      // as a non-relevant.\n\n      if (Math.abs(vertScrollbar) !== 1) {\n        width -= vertScrollbar;\n      }\n\n      if (Math.abs(horizScrollbar) !== 1) {\n        height -= horizScrollbar;\n      }\n    }\n\n    return createRectInit(paddings.left, paddings.top, width, height);\n  }\n  /**\r\n   * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n   *\r\n   * @param {Element} target - Element to be checked.\r\n   * @returns {boolean}\r\n   */\n\n\n  var isSVGGraphicsElement = function () {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== 'undefined') {\n      return function (target) {\n        return target instanceof getWindowOf(target).SVGGraphicsElement;\n      };\n    } // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n\n\n    return function (target) {\n      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';\n    };\n  }();\n  /**\r\n   * Checks whether provided element is a document element (<html>).\r\n   *\r\n   * @param {Element} target - Element to be checked.\r\n   * @returns {boolean}\r\n   */\n\n\n  function isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n  }\n  /**\r\n   * Calculates an appropriate content rectangle for provided html or svg element.\r\n   *\r\n   * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n   * @returns {DOMRectInit}\r\n   */\n\n\n  function getContentRect(target) {\n    if (!isBrowser) {\n      return emptyRect;\n    }\n\n    if (isSVGGraphicsElement(target)) {\n      return getSVGContentRect(target);\n    }\n\n    return getHTMLElementContentRect(target);\n  }\n  /**\r\n   * Creates rectangle with an interface of the DOMRectReadOnly.\r\n   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n   *\r\n   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n   * @returns {DOMRectReadOnly}\r\n   */\n\n\n  function createReadOnlyRect(_a) {\n    var x = _a.x,\n        y = _a.y,\n        width = _a.width,\n        height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.\n\n    defineConfigurable(rect, {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      top: y,\n      right: x + width,\n      bottom: height + y,\n      left: x\n    });\n    return rect;\n  }\n  /**\r\n   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n   *\r\n   * @param {number} x - X coordinate.\r\n   * @param {number} y - Y coordinate.\r\n   * @param {number} width - Rectangle's width.\r\n   * @param {number} height - Rectangle's height.\r\n   * @returns {DOMRectInit}\r\n   */\n\n\n  function createRectInit(x, y, width, height) {\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Class that is responsible for computations of the content rectangle of\r\n   * provided DOM element and for keeping track of it's changes.\r\n   */\n\n\n  var ResizeObservation =\n  /** @class */\n  function () {\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\n    function ResizeObservation(target) {\n      /**\r\n       * Broadcasted width of content rectangle.\r\n       *\r\n       * @type {number}\r\n       */\n      this.broadcastWidth = 0;\n      /**\r\n       * Broadcasted height of content rectangle.\r\n       *\r\n       * @type {number}\r\n       */\n\n      this.broadcastHeight = 0;\n      /**\r\n       * Reference to the last observed content rectangle.\r\n       *\r\n       * @private {DOMRectInit}\r\n       */\n\n      this.contentRect_ = createRectInit(0, 0, 0, 0);\n      this.target = target;\n    }\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    ResizeObservation.prototype.isActive = function () {\n      var rect = getContentRect(this.target);\n      this.contentRect_ = rect;\n      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n    };\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\n\n\n    ResizeObservation.prototype.broadcastRect = function () {\n      var rect = this.contentRect_;\n      this.broadcastWidth = rect.width;\n      this.broadcastHeight = rect.height;\n      return rect;\n    };\n\n    return ResizeObservation;\n  }();\n\n  var ResizeObserverEntry =\n  /** @class */\n  function () {\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\n    function ResizeObserverEntry(target, rectInit) {\n      var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable\n      // and are also not enumerable in the native implementation.\n      //\n      // Property accessors are not being used as they'd require to define a\n      // private WeakMap storage which may cause memory leaks in browsers that\n      // don't support this type of collections.\n\n      defineConfigurable(this, {\n        target: target,\n        contentRect: contentRect\n      });\n    }\n\n    return ResizeObserverEntry;\n  }();\n\n  var ResizeObserverSPI =\n  /** @class */\n  function () {\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\n      /**\r\n       * Collection of resize observations that have detected changes in dimensions\r\n       * of elements.\r\n       *\r\n       * @private {Array<ResizeObservation>}\r\n       */\n      this.activeObservations_ = [];\n      /**\r\n       * Registry of the ResizeObservation instances.\r\n       *\r\n       * @private {Map<Element, ResizeObservation>}\r\n       */\n\n      this.observations_ = new MapShim();\n\n      if (typeof callback !== 'function') {\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\n      }\n\n      this.callback_ = callback;\n      this.controller_ = controller;\n      this.callbackCtx_ = callbackCtx;\n    }\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverSPI.prototype.observe = function (target) {\n      if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n      } // Do nothing if current environment doesn't have the Element interface.\n\n\n      if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n      }\n\n      if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n      }\n\n      var observations = this.observations_; // Do nothing if element is already being observed.\n\n      if (observations.has(target)) {\n        return;\n      }\n\n      observations.set(target, new ResizeObservation(target));\n      this.controller_.addObserver(this); // Force the update of observations.\n\n      this.controller_.refresh();\n    };\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverSPI.prototype.unobserve = function (target) {\n      if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n      } // Do nothing if current environment doesn't have the Element interface.\n\n\n      if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n      }\n\n      if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n      }\n\n      var observations = this.observations_; // Do nothing if element is not being observed.\n\n      if (!observations.has(target)) {\n        return;\n      }\n\n      observations[\"delete\"](target);\n\n      if (!observations.size) {\n        this.controller_.removeObserver(this);\n      }\n    };\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverSPI.prototype.disconnect = function () {\n      this.clearActive();\n      this.observations_.clear();\n      this.controller_.removeObserver(this);\n    };\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverSPI.prototype.gatherActive = function () {\n      var _this = this;\n\n      this.clearActive();\n      this.observations_.forEach(function (observation) {\n        if (observation.isActive()) {\n          _this.activeObservations_.push(observation);\n        }\n      });\n    };\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverSPI.prototype.broadcastActive = function () {\n      // Do nothing if observer doesn't have active observations.\n      if (!this.hasActive()) {\n        return;\n      }\n\n      var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.\n\n      var entries = this.activeObservations_.map(function (observation) {\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n      });\n      this.callback_.call(ctx, entries, ctx);\n      this.clearActive();\n    };\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\n\n\n    ResizeObserverSPI.prototype.clearActive = function () {\n      this.activeObservations_.splice(0);\n    };\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    ResizeObserverSPI.prototype.hasActive = function () {\n      return this.activeObservations_.length > 0;\n    };\n\n    return ResizeObserverSPI;\n  }(); // Registry of internal observers. If WeakMap is not available use current shim\n  // for the Map collection as it has all required methods and because WeakMap\n  // can't be fully polyfilled anyway.\n\n\n  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n  /**\r\n   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n   * exposing only those methods and properties that are defined in the spec.\r\n   */\n\n  var ResizeObserver =\n  /** @class */\n  function () {\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\n    function ResizeObserver(callback) {\n      if (!(this instanceof ResizeObserver)) {\n        throw new TypeError('Cannot call a class as a function.');\n      }\n\n      if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n      }\n\n      var controller = ResizeObserverController.getInstance();\n      var observer = new ResizeObserverSPI(callback, controller, this);\n      observers.set(this, observer);\n    }\n\n    return ResizeObserver;\n  }(); // Expose public methods of ResizeObserver.\n\n\n  ['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n    ResizeObserver.prototype[method] = function () {\n      var _a;\n\n      return (_a = observers.get(this))[method].apply(_a, arguments);\n    };\n  });\n\n  var index = function () {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== 'undefined') {\n      return global$1.ResizeObserver;\n    }\n\n    return ResizeObserver;\n  }();\n\n  var cachedScrollbarWidth = null;\n  var cachedDevicePixelRatio = null;\n\n  if (canUseDom) {\n    window.addEventListener('resize', function () {\n      if (cachedDevicePixelRatio !== window.devicePixelRatio) {\n        cachedDevicePixelRatio = window.devicePixelRatio;\n        cachedScrollbarWidth = null;\n      }\n    });\n  }\n\n  function scrollbarWidth() {\n    if (cachedScrollbarWidth === null) {\n      if (typeof document === 'undefined') {\n        cachedScrollbarWidth = 0;\n        return cachedScrollbarWidth;\n      }\n\n      var body = document.body;\n      var box = document.createElement('div');\n      box.classList.add('simplebar-hide-scrollbar');\n      body.appendChild(box);\n      var width = box.getBoundingClientRect().right;\n      body.removeChild(box);\n      cachedScrollbarWidth = width;\n    }\n\n    return cachedScrollbarWidth;\n  } // `Array.prototype.{ reduce, reduceRight }` methods implementation\n\n\n  var createMethod$4 = function createMethod$4(IS_RIGHT) {\n    return function (that, callbackfn, argumentsLength, memo) {\n      aFunction$1(callbackfn);\n      var O = toObject(that);\n      var self = indexedObject(O);\n      var length = toLength(O.length);\n      var index = IS_RIGHT ? length - 1 : 0;\n      var i = IS_RIGHT ? -1 : 1;\n      if (argumentsLength < 2) while (true) {\n        if (index in self) {\n          memo = self[index];\n          index += i;\n          break;\n        }\n\n        index += i;\n\n        if (IS_RIGHT ? index < 0 : length <= index) {\n          throw TypeError('Reduce of empty array with no initial value');\n        }\n      }\n\n      for (; IS_RIGHT ? index >= 0 : length > index; index += i) {\n        if (index in self) {\n          memo = callbackfn(memo, self[index], index, O);\n        }\n      }\n\n      return memo;\n    };\n  };\n\n  var arrayReduce = {\n    // `Array.prototype.reduce` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n    left: createMethod$4(false),\n    // `Array.prototype.reduceRight` method\n    // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright\n    right: createMethod$4(true)\n  };\n  var $reduce = arrayReduce.left; // `Array.prototype.reduce` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n\n  _export({\n    target: 'Array',\n    proto: true,\n    forced: sloppyArrayMethod('reduce')\n  }, {\n    reduce: function reduce(callbackfn\n    /* , initialValue */\n    ) {\n      return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n    }\n  });\n\n  var defineProperty$1 = objectDefineProperty.f;\n  var FunctionPrototype = Function.prototype;\n  var FunctionPrototypeToString = FunctionPrototype.toString;\n  var nameRE = /^\\s*function ([^ (]*)/;\n  var NAME = 'name'; // Function instances `.name` property\n  // https://tc39.github.io/ecma262/#sec-function-instances-name\n\n  if (descriptors && !(NAME in FunctionPrototype)) {\n    defineProperty$1(FunctionPrototype, NAME, {\n      configurable: true,\n      get: function get() {\n        try {\n          return FunctionPrototypeToString.call(this).match(nameRE)[1];\n        } catch (error) {\n          return '';\n        }\n      }\n    });\n  } // `RegExp.prototype.flags` getter implementation\n  // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags\n\n\n  var regexpFlags = function regexpFlags() {\n    var that = anObject(this);\n    var result = '';\n    if (that.global) result += 'g';\n    if (that.ignoreCase) result += 'i';\n    if (that.multiline) result += 'm';\n    if (that.dotAll) result += 's';\n    if (that.unicode) result += 'u';\n    if (that.sticky) result += 'y';\n    return result;\n  };\n\n  var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the\n  // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n  // which loads this file before patching the method.\n\n  var nativeReplace = String.prototype.replace;\n  var patchedExec = nativeExec;\n\n  var UPDATES_LAST_INDEX_WRONG = function () {\n    var re1 = /a/;\n    var re2 = /b*/g;\n    nativeExec.call(re1, 'a');\n    nativeExec.call(re2, 'a');\n    return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n  }(); // nonparticipating capturing group, copied from es5-shim's String#split patch.\n\n\n  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;\n\n  if (PATCH) {\n    patchedExec = function exec(str) {\n      var re = this;\n      var lastIndex, reCopy, match, i;\n\n      if (NPCG_INCLUDED) {\n        reCopy = new RegExp('^' + re.source + '$(?!\\\\s)', regexpFlags.call(re));\n      }\n\n      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n      match = nativeExec.call(re, str);\n\n      if (UPDATES_LAST_INDEX_WRONG && match) {\n        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n      }\n\n      if (NPCG_INCLUDED && match && match.length > 1) {\n        // Fix browsers whose `exec` methods don't consistently return `undefined`\n        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n        nativeReplace.call(match[0], reCopy, function () {\n          for (i = 1; i < arguments.length - 2; i++) {\n            if (arguments[i] === undefined) match[i] = undefined;\n          }\n        });\n      }\n\n      return match;\n    };\n  }\n\n  var regexpExec = patchedExec;\n\n  _export({\n    target: 'RegExp',\n    proto: true,\n    forced: /./.exec !== regexpExec\n  }, {\n    exec: regexpExec\n  });\n\n  var SPECIES$2 = wellKnownSymbol('species');\n  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n    // #replace needs built-in support for named groups.\n    // #match works fine because it just return the exec results, even if it has\n    // a \"grops\" property.\n    var re = /./;\n\n    re.exec = function () {\n      var result = [];\n      result.groups = {\n        a: '7'\n      };\n      return result;\n    };\n\n    return ''.replace(re, '$<a>') !== '7';\n  }); // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n  // Weex JS has frozen built-in prototypes, so use try / catch wrapper\n\n  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n    var re = /(?:)/;\n    var originalExec = re.exec;\n\n    re.exec = function () {\n      return originalExec.apply(this, arguments);\n    };\n\n    var result = 'ab'.split(re);\n    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n  });\n\n  var fixRegexpWellKnownSymbolLogic = function fixRegexpWellKnownSymbolLogic(KEY, length, exec, sham) {\n    var SYMBOL = wellKnownSymbol(KEY);\n    var DELEGATES_TO_SYMBOL = !fails(function () {\n      // String methods call symbol-named RegEp methods\n      var O = {};\n\n      O[SYMBOL] = function () {\n        return 7;\n      };\n\n      return ''[KEY](O) != 7;\n    });\n    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {\n      // Symbol-named RegExp methods call .exec\n      var execCalled = false;\n      var re = /a/;\n\n      re.exec = function () {\n        execCalled = true;\n        return null;\n      };\n\n      if (KEY === 'split') {\n        // RegExp[@@split] doesn't call the regex's exec method, but first creates\n        // a new one. We need to return the patched regex when creating the new one.\n        re.constructor = {};\n\n        re.constructor[SPECIES$2] = function () {\n          return re;\n        };\n      }\n\n      re[SYMBOL]('');\n      return !execCalled;\n    });\n\n    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {\n      var nativeRegExpMethod = /./[SYMBOL];\n      var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n        if (regexp.exec === regexpExec) {\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n            // The native String method already delegates to @@method (this\n            // polyfilled function), leasing to infinite recursion.\n            // We avoid it by directly calling the native @@method method.\n            return {\n              done: true,\n              value: nativeRegExpMethod.call(regexp, str, arg2)\n            };\n          }\n\n          return {\n            done: true,\n            value: nativeMethod.call(str, regexp, arg2)\n          };\n        }\n\n        return {\n          done: false\n        };\n      });\n      var stringMethod = methods[0];\n      var regexMethod = methods[1];\n      redefine(String.prototype, KEY, stringMethod);\n      redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) {\n        return regexMethod.call(string, this, arg);\n      } // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) {\n        return regexMethod.call(string, this);\n      });\n      if (sham) hide(RegExp.prototype[SYMBOL], 'sham', true);\n    }\n  };\n\n  var charAt$1 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation\n  // https://tc39.github.io/ecma262/#sec-advancestringindex\n\n  var advanceStringIndex = function advanceStringIndex(S, index, unicode) {\n    return index + (unicode ? charAt$1(S, index).length : 1);\n  }; // `RegExpExec` abstract operation\n  // https://tc39.github.io/ecma262/#sec-regexpexec\n\n\n  var regexpExecAbstract = function regexpExecAbstract(R, S) {\n    var exec = R.exec;\n\n    if (typeof exec === 'function') {\n      var result = exec.call(R, S);\n\n      if (_typeof(result) !== 'object') {\n        throw TypeError('RegExp exec method returned something other than an Object or null');\n      }\n\n      return result;\n    }\n\n    if (classofRaw(R) !== 'RegExp') {\n      throw TypeError('RegExp#exec called on incompatible receiver');\n    }\n\n    return regexpExec.call(R, S);\n  }; // @@match logic\n\n\n  fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {\n    return [// `String.prototype.match` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.match\n    function match(regexp) {\n      var O = requireObjectCoercible(this);\n      var matcher = regexp == undefined ? undefined : regexp[MATCH];\n      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n    }, // `RegExp.prototype[@@match]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match\n    function (regexp) {\n      var res = maybeCallNative(nativeMatch, regexp, this);\n      if (res.done) return res.value;\n      var rx = anObject(regexp);\n      var S = String(this);\n      if (!rx.global) return regexpExecAbstract(rx, S);\n      var fullUnicode = rx.unicode;\n      rx.lastIndex = 0;\n      var A = [];\n      var n = 0;\n      var result;\n\n      while ((result = regexpExecAbstract(rx, S)) !== null) {\n        var matchStr = String(result[0]);\n        A[n] = matchStr;\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n        n++;\n      }\n\n      return n === 0 ? null : A;\n    }];\n  });\n  var max$1 = Math.max;\n  var min$2 = Math.min;\n  var floor$1 = Math.floor;\n  var SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d\\d?|<[^>]*>)/g;\n  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d\\d?)/g;\n\n  var maybeToString = function maybeToString(it) {\n    return it === undefined ? it : String(it);\n  }; // @@replace logic\n\n\n  fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative) {\n    return [// `String.prototype.replace` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = requireObjectCoercible(this);\n      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];\n      return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);\n    }, // `RegExp.prototype[@@replace]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace\n    function (regexp, replaceValue) {\n      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);\n      if (res.done) return res.value;\n      var rx = anObject(regexp);\n      var S = String(this);\n      var functionalReplace = typeof replaceValue === 'function';\n      if (!functionalReplace) replaceValue = String(replaceValue);\n      var global = rx.global;\n\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n\n      var results = [];\n\n      while (true) {\n        var result = regexpExecAbstract(rx, S);\n        if (result === null) break;\n        results.push(result);\n        if (!global) break;\n        var matchStr = String(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n        var matched = String(result[0]);\n        var position = max$1(min$2(toInteger(result.index), S.length), 0);\n        var captures = []; // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n\n        for (var j = 1; j < result.length; j++) {\n          captures.push(maybeToString(result[j]));\n        }\n\n        var namedCaptures = result.groups;\n\n        if (functionalReplace) {\n          var replacerArgs = [matched].concat(captures, position, S);\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n\n        if (position >= nextSourcePosition) {\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n\n      return accumulatedResult + S.slice(nextSourcePosition);\n    }]; // https://tc39.github.io/ecma262/#sec-getsubstitution\n\n    function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n      var tailPos = position + matched.length;\n      var m = captures.length;\n      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n\n      if (namedCaptures !== undefined) {\n        namedCaptures = toObject(namedCaptures);\n        symbols = SUBSTITUTION_SYMBOLS;\n      }\n\n      return nativeReplace.call(replacement, symbols, function (match, ch) {\n        var capture;\n\n        switch (ch.charAt(0)) {\n          case '$':\n            return '$';\n\n          case '&':\n            return matched;\n\n          case '`':\n            return str.slice(0, position);\n\n          case \"'\":\n            return str.slice(tailPos);\n\n          case '<':\n            capture = namedCaptures[ch.slice(1, -1)];\n            break;\n\n          default:\n            // \\d\\d?\n            var n = +ch;\n            if (n === 0) return match;\n\n            if (n > m) {\n              var f = floor$1(n / 10);\n              if (f === 0) return match;\n              if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n              return match;\n            }\n\n            capture = captures[n - 1];\n        }\n\n        return capture === undefined ? '' : capture;\n      });\n    }\n  }); // Helper function to retrieve options from element attributes\n\n  var getOptions = function getOptions(obj) {\n    var options = Array.prototype.reduce.call(obj, function (acc, attribute) {\n      var option = attribute.name.match(/data-simplebar-(.+)/);\n\n      if (option) {\n        var key = option[1].replace(/\\W+(.)/g, function (x, chr) {\n          return chr.toUpperCase();\n        });\n\n        switch (attribute.value) {\n          case 'true':\n            acc[key] = true;\n            break;\n\n          case 'false':\n            acc[key] = false;\n            break;\n\n          case undefined:\n            acc[key] = true;\n            break;\n\n          default:\n            acc[key] = attribute.value;\n        }\n      }\n\n      return acc;\n    }, {});\n    return options;\n  };\n\n  function getElementWindow(element) {\n    if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) {\n      return window;\n    }\n\n    return element.ownerDocument.defaultView;\n  }\n\n  function getElementDocument(element) {\n    if (!element || !element.ownerDocument) {\n      return document;\n    }\n\n    return element.ownerDocument;\n  }\n\n  var SimpleBar = /*#__PURE__*/function () {\n    function SimpleBar(element, options) {\n      var _this = this;\n\n      this.onScroll = function () {\n        var elWindow = getElementWindow(_this.el);\n\n        if (!_this.scrollXTicking) {\n          elWindow.requestAnimationFrame(_this.scrollX);\n          _this.scrollXTicking = true;\n        }\n\n        if (!_this.scrollYTicking) {\n          elWindow.requestAnimationFrame(_this.scrollY);\n          _this.scrollYTicking = true;\n        }\n      };\n\n      this.scrollX = function () {\n        if (_this.axis.x.isOverflowing) {\n          _this.showScrollbar('x');\n\n          _this.positionScrollbar('x');\n        }\n\n        _this.scrollXTicking = false;\n      };\n\n      this.scrollY = function () {\n        if (_this.axis.y.isOverflowing) {\n          _this.showScrollbar('y');\n\n          _this.positionScrollbar('y');\n        }\n\n        _this.scrollYTicking = false;\n      };\n\n      this.onMouseEnter = function () {\n        _this.showScrollbar('x');\n\n        _this.showScrollbar('y');\n      };\n\n      this.onMouseMove = function (e) {\n        _this.mouseX = e.clientX;\n        _this.mouseY = e.clientY;\n\n        if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n          _this.onMouseMoveForAxis('x');\n        }\n\n        if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n          _this.onMouseMoveForAxis('y');\n        }\n      };\n\n      this.onMouseLeave = function () {\n        _this.onMouseMove.cancel();\n\n        if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n          _this.onMouseLeaveForAxis('x');\n        }\n\n        if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n          _this.onMouseLeaveForAxis('y');\n        }\n\n        _this.mouseX = -1;\n        _this.mouseY = -1;\n      };\n\n      this.onWindowResize = function () {\n        // Recalculate scrollbarWidth in case it's a zoom\n        _this.scrollbarWidth = _this.getScrollbarWidth();\n\n        _this.hideNativeScrollbar();\n      };\n\n      this.hideScrollbars = function () {\n        _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n        _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n\n        if (!_this.isWithinBounds(_this.axis.y.track.rect)) {\n          _this.axis.y.scrollbar.el.classList.remove(_this.classNames.visible);\n\n          _this.axis.y.isVisible = false;\n        }\n\n        if (!_this.isWithinBounds(_this.axis.x.track.rect)) {\n          _this.axis.x.scrollbar.el.classList.remove(_this.classNames.visible);\n\n          _this.axis.x.isVisible = false;\n        }\n      };\n\n      this.onPointerEvent = function (e) {\n        var isWithinTrackXBounds, isWithinTrackYBounds;\n        _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n        _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n\n        if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n          isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);\n        }\n\n        if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n          isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);\n        } // If any pointer event is called on the scrollbar\n\n\n        if (isWithinTrackXBounds || isWithinTrackYBounds) {\n          // Preventing the event's default action stops text being\n          // selectable during the drag.\n          e.preventDefault(); // Prevent event leaking\n\n          e.stopPropagation();\n\n          if (e.type === 'mousedown') {\n            if (isWithinTrackXBounds) {\n              _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();\n\n              if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) {\n                _this.onDragStart(e, 'x');\n              } else {\n                _this.onTrackClick(e, 'x');\n              }\n            }\n\n            if (isWithinTrackYBounds) {\n              _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();\n\n              if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) {\n                _this.onDragStart(e, 'y');\n              } else {\n                _this.onTrackClick(e, 'y');\n              }\n            }\n          }\n        }\n      };\n\n      this.drag = function (e) {\n        var eventOffset;\n        var track = _this.axis[_this.draggedAxis].track;\n        var trackSize = track.rect[_this.axis[_this.draggedAxis].sizeAttr];\n        var scrollbar = _this.axis[_this.draggedAxis].scrollbar;\n        var contentSize = _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollSizeAttr];\n        var hostSize = parseInt(_this.elStyles[_this.axis[_this.draggedAxis].sizeAttr], 10);\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (_this.draggedAxis === 'y') {\n          eventOffset = e.pageY;\n        } else {\n          eventOffset = e.pageX;\n        } // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n\n\n        var dragPos = eventOffset - track.rect[_this.axis[_this.draggedAxis].offsetAttr] - _this.axis[_this.draggedAxis].dragOffset; // Convert the mouse position into a percentage of the scrollbar height/width.\n\n        var dragPerc = dragPos / (trackSize - scrollbar.size); // Scroll the content by the same percentage.\n\n        var scrollPos = dragPerc * (contentSize - hostSize); // Fix browsers inconsistency on RTL\n\n        if (_this.draggedAxis === 'x') {\n          scrollPos = _this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollbarInverted ? scrollPos - (trackSize + scrollbar.size) : scrollPos;\n          scrollPos = _this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollingInverted ? -scrollPos : scrollPos;\n        }\n\n        _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;\n      };\n\n      this.onEndDrag = function (e) {\n        var elDocument = getElementDocument(_this.el);\n        var elWindow = getElementWindow(_this.el);\n        e.preventDefault();\n        e.stopPropagation();\n\n        _this.el.classList.remove(_this.classNames.dragging);\n\n        elDocument.removeEventListener('mousemove', _this.drag, true);\n        elDocument.removeEventListener('mouseup', _this.onEndDrag, true);\n        _this.removePreventClickId = elWindow.setTimeout(function () {\n          // Remove these asynchronously so we still suppress click events\n          // generated simultaneously with mouseup.\n          elDocument.removeEventListener('click', _this.preventClick, true);\n          elDocument.removeEventListener('dblclick', _this.preventClick, true);\n          _this.removePreventClickId = null;\n        });\n      };\n\n      this.preventClick = function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n      };\n\n      this.el = element;\n      this.minScrollbarWidth = 20;\n      this.options = Object.assign({}, SimpleBar.defaultOptions, {}, options);\n      this.classNames = Object.assign({}, SimpleBar.defaultOptions.classNames, {}, this.options.classNames);\n      this.axis = {\n        x: {\n          scrollOffsetAttr: 'scrollLeft',\n          sizeAttr: 'width',\n          scrollSizeAttr: 'scrollWidth',\n          offsetSizeAttr: 'offsetWidth',\n          offsetAttr: 'left',\n          overflowAttr: 'overflowX',\n          dragOffset: 0,\n          isOverflowing: true,\n          isVisible: false,\n          forceVisible: false,\n          track: {},\n          scrollbar: {}\n        },\n        y: {\n          scrollOffsetAttr: 'scrollTop',\n          sizeAttr: 'height',\n          scrollSizeAttr: 'scrollHeight',\n          offsetSizeAttr: 'offsetHeight',\n          offsetAttr: 'top',\n          overflowAttr: 'overflowY',\n          dragOffset: 0,\n          isOverflowing: true,\n          isVisible: false,\n          forceVisible: false,\n          track: {},\n          scrollbar: {}\n        }\n      };\n      this.removePreventClickId = null; // Don't re-instantiate over an existing one\n\n      if (SimpleBar.instances.has(this.el)) {\n        return;\n      }\n\n      this.recalculate = lodash_throttle(this.recalculate.bind(this), 64);\n      this.onMouseMove = lodash_throttle(this.onMouseMove.bind(this), 64);\n      this.hideScrollbars = lodash_debounce(this.hideScrollbars.bind(this), this.options.timeout);\n      this.onWindowResize = lodash_debounce(this.onWindowResize.bind(this), 64, {\n        leading: true\n      });\n      SimpleBar.getRtlHelpers = lodash_memoize(SimpleBar.getRtlHelpers);\n      this.init();\n    }\n    /**\n     * Static properties\n     */\n\n    /**\n     * Helper to fix browsers inconsistency on RTL:\n     *  - Firefox inverts the scrollbar initial position\n     *  - IE11 inverts both scrollbar position and scrolling offset\n     * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n     */\n\n\n    SimpleBar.getRtlHelpers = function getRtlHelpers() {\n      var dummyDiv = document.createElement('div');\n      dummyDiv.innerHTML = '<div class=\"hs-dummy-scrollbar-size\"><div style=\"height: 200%; width: 200%; margin: 10px 0;\"></div></div>';\n      var scrollbarDummyEl = dummyDiv.firstElementChild;\n      document.body.appendChild(scrollbarDummyEl);\n      var dummyContainerChild = scrollbarDummyEl.firstElementChild;\n      scrollbarDummyEl.scrollLeft = 0;\n      var dummyContainerOffset = SimpleBar.getOffset(scrollbarDummyEl);\n      var dummyContainerChildOffset = SimpleBar.getOffset(dummyContainerChild);\n      scrollbarDummyEl.scrollLeft = 999;\n      var dummyContainerScrollOffsetAfterScroll = SimpleBar.getOffset(dummyContainerChild);\n      return {\n        // determines if the scrolling is responding with negative values\n        isRtlScrollingInverted: dummyContainerOffset.left !== dummyContainerChildOffset.left && dummyContainerChildOffset.left - dummyContainerScrollOffsetAfterScroll.left !== 0,\n        // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n        isRtlScrollbarInverted: dummyContainerOffset.left !== dummyContainerChildOffset.left\n      };\n    };\n\n    SimpleBar.getOffset = function getOffset(el) {\n      var rect = el.getBoundingClientRect();\n      var elDocument = getElementDocument(el);\n      var elWindow = getElementWindow(el);\n      return {\n        top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n        left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)\n      };\n    };\n\n    var _proto = SimpleBar.prototype;\n\n    _proto.init = function init() {\n      // Save a reference to the instance, so we know this DOM node has already been instancied\n      SimpleBar.instances.set(this.el, this); // We stop here on server-side\n\n      if (canUseDom) {\n        this.initDOM();\n        this.scrollbarWidth = this.getScrollbarWidth();\n        this.recalculate();\n        this.initListeners();\n      }\n    };\n\n    _proto.initDOM = function initDOM() {\n      var _this2 = this;\n\n      var elDocument = getElementDocument(this.el); // make sure this element doesn't have the elements yet\n\n      if (Array.prototype.filter.call(this.el.children, function (child) {\n        return child.classList.contains(_this2.classNames.wrapper);\n      }).length) {\n        // assume that element has his DOM already initiated\n        this.wrapperEl = this.el.querySelector(\".\" + this.classNames.wrapper);\n        this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector(\".\" + this.classNames.contentWrapper);\n        this.contentEl = this.options.contentNode || this.el.querySelector(\".\" + this.classNames.contentEl);\n        this.offsetEl = this.el.querySelector(\".\" + this.classNames.offset);\n        this.maskEl = this.el.querySelector(\".\" + this.classNames.mask);\n        this.placeholderEl = this.findChild(this.wrapperEl, \".\" + this.classNames.placeholder);\n        this.heightAutoObserverWrapperEl = this.el.querySelector(\".\" + this.classNames.heightAutoObserverWrapperEl);\n        this.heightAutoObserverEl = this.el.querySelector(\".\" + this.classNames.heightAutoObserverEl);\n        this.axis.x.track.el = this.findChild(this.el, \".\" + this.classNames.track + \".\" + this.classNames.horizontal);\n        this.axis.y.track.el = this.findChild(this.el, \".\" + this.classNames.track + \".\" + this.classNames.vertical);\n      } else {\n        // Prepare DOM\n        this.wrapperEl = document.createElement('div');\n        this.contentWrapperEl = document.createElement('div');\n        this.offsetEl = document.createElement('div');\n        this.maskEl = document.createElement('div');\n        this.contentEl = document.createElement('div');\n        this.placeholderEl = document.createElement('div');\n        this.heightAutoObserverWrapperEl = document.createElement('div');\n        this.heightAutoObserverEl = document.createElement('div');\n        this.wrapperEl.classList.add(this.classNames.wrapper);\n        this.contentWrapperEl.classList.add(this.classNames.contentWrapper);\n        this.offsetEl.classList.add(this.classNames.offset);\n        this.maskEl.classList.add(this.classNames.mask);\n        this.contentEl.classList.add(this.classNames.contentEl);\n        this.placeholderEl.classList.add(this.classNames.placeholder);\n        this.heightAutoObserverWrapperEl.classList.add(this.classNames.heightAutoObserverWrapperEl);\n        this.heightAutoObserverEl.classList.add(this.classNames.heightAutoObserverEl);\n\n        while (this.el.firstChild) {\n          this.contentEl.appendChild(this.el.firstChild);\n        }\n\n        this.contentWrapperEl.appendChild(this.contentEl);\n        this.offsetEl.appendChild(this.contentWrapperEl);\n        this.maskEl.appendChild(this.offsetEl);\n        this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n        this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n        this.wrapperEl.appendChild(this.maskEl);\n        this.wrapperEl.appendChild(this.placeholderEl);\n        this.el.appendChild(this.wrapperEl);\n      }\n\n      if (!this.axis.x.track.el || !this.axis.y.track.el) {\n        var track = document.createElement('div');\n        var scrollbar = document.createElement('div');\n        track.classList.add(this.classNames.track);\n        scrollbar.classList.add(this.classNames.scrollbar);\n        track.appendChild(scrollbar);\n        this.axis.x.track.el = track.cloneNode(true);\n        this.axis.x.track.el.classList.add(this.classNames.horizontal);\n        this.axis.y.track.el = track.cloneNode(true);\n        this.axis.y.track.el.classList.add(this.classNames.vertical);\n        this.el.appendChild(this.axis.x.track.el);\n        this.el.appendChild(this.axis.y.track.el);\n      }\n\n      this.axis.x.scrollbar.el = this.axis.x.track.el.querySelector(\".\" + this.classNames.scrollbar);\n      this.axis.y.scrollbar.el = this.axis.y.track.el.querySelector(\".\" + this.classNames.scrollbar);\n\n      if (!this.options.autoHide) {\n        this.axis.x.scrollbar.el.classList.add(this.classNames.visible);\n        this.axis.y.scrollbar.el.classList.add(this.classNames.visible);\n      }\n\n      this.el.setAttribute('data-simplebar', 'init');\n    };\n\n    _proto.initListeners = function initListeners() {\n      var _this3 = this;\n\n      var elWindow = getElementWindow(this.el); // Event listeners\n\n      if (this.options.autoHide) {\n        this.el.addEventListener('mouseenter', this.onMouseEnter);\n      }\n\n      ['mousedown', 'click', 'dblclick'].forEach(function (e) {\n        _this3.el.addEventListener(e, _this3.onPointerEvent, true);\n      });\n      ['touchstart', 'touchend', 'touchmove'].forEach(function (e) {\n        _this3.el.addEventListener(e, _this3.onPointerEvent, {\n          capture: true,\n          passive: true\n        });\n      });\n      this.el.addEventListener('mousemove', this.onMouseMove);\n      this.el.addEventListener('mouseleave', this.onMouseLeave);\n      this.contentWrapperEl.addEventListener('scroll', this.onScroll); // Browser zoom triggers a window resize\n\n      elWindow.addEventListener('resize', this.onWindowResize); // Hack for https://github.com/WICG/ResizeObserver/issues/38\n\n      var resizeObserverStarted = false;\n      var resizeObserver = elWindow.ResizeObserver || index;\n      this.resizeObserver = new resizeObserver(function () {\n        if (!resizeObserverStarted) return;\n\n        _this3.recalculate();\n      });\n      this.resizeObserver.observe(this.el);\n      this.resizeObserver.observe(this.contentEl);\n      elWindow.requestAnimationFrame(function () {\n        resizeObserverStarted = true;\n      }); // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n\n      this.mutationObserver = new elWindow.MutationObserver(this.recalculate);\n      this.mutationObserver.observe(this.contentEl, {\n        childList: true,\n        subtree: true,\n        characterData: true\n      });\n    };\n\n    _proto.recalculate = function recalculate() {\n      var elWindow = getElementWindow(this.el);\n      this.elStyles = elWindow.getComputedStyle(this.el);\n      this.isRtl = this.elStyles.direction === 'rtl';\n      var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n      var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1;\n      var contentElOffsetWidth = this.contentEl.offsetWidth;\n      var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n      var elOverflowX = this.elStyles.overflowX;\n      var elOverflowY = this.elStyles.overflowY;\n      this.contentEl.style.padding = this.elStyles.paddingTop + \" \" + this.elStyles.paddingRight + \" \" + this.elStyles.paddingBottom + \" \" + this.elStyles.paddingLeft;\n      this.wrapperEl.style.margin = \"-\" + this.elStyles.paddingTop + \" -\" + this.elStyles.paddingRight + \" -\" + this.elStyles.paddingBottom + \" -\" + this.elStyles.paddingLeft;\n      var contentElScrollHeight = this.contentEl.scrollHeight;\n      var contentElScrollWidth = this.contentEl.scrollWidth;\n      this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%'; // Determine placeholder size\n\n      this.placeholderEl.style.width = isWidthAuto ? contentElOffsetWidth + \"px\" : 'auto';\n      this.placeholderEl.style.height = contentElScrollHeight + \"px\";\n      var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n      this.axis.x.isOverflowing = contentElScrollWidth > contentElOffsetWidth;\n      this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight; // Set isOverflowing to false if user explicitely set hidden overflow\n\n      this.axis.x.isOverflowing = elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;\n      this.axis.y.isOverflowing = elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;\n      this.axis.x.forceVisible = this.options.forceVisible === 'x' || this.options.forceVisible === true;\n      this.axis.y.forceVisible = this.options.forceVisible === 'y' || this.options.forceVisible === true;\n      this.hideNativeScrollbar(); // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n\n      var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;\n      var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;\n      this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n      this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;\n      this.axis.x.scrollbar.size = this.getScrollbarSize('x');\n      this.axis.y.scrollbar.size = this.getScrollbarSize('y');\n      this.axis.x.scrollbar.el.style.width = this.axis.x.scrollbar.size + \"px\";\n      this.axis.y.scrollbar.el.style.height = this.axis.y.scrollbar.size + \"px\";\n      this.positionScrollbar('x');\n      this.positionScrollbar('y');\n      this.toggleTrackVisibility('x');\n      this.toggleTrackVisibility('y');\n    }\n    /**\n     * Calculate scrollbar size\n     */\n    ;\n\n    _proto.getScrollbarSize = function getScrollbarSize(axis) {\n      if (axis === void 0) {\n        axis = 'y';\n      }\n\n      if (!this.axis[axis].isOverflowing) {\n        return 0;\n      }\n\n      var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n      var trackSize = this.axis[axis].track.el[this.axis[axis].offsetSizeAttr];\n      var scrollbarSize;\n      var scrollbarRatio = trackSize / contentSize; // Calculate new height/position of drag handle.\n\n      scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);\n\n      if (this.options.scrollbarMaxSize) {\n        scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n      }\n\n      return scrollbarSize;\n    };\n\n    _proto.positionScrollbar = function positionScrollbar(axis) {\n      if (axis === void 0) {\n        axis = 'y';\n      }\n\n      if (!this.axis[axis].isOverflowing) {\n        return;\n      }\n\n      var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n      var trackSize = this.axis[axis].track.el[this.axis[axis].offsetSizeAttr];\n      var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n      var scrollbar = this.axis[axis].scrollbar;\n      var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n      scrollOffset = axis === 'x' && this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollingInverted ? -scrollOffset : scrollOffset;\n      var scrollPourcent = scrollOffset / (contentSize - hostSize);\n      var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n      handleOffset = axis === 'x' && this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollbarInverted ? handleOffset + (trackSize - scrollbar.size) : handleOffset;\n      scrollbar.el.style.transform = axis === 'x' ? \"translate3d(\" + handleOffset + \"px, 0, 0)\" : \"translate3d(0, \" + handleOffset + \"px, 0)\";\n    };\n\n    _proto.toggleTrackVisibility = function toggleTrackVisibility(axis) {\n      if (axis === void 0) {\n        axis = 'y';\n      }\n\n      var track = this.axis[axis].track.el;\n      var scrollbar = this.axis[axis].scrollbar.el;\n\n      if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n        track.style.visibility = 'visible';\n        this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';\n      } else {\n        track.style.visibility = 'hidden';\n        this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';\n      } // Even if forceVisible is enabled, scrollbar itself should be hidden\n\n\n      if (this.axis[axis].isOverflowing) {\n        scrollbar.style.display = 'block';\n      } else {\n        scrollbar.style.display = 'none';\n      }\n    };\n\n    _proto.hideNativeScrollbar = function hideNativeScrollbar() {\n      this.offsetEl.style[this.isRtl ? 'left' : 'right'] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? \"-\" + this.scrollbarWidth + \"px\" : 0;\n      this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? \"-\" + this.scrollbarWidth + \"px\" : 0;\n    }\n    /**\n     * On scroll event handling\n     */\n    ;\n\n    _proto.onMouseMoveForAxis = function onMouseMoveForAxis(axis) {\n      if (axis === void 0) {\n        axis = 'y';\n      }\n\n      this.axis[axis].track.rect = this.axis[axis].track.el.getBoundingClientRect();\n      this.axis[axis].scrollbar.rect = this.axis[axis].scrollbar.el.getBoundingClientRect();\n      var isWithinScrollbarBoundsX = this.isWithinBounds(this.axis[axis].scrollbar.rect);\n\n      if (isWithinScrollbarBoundsX) {\n        this.axis[axis].scrollbar.el.classList.add(this.classNames.hover);\n      } else {\n        this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);\n      }\n\n      if (this.isWithinBounds(this.axis[axis].track.rect)) {\n        this.showScrollbar(axis);\n        this.axis[axis].track.el.classList.add(this.classNames.hover);\n      } else {\n        this.axis[axis].track.el.classList.remove(this.classNames.hover);\n      }\n    };\n\n    _proto.onMouseLeaveForAxis = function onMouseLeaveForAxis(axis) {\n      if (axis === void 0) {\n        axis = 'y';\n      }\n\n      this.axis[axis].track.el.classList.remove(this.classNames.hover);\n      this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);\n    };\n    /**\n     * Show scrollbar\n     */\n\n\n    _proto.showScrollbar = function showScrollbar(axis) {\n      if (axis === void 0) {\n        axis = 'y';\n      }\n\n      var scrollbar = this.axis[axis].scrollbar.el;\n\n      if (!this.axis[axis].isVisible) {\n        scrollbar.classList.add(this.classNames.visible);\n        this.axis[axis].isVisible = true;\n      }\n\n      if (this.options.autoHide) {\n        this.hideScrollbars();\n      }\n    }\n    /**\n     * Hide Scrollbar\n     */\n    ;\n    /**\n     * on scrollbar handle drag movement starts\n     */\n\n\n    _proto.onDragStart = function onDragStart(e, axis) {\n      if (axis === void 0) {\n        axis = 'y';\n      }\n\n      var elDocument = getElementDocument(this.el);\n      var elWindow = getElementWindow(this.el);\n      var scrollbar = this.axis[axis].scrollbar; // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n\n      var eventOffset = axis === 'y' ? e.pageY : e.pageX;\n      this.axis[axis].dragOffset = eventOffset - scrollbar.rect[this.axis[axis].offsetAttr];\n      this.draggedAxis = axis;\n      this.el.classList.add(this.classNames.dragging);\n      elDocument.addEventListener('mousemove', this.drag, true);\n      elDocument.addEventListener('mouseup', this.onEndDrag, true);\n\n      if (this.removePreventClickId === null) {\n        elDocument.addEventListener('click', this.preventClick, true);\n        elDocument.addEventListener('dblclick', this.preventClick, true);\n      } else {\n        elWindow.clearTimeout(this.removePreventClickId);\n        this.removePreventClickId = null;\n      }\n    }\n    /**\n     * Drag scrollbar handle\n     */\n    ;\n\n    _proto.onTrackClick = function onTrackClick(e, axis) {\n      var _this4 = this;\n\n      if (axis === void 0) {\n        axis = 'y';\n      }\n\n      if (!this.options.clickOnTrack) return;\n      var elWindow = getElementWindow(this.el);\n      this.axis[axis].scrollbar.rect = this.axis[axis].scrollbar.el.getBoundingClientRect();\n      var scrollbar = this.axis[axis].scrollbar;\n      var scrollbarOffset = scrollbar.rect[this.axis[axis].offsetAttr];\n      var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n      var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n      var t = axis === 'y' ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;\n      var dir = t < 0 ? -1 : 1;\n      var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n      var speed = 40;\n\n      var scrollTo = function scrollTo() {\n        if (dir === -1) {\n          if (scrolled > scrollSize) {\n            var _this4$contentWrapper;\n\n            scrolled -= speed;\n\n            _this4.contentWrapperEl.scrollTo((_this4$contentWrapper = {}, _this4$contentWrapper[_this4.axis[axis].offsetAttr] = scrolled, _this4$contentWrapper));\n\n            elWindow.requestAnimationFrame(scrollTo);\n          }\n        } else {\n          if (scrolled < scrollSize) {\n            var _this4$contentWrapper2;\n\n            scrolled += speed;\n\n            _this4.contentWrapperEl.scrollTo((_this4$contentWrapper2 = {}, _this4$contentWrapper2[_this4.axis[axis].offsetAttr] = scrolled, _this4$contentWrapper2));\n\n            elWindow.requestAnimationFrame(scrollTo);\n          }\n        }\n      };\n\n      scrollTo();\n    }\n    /**\n     * Getter for content element\n     */\n    ;\n\n    _proto.getContentElement = function getContentElement() {\n      return this.contentEl;\n    }\n    /**\n     * Getter for original scrolling element\n     */\n    ;\n\n    _proto.getScrollElement = function getScrollElement() {\n      return this.contentWrapperEl;\n    };\n\n    _proto.getScrollbarWidth = function getScrollbarWidth() {\n      // Try/catch for FF 56 throwing on undefined computedStyles\n      try {\n        // Detect browsers supporting CSS scrollbar styling and do not calculate\n        if (getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar').display === 'none' || 'scrollbarWidth' in document.documentElement.style || '-ms-overflow-style' in document.documentElement.style) {\n          return 0;\n        } else {\n          return scrollbarWidth();\n        }\n      } catch (e) {\n        return scrollbarWidth();\n      }\n    };\n\n    _proto.removeListeners = function removeListeners() {\n      var _this5 = this;\n\n      var elWindow = getElementWindow(this.el); // Event listeners\n\n      if (this.options.autoHide) {\n        this.el.removeEventListener('mouseenter', this.onMouseEnter);\n      }\n\n      ['mousedown', 'click', 'dblclick'].forEach(function (e) {\n        _this5.el.removeEventListener(e, _this5.onPointerEvent, true);\n      });\n      ['touchstart', 'touchend', 'touchmove'].forEach(function (e) {\n        _this5.el.removeEventListener(e, _this5.onPointerEvent, {\n          capture: true,\n          passive: true\n        });\n      });\n      this.el.removeEventListener('mousemove', this.onMouseMove);\n      this.el.removeEventListener('mouseleave', this.onMouseLeave);\n      this.contentWrapperEl.removeEventListener('scroll', this.onScroll);\n      elWindow.removeEventListener('resize', this.onWindowResize);\n      this.mutationObserver.disconnect();\n      this.resizeObserver.disconnect(); // Cancel all debounced functions\n\n      this.recalculate.cancel();\n      this.onMouseMove.cancel();\n      this.hideScrollbars.cancel();\n      this.onWindowResize.cancel();\n    }\n    /**\n     * UnMount mutation observer and delete SimpleBar instance from DOM element\n     */\n    ;\n\n    _proto.unMount = function unMount() {\n      this.removeListeners();\n      SimpleBar.instances[\"delete\"](this.el);\n    }\n    /**\n     * Check if mouse is within bounds\n     */\n    ;\n\n    _proto.isWithinBounds = function isWithinBounds(bbox) {\n      return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;\n    }\n    /**\n     * Find element children matches query\n     */\n    ;\n\n    _proto.findChild = function findChild(el, query) {\n      var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;\n      return Array.prototype.filter.call(el.children, function (child) {\n        return matches.call(child, query);\n      })[0];\n    };\n\n    return SimpleBar;\n  }();\n\n  SimpleBar.defaultOptions = {\n    autoHide: true,\n    forceVisible: false,\n    clickOnTrack: true,\n    classNames: {\n      contentEl: 'simplebar-content',\n      contentWrapper: 'simplebar-content-wrapper',\n      offset: 'simplebar-offset',\n      mask: 'simplebar-mask',\n      wrapper: 'simplebar-wrapper',\n      placeholder: 'simplebar-placeholder',\n      scrollbar: 'simplebar-scrollbar',\n      track: 'simplebar-track',\n      heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',\n      heightAutoObserverEl: 'simplebar-height-auto-observer',\n      visible: 'simplebar-visible',\n      horizontal: 'simplebar-horizontal',\n      vertical: 'simplebar-vertical',\n      hover: 'simplebar-hover',\n      dragging: 'simplebar-dragging'\n    },\n    scrollbarMinSize: 25,\n    scrollbarMaxSize: 0,\n    timeout: 1000\n  };\n  SimpleBar.instances = new WeakMap();\n\n  SimpleBar.initDOMLoadedElements = function () {\n    document.removeEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n    window.removeEventListener('load', this.initDOMLoadedElements);\n    Array.prototype.forEach.call(document.querySelectorAll('[data-simplebar]:not([data-simplebar=\"init\"])'), function (el) {\n      if (!SimpleBar.instances.has(el)) new SimpleBar(el, getOptions(el.attributes));\n    });\n  };\n\n  SimpleBar.removeObserver = function () {\n    this.globalObserver.disconnect();\n  };\n\n  SimpleBar.initHtmlApi = function () {\n    this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this); // MutationObserver is IE11+\n\n    if (typeof MutationObserver !== 'undefined') {\n      // Mutation observer to observe dynamically added elements\n      this.globalObserver = new MutationObserver(SimpleBar.handleMutations);\n      this.globalObserver.observe(document, {\n        childList: true,\n        subtree: true\n      });\n    } // Taken from jQuery `ready` function\n    // Instantiate elements already present on the page\n\n\n    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {\n      // Handle it asynchronously to allow scripts the opportunity to delay init\n      window.setTimeout(this.initDOMLoadedElements);\n    } else {\n      document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n      window.addEventListener('load', this.initDOMLoadedElements);\n    }\n  };\n\n  SimpleBar.handleMutations = function (mutations) {\n    mutations.forEach(function (mutation) {\n      Array.prototype.forEach.call(mutation.addedNodes, function (addedNode) {\n        if (addedNode.nodeType === 1) {\n          if (addedNode.hasAttribute('data-simplebar')) {\n            !SimpleBar.instances.has(addedNode) && new SimpleBar(addedNode, getOptions(addedNode.attributes));\n          } else {\n            Array.prototype.forEach.call(addedNode.querySelectorAll('[data-simplebar]:not([data-simplebar=\"init\"])'), function (el) {\n              !SimpleBar.instances.has(el) && new SimpleBar(el, getOptions(el.attributes));\n            });\n          }\n        }\n      });\n      Array.prototype.forEach.call(mutation.removedNodes, function (removedNode) {\n        if (removedNode.nodeType === 1) {\n          if (removedNode.hasAttribute('[data-simplebar=\"init\"]')) {\n            SimpleBar.instances.has(removedNode) && SimpleBar.instances.get(removedNode).unMount();\n          } else {\n            Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar=\"init\"]'), function (el) {\n              SimpleBar.instances.has(el) && SimpleBar.instances.get(el).unMount();\n            });\n          }\n        }\n      });\n    });\n  };\n\n  SimpleBar.getOptions = getOptions;\n  /**\n   * HTML API\n   * Called only in a browser env.\n   */\n\n  if (canUseDom) {\n    SimpleBar.initHtmlApi();\n  }\n\n  return SimpleBar;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvYmFja2VuZC9qcy9zaW1wbGViYXIuanM/YjBmNCJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsInNlbGYiLCJjcmVhdGVDb21tb25qc01vZHVsZSIsImZuIiwiTyIsImNoZWNrIiwiaXQiLCJNYXRoIiwiZ2xvYmFsXzEiLCJGdW5jdGlvbiIsImZhaWxzIiwiZXhlYyIsImVycm9yIiwiZGVzY3JpcHRvcnMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImEiLCJuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiTkFTSE9STl9CVUciLCJjYWxsIiwiZiIsIlYiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsIm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yIiwiYml0bWFwIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInRvU3RyaW5nIiwiY2xhc3NvZlJhdyIsInNsaWNlIiwic3BsaXQiLCJpbmRleGVkT2JqZWN0IiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsInRvSW5kZXhlZE9iamVjdCIsImlzT2JqZWN0IiwidG9QcmltaXRpdmUiLCJpbnB1dCIsIlBSRUZFUlJFRF9TVFJJTkciLCJ2YWwiLCJ2YWx1ZU9mIiwiaGFzT3duUHJvcGVydHkiLCJoYXMiLCJrZXkiLCJkb2N1bWVudCQxIiwiZG9jdW1lbnQiLCJFWElTVFMiLCJjcmVhdGVFbGVtZW50IiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50IiwiaWU4RG9tRGVmaW5lIiwibmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZiQxIiwiUCIsIm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImFuT2JqZWN0IiwiU3RyaW5nIiwibmF0aXZlRGVmaW5lUHJvcGVydHkiLCJmJDIiLCJBdHRyaWJ1dGVzIiwib2JqZWN0RGVmaW5lUHJvcGVydHkiLCJoaWRlIiwib2JqZWN0Iiwic2V0R2xvYmFsIiwic2hhcmVkIiwiU0hBUkVEIiwic3RvcmUiLCJwdXNoIiwidmVyc2lvbiIsIm1vZGUiLCJjb3B5cmlnaHQiLCJmdW5jdGlvblRvU3RyaW5nIiwiV2Vha01hcCQxIiwiV2Vha01hcCIsIm5hdGl2ZVdlYWtNYXAiLCJ0ZXN0IiwiaWQiLCJwb3N0Zml4IiwicmFuZG9tIiwidWlkIiwia2V5cyIsInNoYXJlZEtleSIsImhpZGRlbktleXMiLCJXZWFrTWFwJDIiLCJzZXQiLCJoYXMkMSIsImVuZm9yY2UiLCJnZXR0ZXJGb3IiLCJUWVBFIiwic3RhdGUiLCJ0eXBlIiwid21nZXQiLCJ3bWhhcyIsIndtc2V0IiwibWV0YWRhdGEiLCJTVEFURSIsImludGVybmFsU3RhdGUiLCJyZWRlZmluZSIsImdldEludGVybmFsU3RhdGUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsIlRFTVBMQVRFIiwib3B0aW9ucyIsInVuc2FmZSIsInNpbXBsZSIsIm5vVGFyZ2V0R2V0Iiwic291cmNlIiwiam9pbiIsInByb3RvdHlwZSIsInBhdGgiLCJhRnVuY3Rpb24iLCJ2YXJpYWJsZSIsImdldEJ1aWx0SW4iLCJuYW1lc3BhY2UiLCJtZXRob2QiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjZWlsIiwiZmxvb3IiLCJ0b0ludGVnZXIiLCJhcmd1bWVudCIsImlzTmFOIiwibWluIiwidG9MZW5ndGgiLCJtYXgiLCJtaW4kMSIsInRvQWJzb2x1dGVJbmRleCIsImluZGV4IiwiaW50ZWdlciIsImNyZWF0ZU1ldGhvZCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJlbCIsImZyb21JbmRleCIsImFycmF5SW5jbHVkZXMiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJvYmplY3RLZXlzSW50ZXJuYWwiLCJuYW1lcyIsImkiLCJyZXN1bHQiLCJlbnVtQnVnS2V5cyIsImhpZGRlbktleXMkMSIsImNvbmNhdCIsImYkMyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZiQ0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwib2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzIiwib3duS2V5cyIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMiLCJ0YXJnZXQiLCJyZXBsYWNlbWVudCIsImlzRm9yY2VkIiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsInN0cmluZyIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImlzRm9yY2VkXzEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSIsIl9leHBvcnQiLCJUQVJHRVQiLCJHTE9CQUwiLCJTVEFUSUMiLCJzdGF0IiwiRk9SQ0VEIiwidGFyZ2V0UHJvcGVydHkiLCJzb3VyY2VQcm9wZXJ0eSIsImZvcmNlZCIsInNoYW0iLCJhRnVuY3Rpb24kMSIsImJpbmRDb250ZXh0IiwidGhhdCIsImIiLCJjIiwiYXBwbHkiLCJ0b09iamVjdCIsImlzQXJyYXkiLCJBcnJheSIsImFyZyIsIm5hdGl2ZVN5bWJvbCIsIlN5bWJvbCIsIlN5bWJvbCQxIiwic3RvcmUkMSIsIndlbGxLbm93blN5bWJvbCIsIm5hbWUiLCJTUEVDSUVTIiwiYXJyYXlTcGVjaWVzQ3JlYXRlIiwib3JpZ2luYWxBcnJheSIsIkMiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZU1ldGhvZCQxIiwiSVNfTUFQIiwiSVNfRklMVEVSIiwiSVNfU09NRSIsIklTX0VWRVJZIiwiSVNfRklORF9JTkRFWCIsIk5PX0hPTEVTIiwiY2FsbGJhY2tmbiIsInNwZWNpZmljQ3JlYXRlIiwiYm91bmRGdW5jdGlvbiIsImNyZWF0ZSIsImFycmF5SXRlcmF0aW9uIiwiZm9yRWFjaCIsIm1hcCIsImZpbHRlciIsInNvbWUiLCJldmVyeSIsImZpbmQiLCJmaW5kSW5kZXgiLCJzbG9wcHlBcnJheU1ldGhvZCIsIk1FVEhPRF9OQU1FIiwiJGZvckVhY2giLCJhcnJheUZvckVhY2giLCJwcm90byIsImRvbUl0ZXJhYmxlcyIsIkNTU1J1bGVMaXN0IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsIkNTU1ZhbHVlTGlzdCIsIkNsaWVudFJlY3RMaXN0IiwiRE9NUmVjdExpc3QiLCJET01TdHJpbmdMaXN0IiwiRE9NVG9rZW5MaXN0IiwiRGF0YVRyYW5zZmVySXRlbUxpc3QiLCJGaWxlTGlzdCIsIkhUTUxBbGxDb2xsZWN0aW9uIiwiSFRNTENvbGxlY3Rpb24iLCJIVE1MRm9ybUVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIk1lZGlhTGlzdCIsIk1pbWVUeXBlQXJyYXkiLCJOYW1lZE5vZGVNYXAiLCJOb2RlTGlzdCIsIlBhaW50UmVxdWVzdExpc3QiLCJQbHVnaW4iLCJQbHVnaW5BcnJheSIsIlNWR0xlbmd0aExpc3QiLCJTVkdOdW1iZXJMaXN0IiwiU1ZHUGF0aFNlZ0xpc3QiLCJTVkdQb2ludExpc3QiLCJTVkdTdHJpbmdMaXN0IiwiU1ZHVHJhbnNmb3JtTGlzdCIsIlNvdXJjZUJ1ZmZlckxpc3QiLCJTdHlsZVNoZWV0TGlzdCIsIlRleHRUcmFja0N1ZUxpc3QiLCJUZXh0VHJhY2tMaXN0IiwiVG91Y2hMaXN0IiwiQ09MTEVDVElPTl9OQU1FIiwiQ29sbGVjdGlvbiIsIkNvbGxlY3Rpb25Qcm90b3R5cGUiLCJjYW5Vc2VET00iLCJjYW5Vc2VEb20iLCJTUEVDSUVTJDEiLCJhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0IiwiYXJyYXkiLCJmb28iLCJCb29sZWFuIiwiJGZpbHRlciIsIm9iamVjdEtleXMiLCJvYmplY3REZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJodG1sIiwiSUVfUFJPVE8iLCJQUk9UT1RZUEUiLCJFbXB0eSIsImNyZWF0ZURpY3QiLCJpZnJhbWUiLCJsdCIsInNjcmlwdCIsImd0IiwianMiLCJpZnJhbWVEb2N1bWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwic3JjIiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwiRiIsIm9iamVjdENyZWF0ZSIsIlVOU0NPUEFCTEVTIiwiQXJyYXlQcm90b3R5cGUiLCJhZGRUb1Vuc2NvcGFibGVzIiwiaXRlcmF0b3JzIiwiY29ycmVjdFByb3RvdHlwZUdldHRlciIsImdldFByb3RvdHlwZU9mIiwiSUVfUFJPVE8kMSIsIk9iamVjdFByb3RvdHlwZSIsIm9iamVjdEdldFByb3RvdHlwZU9mIiwiSVRFUkFUT1IiLCJCVUdHWV9TQUZBUklfSVRFUkFUT1JTIiwicmV0dXJuVGhpcyIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlIiwiYXJyYXlJdGVyYXRvciIsIml0ZXJhdG9yc0NvcmUiLCJUT19TVFJJTkdfVEFHIiwic2V0VG9TdHJpbmdUYWciLCJUQUciLCJJdGVyYXRvclByb3RvdHlwZSQxIiwicmV0dXJuVGhpcyQxIiwiY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciIsIkl0ZXJhdG9yQ29uc3RydWN0b3IiLCJOQU1FIiwibmV4dCIsImFQb3NzaWJsZVByb3RvdHlwZSIsIm9iamVjdFNldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJDT1JSRUNUX1NFVFRFUiIsInNldHRlciIsIl9fcHJvdG9fXyIsIkl0ZXJhdG9yUHJvdG90eXBlJDIiLCJCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEiLCJJVEVSQVRPUiQxIiwiS0VZUyIsIlZBTFVFUyIsIkVOVFJJRVMiLCJyZXR1cm5UaGlzJDIiLCJkZWZpbmVJdGVyYXRvciIsIkl0ZXJhYmxlIiwiREVGQVVMVCIsIklTX1NFVCIsImdldEl0ZXJhdGlvbk1ldGhvZCIsIktJTkQiLCJkZWZhdWx0SXRlcmF0b3IiLCJJdGVyYWJsZVByb3RvdHlwZSIsInZhbHVlcyIsImVudHJpZXMiLCJJTkNPUlJFQ1RfVkFMVUVTX05BTUUiLCJuYXRpdmVJdGVyYXRvciIsImFueU5hdGl2ZUl0ZXJhdG9yIiwiQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlIiwibWV0aG9kcyIsIktFWSIsIkFSUkFZX0lURVJBVE9SIiwic2V0SW50ZXJuYWxTdGF0ZSIsImVzX2FycmF5X2l0ZXJhdG9yIiwiaXRlcmF0ZWQiLCJraW5kIiwiZG9uZSIsIkFyZ3VtZW50cyIsIm5hdGl2ZUFzc2lnbiIsImFzc2lnbiIsIm9iamVjdEFzc2lnbiIsIkEiLCJCIiwic3ltYm9sIiwiYWxwaGFiZXQiLCJjaHIiLCJUIiwiYXJndW1lbnRzTGVuZ3RoIiwiUyIsImoiLCJUT19TVFJJTkdfVEFHJDEiLCJDT1JSRUNUX0FSR1VNRU5UUyIsInRyeUdldCIsImNsYXNzb2YiLCJ0YWciLCJjYWxsZWUiLCJUT19TVFJJTkdfVEFHJDIiLCJvYmplY3RUb1N0cmluZyIsIk9iamVjdFByb3RvdHlwZSQxIiwid2hpdGVzcGFjZXMiLCJ3aGl0ZXNwYWNlIiwibHRyaW0iLCJSZWdFeHAiLCJydHJpbSIsImNyZWF0ZU1ldGhvZCQyIiwic3RyaW5nVHJpbSIsInN0YXJ0IiwiZW5kIiwidHJpbSIsIm5hdGl2ZVBhcnNlSW50IiwicGFyc2VJbnQiLCJoZXgiLCJfcGFyc2VJbnQiLCJyYWRpeCIsImNyZWF0ZU1ldGhvZCQzIiwiQ09OVkVSVF9UT19TVFJJTkciLCJwb3MiLCJwb3NpdGlvbiIsInNpemUiLCJmaXJzdCIsInNlY29uZCIsImNoYXJDb2RlQXQiLCJjaGFyQXQiLCJzdHJpbmdNdWx0aWJ5dGUiLCJjb2RlQXQiLCJTVFJJTkdfSVRFUkFUT1IiLCJzZXRJbnRlcm5hbFN0YXRlJDEiLCJnZXRJbnRlcm5hbFN0YXRlJDEiLCJwb2ludCIsInJlZGVmaW5lQWxsIiwiZnJlZXppbmciLCJpc0V4dGVuc2libGUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImludGVybmFsTWV0YWRhdGEiLCJNRVRBREFUQSIsInNldE1ldGFkYXRhIiwib2JqZWN0SUQiLCJ3ZWFrRGF0YSIsImZhc3RLZXkiLCJnZXRXZWFrRGF0YSIsIm9uRnJlZXplIiwibWV0YSIsIlJFUVVJUkVEIiwiaW50ZXJuYWxNZXRhZGF0YV8xIiwiaW50ZXJuYWxNZXRhZGF0YV8yIiwiaW50ZXJuYWxNZXRhZGF0YV8zIiwiaW50ZXJuYWxNZXRhZGF0YV80IiwiSVRFUkFUT1IkMiIsIkFycmF5UHJvdG90eXBlJDEiLCJpc0FycmF5SXRlcmF0b3JNZXRob2QiLCJJVEVSQVRPUiQzIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nIiwiaXRlcmF0b3IiLCJyZXR1cm5NZXRob2QiLCJpdGVyYXRlXzEiLCJSZXN1bHQiLCJzdG9wcGVkIiwiaXRlcmF0ZSIsIml0ZXJhYmxlIiwiQVNfRU5UUklFUyIsIklTX0lURVJBVE9SIiwiaXRlckZuIiwic3RlcCIsInN0b3AiLCJhbkluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJJVEVSQVRPUiQ0IiwiU0FGRV9DTE9TSU5HIiwiY2FsbGVkIiwiaXRlcmF0b3JXaXRoUmV0dXJuIiwiZnJvbSIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiIsIlNLSVBfQ0xPU0lORyIsIklURVJBVElPTl9TVVBQT1JUIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJkdW1teSIsIldyYXBwZXIiLCJOZXdUYXJnZXQiLCJOZXdUYXJnZXRQcm90b3R5cGUiLCJjb2xsZWN0aW9uIiwiQ09OU1RSVUNUT1JfTkFNRSIsIndyYXBwZXIiLCJjb21tb24iLCJJU19XRUFLIiwiTmF0aXZlQ29uc3RydWN0b3IiLCJOYXRpdmVQcm90b3R5cGUiLCJBRERFUiIsImV4cG9ydGVkIiwiZml4TWV0aG9kIiwibmF0aXZlTWV0aG9kIiwiYWRkIiwiZ2V0Q29uc3RydWN0b3IiLCJpbnN0YW5jZSIsIkhBU05UX0NIQUlOSU5HIiwiVEhST1dTX09OX1BSSU1JVElWRVMiLCJBQ0NFUFRfSVRFUkFCTEVTIiwiQlVHR1lfWkVSTyIsIiRpbnN0YW5jZSIsImNsZWFyIiwic2V0U3Ryb25nIiwic2V0SW50ZXJuYWxTdGF0ZSQyIiwiaW50ZXJuYWxTdGF0ZUdldHRlckZvciIsImlkJDEiLCJ1bmNhdWdodEZyb3plblN0b3JlIiwiZnJvemVuIiwiVW5jYXVnaHRGcm96ZW5TdG9yZSIsImZpbmRVbmNhdWdodEZyb3plbiIsImVudHJ5Iiwic3BsaWNlIiwiY29sbGVjdGlvbldlYWsiLCJlc193ZWFrTWFwIiwiZW5mb3JjZUl0ZXJuYWxTdGF0ZSIsIklTX0lFMTEiLCJBY3RpdmVYT2JqZWN0IiwiSW50ZXJuYWxXZWFrTWFwIiwiJFdlYWtNYXAiLCJXZWFrTWFwUHJvdG90eXBlIiwibmF0aXZlRGVsZXRlIiwibmF0aXZlSGFzIiwibmF0aXZlR2V0IiwibmF0aXZlU2V0IiwiSVRFUkFUT1IkNSIsIlRPX1NUUklOR19UQUckMyIsIkFycmF5VmFsdWVzIiwiQ09MTEVDVElPTl9OQU1FJDEiLCJDb2xsZWN0aW9uJDEiLCJDb2xsZWN0aW9uUHJvdG90eXBlJDEiLCJGVU5DX0VSUk9SX1RFWFQiLCJOQU4iLCJzeW1ib2xUYWciLCJyZVRyaW0iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJvYmplY3RQcm90byIsIm9iamVjdFRvU3RyaW5nJDEiLCJuYXRpdmVNYXgiLCJuYXRpdmVNaW4iLCJub3ciLCJEYXRlIiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsInRyYWlsaW5nIiwidG9OdW1iZXIiLCJpc09iamVjdCQxIiwiaW52b2tlRnVuYyIsInRpbWUiLCJhcmdzIiwidGhpc0FyZyIsImxlYWRpbmdFZGdlIiwic2V0VGltZW91dCIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJ0aHJvdHRsZSIsImlzT2JqZWN0TGlrZSIsImlzU3ltYm9sIiwib3RoZXIiLCJpc0JpbmFyeSIsImxvZGFzaF90aHJvdHRsZSIsIkZVTkNfRVJST1JfVEVYVCQxIiwiTkFOJDEiLCJzeW1ib2xUYWckMSIsInJlVHJpbSQxIiwicmVJc0JhZEhleCQxIiwicmVJc0JpbmFyeSQxIiwicmVJc09jdGFsJDEiLCJmcmVlUGFyc2VJbnQkMSIsImZyZWVHbG9iYWwkMSIsImZyZWVTZWxmJDEiLCJyb290JDEiLCJvYmplY3RQcm90byQxIiwib2JqZWN0VG9TdHJpbmckMiIsIm5hdGl2ZU1heCQxIiwibmF0aXZlTWluJDEiLCJub3ckMSIsImRlYm91bmNlJDEiLCJ0b051bWJlciQxIiwiaXNPYmplY3QkMiIsImlzT2JqZWN0TGlrZSQxIiwiaXNTeW1ib2wkMSIsImxvZGFzaF9kZWJvdW5jZSIsIkZVTkNfRVJST1JfVEVYVCQyIiwiSEFTSF9VTkRFRklORUQiLCJmdW5jVGFnIiwiZ2VuVGFnIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnJlZUdsb2JhbCQyIiwiZnJlZVNlbGYkMiIsInJvb3QkMiIsImdldFZhbHVlIiwiaXNIb3N0T2JqZWN0IiwiZSIsImFycmF5UHJvdG8iLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byQyIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJmdW5jVG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSQxIiwib2JqZWN0VG9TdHJpbmckMyIsInJlSXNOYXRpdmUiLCJNYXAkMSIsImdldE5hdGl2ZSIsIm5hdGl2ZUNyZWF0ZSIsIkhhc2giLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJMaXN0Q2FjaGUiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiIsImxhc3RJbmRleCIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIk1hcENhY2hlIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsImVxIiwiYmFzZUlzTmF0aXZlIiwiaXNPYmplY3QkMyIsImlzTWFza2VkIiwicGF0dGVybiIsImlzRnVuY3Rpb24iLCJ0b1NvdXJjZSIsImlzS2V5YWJsZSIsIm1lbW9pemUiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiY2FjaGUiLCJDYWNoZSIsImxvZGFzaF9tZW1vaXplIiwiTWFwU2hpbSIsIk1hcCIsImdldEluZGV4IiwiYXJyIiwiY2xhc3NfMSIsIl9fZW50cmllc19fIiwiY2FsbGJhY2siLCJjdHgiLCJfaSIsIl9hIiwiaXNCcm93c2VyIiwiZ2xvYmFsJDEiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJpbmQiLCJ0cmFpbGluZ1RpbWVvdXQiLCJ0aHJvdHRsZSQxIiwiZGVsYXkiLCJsZWFkaW5nQ2FsbCIsInRyYWlsaW5nQ2FsbCIsInJlc29sdmVQZW5kaW5nIiwicHJveHkiLCJ0aW1lb3V0Q2FsbGJhY2siLCJ0aW1lU3RhbXAiLCJSRUZSRVNIX0RFTEFZIiwidHJhbnNpdGlvbktleXMiLCJtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkIiwiTXV0YXRpb25PYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciIsImNvbm5lY3RlZF8iLCJtdXRhdGlvbkV2ZW50c0FkZGVkXyIsIm11dGF0aW9uc09ic2VydmVyXyIsIm9ic2VydmVyc18iLCJvblRyYW5zaXRpb25FbmRfIiwicmVmcmVzaCIsImFkZE9ic2VydmVyIiwib2JzZXJ2ZXIiLCJjb25uZWN0XyIsInJlbW92ZU9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiZGlzY29ubmVjdF8iLCJjaGFuZ2VzRGV0ZWN0ZWQiLCJ1cGRhdGVPYnNlcnZlcnNfIiwiYWN0aXZlT2JzZXJ2ZXJzIiwiZ2F0aGVyQWN0aXZlIiwiaGFzQWN0aXZlIiwiYnJvYWRjYXN0QWN0aXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsIl9iIiwicHJvcGVydHlOYW1lIiwiaXNSZWZsb3dQcm9wZXJ0eSIsImdldEluc3RhbmNlIiwiaW5zdGFuY2VfIiwiZGVmaW5lQ29uZmlndXJhYmxlIiwicHJvcHMiLCJnZXRXaW5kb3dPZiIsIm93bmVyR2xvYmFsIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiZW1wdHlSZWN0IiwiY3JlYXRlUmVjdEluaXQiLCJ0b0Zsb2F0IiwicGFyc2VGbG9hdCIsImdldEJvcmRlcnNTaXplIiwic3R5bGVzIiwicG9zaXRpb25zIiwicmVkdWNlIiwiZ2V0UGFkZGluZ3MiLCJwYWRkaW5ncyIsInBvc2l0aW9uc18xIiwiZ2V0U1ZHQ29udGVudFJlY3QiLCJiYm94IiwiZ2V0QkJveCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImhvcml6UGFkIiwibGVmdCIsInJpZ2h0IiwidmVydFBhZCIsInRvcCIsImJvdHRvbSIsImJveFNpemluZyIsInJvdW5kIiwiaXNEb2N1bWVudEVsZW1lbnQiLCJ2ZXJ0U2Nyb2xsYmFyIiwiaG9yaXpTY3JvbGxiYXIiLCJhYnMiLCJpc1NWR0dyYXBoaWNzRWxlbWVudCIsIlNWR0dyYXBoaWNzRWxlbWVudCIsIlNWR0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRDb250ZW50UmVjdCIsImNyZWF0ZVJlYWRPbmx5UmVjdCIsIngiLCJ5IiwiQ29uc3RyIiwiRE9NUmVjdFJlYWRPbmx5IiwicmVjdCIsIlJlc2l6ZU9ic2VydmF0aW9uIiwiYnJvYWRjYXN0V2lkdGgiLCJicm9hZGNhc3RIZWlnaHQiLCJjb250ZW50UmVjdF8iLCJpc0FjdGl2ZSIsImJyb2FkY2FzdFJlY3QiLCJSZXNpemVPYnNlcnZlckVudHJ5IiwicmVjdEluaXQiLCJjb250ZW50UmVjdCIsIlJlc2l6ZU9ic2VydmVyU1BJIiwiY29udHJvbGxlciIsImNhbGxiYWNrQ3R4IiwiYWN0aXZlT2JzZXJ2YXRpb25zXyIsIm9ic2VydmF0aW9uc18iLCJjYWxsYmFja18iLCJjb250cm9sbGVyXyIsImNhbGxiYWNrQ3R4XyIsIkVsZW1lbnQiLCJvYnNlcnZhdGlvbnMiLCJ1bm9ic2VydmUiLCJjbGVhckFjdGl2ZSIsIl90aGlzIiwib2JzZXJ2YXRpb24iLCJSZXNpemVPYnNlcnZlciIsImNhY2hlZFNjcm9sbGJhcldpZHRoIiwiY2FjaGVkRGV2aWNlUGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJzY3JvbGxiYXJXaWR0aCIsImJvZHkiLCJib3giLCJjbGFzc0xpc3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZU1ldGhvZCQ0IiwiSVNfUklHSFQiLCJtZW1vIiwiYXJyYXlSZWR1Y2UiLCIkcmVkdWNlIiwiZGVmaW5lUHJvcGVydHkkMSIsIkZ1bmN0aW9uUHJvdG90eXBlIiwiRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZyIsIm5hbWVSRSIsIm1hdGNoIiwicmVnZXhwRmxhZ3MiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwiZG90QWxsIiwidW5pY29kZSIsInN0aWNreSIsIm5hdGl2ZUV4ZWMiLCJuYXRpdmVSZXBsYWNlIiwicGF0Y2hlZEV4ZWMiLCJVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkciLCJyZTEiLCJyZTIiLCJOUENHX0lOQ0xVREVEIiwiUEFUQ0giLCJzdHIiLCJyZSIsInJlQ29weSIsInJlZ2V4cEV4ZWMiLCJTUEVDSUVTJDIiLCJSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyIsImdyb3VwcyIsIlNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyIsIm9yaWdpbmFsRXhlYyIsImZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljIiwiU1lNQk9MIiwiREVMRUdBVEVTX1RPX1NZTUJPTCIsIkRFTEVHQVRFU19UT19FWEVDIiwiZXhlY0NhbGxlZCIsIm5hdGl2ZVJlZ0V4cE1ldGhvZCIsInJlZ2V4cCIsImFyZzIiLCJmb3JjZVN0cmluZ01ldGhvZCIsInN0cmluZ01ldGhvZCIsInJlZ2V4TWV0aG9kIiwiY2hhckF0JDEiLCJhZHZhbmNlU3RyaW5nSW5kZXgiLCJyZWdleHBFeGVjQWJzdHJhY3QiLCJSIiwiTUFUQ0giLCJuYXRpdmVNYXRjaCIsIm1heWJlQ2FsbE5hdGl2ZSIsIm1hdGNoZXIiLCJyZXMiLCJyeCIsImZ1bGxVbmljb2RlIiwibiIsIm1hdGNoU3RyIiwibWF4JDEiLCJtaW4kMiIsImZsb29yJDEiLCJTVUJTVElUVVRJT05fU1lNQk9MUyIsIlNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEIiwibWF5YmVUb1N0cmluZyIsIlJFUExBQ0UiLCJzZWFyY2hWYWx1ZSIsInJlcGxhY2VWYWx1ZSIsInJlcGxhY2VyIiwiZnVuY3Rpb25hbFJlcGxhY2UiLCJyZXN1bHRzIiwiYWNjdW11bGF0ZWRSZXN1bHQiLCJuZXh0U291cmNlUG9zaXRpb24iLCJtYXRjaGVkIiwiY2FwdHVyZXMiLCJuYW1lZENhcHR1cmVzIiwicmVwbGFjZXJBcmdzIiwiZ2V0U3Vic3RpdHV0aW9uIiwidGFpbFBvcyIsIm0iLCJzeW1ib2xzIiwiY2giLCJjYXB0dXJlIiwiZ2V0T3B0aW9ucyIsIm9iaiIsImFjYyIsImF0dHJpYnV0ZSIsIm9wdGlvbiIsInRvVXBwZXJDYXNlIiwiZ2V0RWxlbWVudFdpbmRvdyIsImVsZW1lbnQiLCJnZXRFbGVtZW50RG9jdW1lbnQiLCJTaW1wbGVCYXIiLCJvblNjcm9sbCIsImVsV2luZG93Iiwic2Nyb2xsWFRpY2tpbmciLCJzY3JvbGxYIiwic2Nyb2xsWVRpY2tpbmciLCJzY3JvbGxZIiwiYXhpcyIsImlzT3ZlcmZsb3dpbmciLCJzaG93U2Nyb2xsYmFyIiwicG9zaXRpb25TY3JvbGxiYXIiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTW92ZSIsIm1vdXNlWCIsImNsaWVudFgiLCJtb3VzZVkiLCJjbGllbnRZIiwiZm9yY2VWaXNpYmxlIiwib25Nb3VzZU1vdmVGb3JBeGlzIiwib25Nb3VzZUxlYXZlIiwib25Nb3VzZUxlYXZlRm9yQXhpcyIsIm9uV2luZG93UmVzaXplIiwiZ2V0U2Nyb2xsYmFyV2lkdGgiLCJoaWRlTmF0aXZlU2Nyb2xsYmFyIiwiaGlkZVNjcm9sbGJhcnMiLCJ0cmFjayIsImlzV2l0aGluQm91bmRzIiwic2Nyb2xsYmFyIiwicmVtb3ZlIiwiY2xhc3NOYW1lcyIsInZpc2libGUiLCJpc1Zpc2libGUiLCJvblBvaW50ZXJFdmVudCIsImlzV2l0aGluVHJhY2tYQm91bmRzIiwiaXNXaXRoaW5UcmFja1lCb3VuZHMiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIm9uRHJhZ1N0YXJ0Iiwib25UcmFja0NsaWNrIiwiZHJhZyIsImV2ZW50T2Zmc2V0IiwiZHJhZ2dlZEF4aXMiLCJ0cmFja1NpemUiLCJzaXplQXR0ciIsImNvbnRlbnRTaXplIiwiY29udGVudFdyYXBwZXJFbCIsInNjcm9sbFNpemVBdHRyIiwiaG9zdFNpemUiLCJlbFN0eWxlcyIsInBhZ2VZIiwicGFnZVgiLCJkcmFnUG9zIiwib2Zmc2V0QXR0ciIsImRyYWdPZmZzZXQiLCJkcmFnUGVyYyIsInNjcm9sbFBvcyIsImlzUnRsIiwiZ2V0UnRsSGVscGVycyIsImlzUnRsU2Nyb2xsYmFySW52ZXJ0ZWQiLCJpc1J0bFNjcm9sbGluZ0ludmVydGVkIiwic2Nyb2xsT2Zmc2V0QXR0ciIsIm9uRW5kRHJhZyIsImVsRG9jdW1lbnQiLCJkcmFnZ2luZyIsInJlbW92ZVByZXZlbnRDbGlja0lkIiwicHJldmVudENsaWNrIiwibWluU2Nyb2xsYmFyV2lkdGgiLCJkZWZhdWx0T3B0aW9ucyIsIm9mZnNldFNpemVBdHRyIiwib3ZlcmZsb3dBdHRyIiwiaW5zdGFuY2VzIiwicmVjYWxjdWxhdGUiLCJ0aW1lb3V0IiwiaW5pdCIsImR1bW15RGl2IiwiaW5uZXJIVE1MIiwic2Nyb2xsYmFyRHVtbXlFbCIsImZpcnN0RWxlbWVudENoaWxkIiwiZHVtbXlDb250YWluZXJDaGlsZCIsInNjcm9sbExlZnQiLCJkdW1teUNvbnRhaW5lck9mZnNldCIsImdldE9mZnNldCIsImR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQiLCJkdW1teUNvbnRhaW5lclNjcm9sbE9mZnNldEFmdGVyU2Nyb2xsIiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJwYWdlWE9mZnNldCIsIl9wcm90byIsImluaXRET00iLCJpbml0TGlzdGVuZXJzIiwiX3RoaXMyIiwiY2hpbGRyZW4iLCJjaGlsZCIsImNvbnRhaW5zIiwid3JhcHBlckVsIiwicXVlcnlTZWxlY3RvciIsInNjcm9sbGFibGVOb2RlIiwiY29udGVudFdyYXBwZXIiLCJjb250ZW50RWwiLCJjb250ZW50Tm9kZSIsIm9mZnNldEVsIiwib2Zmc2V0IiwibWFza0VsIiwibWFzayIsInBsYWNlaG9sZGVyRWwiLCJmaW5kQ2hpbGQiLCJwbGFjZWhvbGRlciIsImhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbCIsImhlaWdodEF1dG9PYnNlcnZlckVsIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwiZmlyc3RDaGlsZCIsImNsb25lTm9kZSIsImF1dG9IaWRlIiwic2V0QXR0cmlidXRlIiwiX3RoaXMzIiwicGFzc2l2ZSIsInJlc2l6ZU9ic2VydmVyU3RhcnRlZCIsInJlc2l6ZU9ic2VydmVyIiwibXV0YXRpb25PYnNlcnZlciIsImRpcmVjdGlvbiIsImlzSGVpZ2h0QXV0byIsIm9mZnNldEhlaWdodCIsImlzV2lkdGhBdXRvIiwib2Zmc2V0V2lkdGgiLCJjb250ZW50RWxPZmZzZXRXaWR0aCIsImNvbnRlbnRXcmFwcGVyRWxPZmZzZXRXaWR0aCIsImVsT3ZlcmZsb3dYIiwib3ZlcmZsb3dYIiwiZWxPdmVyZmxvd1kiLCJvdmVyZmxvd1kiLCJwYWRkaW5nIiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsIm1hcmdpbiIsImNvbnRlbnRFbFNjcm9sbEhlaWdodCIsInNjcm9sbEhlaWdodCIsImNvbnRlbnRFbFNjcm9sbFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJjb250ZW50V3JhcHBlckVsT2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0Rm9yWFNjcm9sbGJhciIsIm9mZnNldEZvcllTY3JvbGxiYXIiLCJnZXRTY3JvbGxiYXJTaXplIiwidG9nZ2xlVHJhY2tWaXNpYmlsaXR5Iiwic2Nyb2xsYmFyU2l6ZSIsInNjcm9sbGJhclJhdGlvIiwic2Nyb2xsYmFyTWluU2l6ZSIsInNjcm9sbGJhck1heFNpemUiLCJzY3JvbGxPZmZzZXQiLCJzY3JvbGxQb3VyY2VudCIsImhhbmRsZU9mZnNldCIsInRyYW5zZm9ybSIsInZpc2liaWxpdHkiLCJpc1dpdGhpblNjcm9sbGJhckJvdW5kc1giLCJob3ZlciIsIl90aGlzNCIsImNsaWNrT25UcmFjayIsInNjcm9sbGJhck9mZnNldCIsInNjcm9sbGVkIiwidCIsImRpciIsInNjcm9sbFNpemUiLCJzcGVlZCIsInNjcm9sbFRvIiwiX3RoaXM0JGNvbnRlbnRXcmFwcGVyIiwiX3RoaXM0JGNvbnRlbnRXcmFwcGVyMiIsImdldENvbnRlbnRFbGVtZW50IiwiZ2V0U2Nyb2xsRWxlbWVudCIsInJlbW92ZUxpc3RlbmVycyIsIl90aGlzNSIsInVuTW91bnQiLCJxdWVyeSIsIm1hdGNoZXMiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImluaXRET01Mb2FkZWRFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJnbG9iYWxPYnNlcnZlciIsImluaXRIdG1sQXBpIiwiaGFuZGxlTXV0YXRpb25zIiwicmVhZHlTdGF0ZSIsImRvU2Nyb2xsIiwibXV0YXRpb25zIiwibXV0YXRpb24iLCJhZGRlZE5vZGVzIiwiYWRkZWROb2RlIiwibm9kZVR5cGUiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVkTm9kZXMiLCJyZW1vdmVkTm9kZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7QUFTQyxXQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtBQUMzQixnQ0FBT0MsT0FBUCxPQUFtQixRQUFuQixJQUErQixPQUFPQyxNQUFQLEtBQWtCLFdBQWpELEdBQStEQSxNQUFNLENBQUNELE9BQVAsR0FBaUJELE9BQU8sRUFBdkYsR0FDQSxRQUE2Q0csb0NBQU9ILE9BQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBbkQsSUFDQ0QsU0FERCxDQURBO0FBR0EsQ0FKQSxFQUlDLElBSkQsRUFJTyxZQUFZO0FBQUU7O0FBRXJCLE1BQUlLLGNBQWMsR0FBRyxPQUFPQyxVQUFQLEtBQXNCLFdBQXRCLEdBQW9DQSxVQUFwQyxHQUFpRCxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPUCxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPUSxJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixHQUFxQyxFQUE3TDs7QUFFQSxXQUFTQyxvQkFBVCxDQUE4QkMsRUFBOUIsRUFBa0NQLE1BQWxDLEVBQTBDO0FBQ3pDLFdBQU9BLE1BQU0sR0FBRztBQUFFRCxhQUFPLEVBQUU7QUFBWCxLQUFULEVBQTBCUSxFQUFFLENBQUNQLE1BQUQsRUFBU0EsTUFBTSxDQUFDRCxPQUFoQixDQUE1QixFQUFzREMsTUFBTSxDQUFDRCxPQUFwRTtBQUNBOztBQUVELE1BQUlTLENBQUMsR0FBRyxRQUFSOztBQUNBLE1BQUlDLEtBQUssR0FBRyxTQUFSQSxLQUFRLENBQVVDLEVBQVYsRUFBYztBQUN4QixX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LENBQUM1RSxTQUFOLENBQWdCcUcsT0FBaEIsQ0FBd0JoTSxJQUF4QixDQUE2Qm9oQyxXQUFXLENBQUNiLGdCQUFaLENBQTZCLHlCQUE3QixDQUE3QixFQUFzRixVQUFVcDVCLEVBQVYsRUFBYztBQUNsR2l1Qix1QkFBUyxDQUFDc0UsU0FBVixDQUFvQi8zQixHQUFwQixDQUF3QndGLEVBQXhCLEtBQStCaXVCLFNBQVMsQ0FBQ3NFLFNBQVYsQ0FBb0JoNkIsR0FBcEIsQ0FBd0J5SCxFQUF4QixFQUE0QjY0QixPQUE1QixFQUEvQjtBQUNELGFBRkQ7QUFHRDtBQUNGO0FBQ0YsT0FWRDtBQVdELEtBdkJEO0FBd0JELEdBekJEOztBQTJCQTVLLFdBQVMsQ0FBQ1QsVUFBVixHQUF1QkEsVUFBdkI7QUFDQTs7Ozs7QUFLQSxNQUFJM2xCLFNBQUosRUFBZTtBQUNib21CLGFBQVMsQ0FBQ3FMLFdBQVY7QUFDRDs7QUFFRCxTQUFPckwsU0FBUDtBQUVBLENBcjVLQSxDQUFELEMiLCJmaWxlIjoiLi9wdWJsaWMvYmFja2VuZC9qcy9zaW1wbGViYXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNpbXBsZUJhci5qcyAtIHY1LjEuMFxuICogU2Nyb2xsYmFycywgc2ltcGxlci5cbiAqIGh0dHBzOi8vZ3JzbXRvLmdpdGh1Yi5pby9zaW1wbGViYXIvXG4gKlxuICogTWFkZSBieSBBZHJpZW4gRGVuYXQgZnJvbSBhIGZvcmsgYnkgSm9uYXRoYW4gTmljb2xcbiAqIFVuZGVyIE1JVCBMaWNlbnNlXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5TaW1wbGVCYXIgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0dmFyIE8gPSAnb2JqZWN0Jztcblx0dmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcblx0fTtcblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuXHR2YXIgZ2xvYmFsXzEgPVxuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHQgIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09IE8gJiYgZ2xvYmFsVGhpcykgfHxcblx0ICBjaGVjayh0eXBlb2Ygd2luZG93ID09IE8gJiYgd2luZG93KSB8fFxuXHQgIGNoZWNrKHR5cGVvZiBzZWxmID09IE8gJiYgc2VsZikgfHxcblx0ICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gTyAmJiBjb21tb25qc0dsb2JhbCkgfHxcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcblx0ICBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cdHZhciBmYWlscyA9IGZ1bmN0aW9uIChleGVjKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiAhIWV4ZWMoKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9O1xuXG5cdC8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcblx0dmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcblx0fSk7XG5cblx0dmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5cdC8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xuXHR2YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG5cdC8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuXHR2YXIgZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuXHQgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuXHQgIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xuXHR9IDogbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGU7XG5cblx0dmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge1xuXHRcdGY6IGZcblx0fTtcblxuXHR2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcblx0ICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcblx0ICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuXHQgICAgdmFsdWU6IHZhbHVlXG5cdCAgfTtcblx0fTtcblxuXHR2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxuXHR2YXIgY2xhc3NvZlJhdyA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG5cdH07XG5cblx0dmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cblx0Ly8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncblx0dmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblx0ICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xuXHR9KSA/IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiBjbGFzc29mUmF3KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XG5cdH0gOiBPYmplY3Q7XG5cblx0Ly8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5cdHZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG5cdC8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG5cblxuXG5cdHZhciB0b0luZGV4ZWRPYmplY3QgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gaW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG5cdH07XG5cblx0dmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuXHQvLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxuXHQvLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuXHQvLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xuXHR2YXIgdG9QcmltaXRpdmUgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcblx0ICBpZiAoIWlzT2JqZWN0KGlucHV0KSkgcmV0dXJuIGlucHV0O1xuXHQgIHZhciBmbiwgdmFsO1xuXHQgIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuXHQgIGlmICh0eXBlb2YgKGZuID0gaW5wdXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuXHQgIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcblx0ICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG5cdH07XG5cblx0dmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0dmFyIGhhcyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG5cdH07XG5cblx0dmFyIGRvY3VtZW50JDEgPSBnbG9iYWxfMS5kb2N1bWVudDtcblx0Ly8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cdHZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCQxKSAmJiBpc09iamVjdChkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xuXG5cdHZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xuXHR9O1xuXG5cdC8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcblx0dmFyIGllOERvbURlZmluZSA9ICFkZXNjcmlwdG9ycyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cblx0ICB9KS5hICE9IDc7XG5cdH0pO1xuXG5cdHZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5cdC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuXHR2YXIgZiQxID0gZGVzY3JpcHRvcnMgPyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuXHQgIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIGlmIChpZThEb21EZWZpbmUpIHRyeSB7XG5cdCAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblx0ICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xuXHR9O1xuXG5cdHZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7XG5cdFx0ZjogZiQxXG5cdH07XG5cblx0dmFyIGFuT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKCFpc09iamVjdChpdCkpIHtcblx0ICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG5cdCAgfSByZXR1cm4gaXQ7XG5cdH07XG5cblx0dmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cdC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcblx0dmFyIGYkMiA9IGRlc2NyaXB0b3JzID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuXHQgIGlmIChpZThEb21EZWZpbmUpIHRyeSB7XG5cdCAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXHQgIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcblx0ICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcblx0ICByZXR1cm4gTztcblx0fTtcblxuXHR2YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7XG5cdFx0ZjogZiQyXG5cdH07XG5cblx0dmFyIGhpZGUgPSBkZXNjcmlwdG9ycyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcblx0ICByZXR1cm4gb2JqZWN0RGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG5cdH0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcblx0ICByZXR1cm4gb2JqZWN0O1xuXHR9O1xuXG5cdHZhciBzZXRHbG9iYWwgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgIHRyeSB7XG5cdCAgICBoaWRlKGdsb2JhbF8xLCBrZXksIHZhbHVlKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgZ2xvYmFsXzFba2V5XSA9IHZhbHVlO1xuXHQgIH0gcmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdHZhciBzaGFyZWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdHZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcblx0dmFyIHN0b3JlID0gZ2xvYmFsXzFbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cblx0KG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcblx0fSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuXHQgIHZlcnNpb246ICczLjIuMScsXG5cdCAgbW9kZTogICdnbG9iYWwnLFxuXHQgIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG5cdH0pO1xuXHR9KTtcblxuXHR2YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHNoYXJlZCgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuXHR2YXIgV2Vha01hcCQxID0gZ2xvYmFsXzEuV2Vha01hcDtcblxuXHR2YXIgbmF0aXZlV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwJDEgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChXZWFrTWFwJDEpKTtcblxuXHR2YXIgaWQgPSAwO1xuXHR2YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cblx0dmFyIHVpZCA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICByZXR1cm4gJ1N5bWJvbCgnICsgU3RyaW5nKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArICgrK2lkICsgcG9zdGZpeCkudG9TdHJpbmcoMzYpO1xuXHR9O1xuXG5cdHZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cblx0dmFyIHNoYXJlZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG5cdH07XG5cblx0dmFyIGhpZGRlbktleXMgPSB7fTtcblxuXHR2YXIgV2Vha01hcCQyID0gZ2xvYmFsXzEuV2Vha01hcDtcblx0dmFyIHNldCwgZ2V0LCBoYXMkMTtcblxuXHR2YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiBoYXMkMShpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG5cdH07XG5cblx0dmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuXHQgICAgdmFyIHN0YXRlO1xuXHQgICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuXHQgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG5cdCAgICB9IHJldHVybiBzdGF0ZTtcblx0ICB9O1xuXHR9O1xuXG5cdGlmIChuYXRpdmVXZWFrTWFwKSB7XG5cdCAgdmFyIHN0b3JlID0gbmV3IFdlYWtNYXAkMigpO1xuXHQgIHZhciB3bWdldCA9IHN0b3JlLmdldDtcblx0ICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XG5cdCAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuXHQgIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcblx0ICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG5cdCAgICByZXR1cm4gbWV0YWRhdGE7XG5cdCAgfTtcblx0ICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG5cdCAgfTtcblx0ICBoYXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuXHQgICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcblx0ICB9O1xuXHR9IGVsc2Uge1xuXHQgIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcblx0ICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG5cdCAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuXHQgICAgaGlkZShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcblx0ICAgIHJldHVybiBtZXRhZGF0YTtcblx0ICB9O1xuXHQgIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuXHQgICAgcmV0dXJuIGhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG5cdCAgfTtcblx0ICBoYXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuXHQgICAgcmV0dXJuIGhhcyhpdCwgU1RBVEUpO1xuXHQgIH07XG5cdH1cblxuXHR2YXIgaW50ZXJuYWxTdGF0ZSA9IHtcblx0ICBzZXQ6IHNldCxcblx0ICBnZXQ6IGdldCxcblx0ICBoYXM6IGhhcyQxLFxuXHQgIGVuZm9yY2U6IGVuZm9yY2UsXG5cdCAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcblx0fTtcblxuXHR2YXIgcmVkZWZpbmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5nZXQ7XG5cdHZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZW5mb3JjZTtcblx0dmFyIFRFTVBMQVRFID0gU3RyaW5nKGZ1bmN0aW9uVG9TdHJpbmcpLnNwbGl0KCd0b1N0cmluZycpO1xuXG5cdHNoYXJlZCgnaW5zcGVjdFNvdXJjZScsIGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuXHR9KTtcblxuXHQobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuXHQgIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuXHQgIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcblx0ICB2YXIgbm9UYXJnZXRHZXQgPSBvcHRpb25zID8gISFvcHRpb25zLm5vVGFyZ2V0R2V0IDogZmFsc2U7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJyAmJiAhaGFzKHZhbHVlLCAnbmFtZScpKSBoaWRlKHZhbHVlLCAnbmFtZScsIGtleSk7XG5cdCAgICBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSkuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xuXHQgIH1cblx0ICBpZiAoTyA9PT0gZ2xvYmFsXzEpIHtcblx0ICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuXHQgICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG5cdCAgICByZXR1cm47XG5cdCAgfSBlbHNlIGlmICghdW5zYWZlKSB7XG5cdCAgICBkZWxldGUgT1trZXldO1xuXHQgIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuXHQgICAgc2ltcGxlID0gdHJ1ZTtcblx0ICB9XG5cdCAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG5cdCAgZWxzZSBoaWRlKE8sIGtleSwgdmFsdWUpO1xuXHQvLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcblx0fSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBmdW5jdGlvblRvU3RyaW5nLmNhbGwodGhpcyk7XG5cdH0pO1xuXHR9KTtcblxuXHR2YXIgcGF0aCA9IGdsb2JhbF8xO1xuXG5cdHZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcblx0fTtcblxuXHR2YXIgZ2V0QnVpbHRJbiA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuXHQgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoW25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWxfMVtuYW1lc3BhY2VdKVxuXHQgICAgOiBwYXRoW25hbWVzcGFjZV0gJiYgcGF0aFtuYW1lc3BhY2VdW21ldGhvZF0gfHwgZ2xvYmFsXzFbbmFtZXNwYWNlXSAmJiBnbG9iYWxfMVtuYW1lc3BhY2VdW21ldGhvZF07XG5cdH07XG5cblx0dmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5cdHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cblx0Ly8gYFRvSW50ZWdlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxuXHR2YXIgdG9JbnRlZ2VyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG5cdCAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG5cdH07XG5cblx0dmFyIG1pbiA9IE1hdGgubWluO1xuXG5cdC8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5cdHZhciB0b0xlbmd0aCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuXHQgIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG5cdH07XG5cblx0dmFyIG1heCA9IE1hdGgubWF4O1xuXHR2YXIgbWluJDEgPSBNYXRoLm1pbjtcblxuXHQvLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcblx0Ly8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuXHQvLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihsZW5ndGgsIGxlbmd0aCkuXG5cdHZhciB0b0Fic29sdXRlSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuXHQgIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcblx0ICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMShpbnRlZ2VyLCBsZW5ndGgpO1xuXHR9O1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cdHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG5cdCAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG5cdCAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuXHQgICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcblx0ICAgIHZhciB2YWx1ZTtcblx0ICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0ICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG5cdCAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHQgICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuXHQgICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuXHQgICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG5cdCAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcblx0ICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBhcnJheUluY2x1ZGVzID0ge1xuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuXHQgIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuXHQgIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcblx0fTtcblxuXHR2YXIgaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcblxuXG5cdHZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuXHQgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICB2YXIga2V5O1xuXHQgIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuXHQgIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcblx0ICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuXHQgICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5cdHZhciBlbnVtQnVnS2V5cyA9IFtcblx0ICAnY29uc3RydWN0b3InLFxuXHQgICdoYXNPd25Qcm9wZXJ0eScsXG5cdCAgJ2lzUHJvdG90eXBlT2YnLFxuXHQgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdCAgJ3RvTG9jYWxlU3RyaW5nJyxcblx0ICAndG9TdHJpbmcnLFxuXHQgICd2YWx1ZU9mJ1xuXHRdO1xuXG5cdHZhciBoaWRkZW5LZXlzJDEgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuXHQvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuXHR2YXIgZiQzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG5cdCAgcmV0dXJuIG9iamVjdEtleXNJbnRlcm5hbChPLCBoaWRkZW5LZXlzJDEpO1xuXHR9O1xuXG5cdHZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge1xuXHRcdGY6IGYkM1xuXHR9O1xuXG5cdHZhciBmJDQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cdHZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB7XG5cdFx0ZjogZiQ0XG5cdH07XG5cblx0Ly8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xuXHR2YXIgb3duS2V5cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcblx0ICB2YXIga2V5cyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZihhbk9iamVjdChpdCkpO1xuXHQgIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZjtcblx0ICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xuXHR9O1xuXG5cdHZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdCAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG5cdCAgdmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblx0ICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIga2V5ID0ga2V5c1tpXTtcblx0ICAgIGlmICghaGFzKHRhcmdldCwga2V5KSkgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG5cdHZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcblx0ICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG5cdCAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuXHQgICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuXHQgICAgOiB0eXBlb2YgZGV0ZWN0aW9uID09ICdmdW5jdGlvbicgPyBmYWlscyhkZXRlY3Rpb24pXG5cdCAgICA6ICEhZGV0ZWN0aW9uO1xuXHR9O1xuXG5cdHZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdCAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcblx0fTtcblxuXHR2YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcblx0dmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcblx0dmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cblx0dmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZDtcblxuXHR2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcblxuXG5cblxuXG5cblx0Lypcblx0ICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuXHQgIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3Rcblx0ICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuXHQgIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG5cdCAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG5cdCAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcblx0ICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cblx0ICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG5cdCAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuXHQgIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG5cdCAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG5cdCAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcblx0Ki9cblx0dmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdCAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuXHQgIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcblx0ICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuXHQgIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG5cdCAgaWYgKEdMT0JBTCkge1xuXHQgICAgdGFyZ2V0ID0gZ2xvYmFsXzE7XG5cdCAgfSBlbHNlIGlmIChTVEFUSUMpIHtcblx0ICAgIHRhcmdldCA9IGdsb2JhbF8xW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXQgPSAoZ2xvYmFsXzFbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuXHQgIH1cblx0ICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0ICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG5cdCAgICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuXHQgICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodGFyZ2V0LCBrZXkpO1xuXHQgICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcblx0ICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuXHQgICAgRk9SQ0VEID0gaXNGb3JjZWRfMShHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuXHQgICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuXHQgICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuXHQgICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG5cdCAgICB9XG5cdCAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG5cdCAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuXHQgICAgICBoaWRlKHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuXHQgICAgfVxuXHQgICAgLy8gZXh0ZW5kIGdsb2JhbFxuXHQgICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcblx0ICB9XG5cdH07XG5cblx0dmFyIGFGdW5jdGlvbiQxID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0ICB9IHJldHVybiBpdDtcblx0fTtcblxuXHQvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblx0dmFyIGJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcblx0ICBhRnVuY3Rpb24kMShmbik7XG5cdCAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuXHQgIHN3aXRjaCAobGVuZ3RoKSB7XG5cdCAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG5cdCAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcblx0ICB9O1xuXHR9O1xuXG5cdC8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5cdHZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuXHQgIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xuXHR9O1xuXG5cdC8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxuXHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcblx0ICByZXR1cm4gY2xhc3NvZlJhdyhhcmcpID09ICdBcnJheSc7XG5cdH07XG5cblx0dmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdCAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xuXHR9KTtcblxuXHR2YXIgU3ltYm9sJDEgPSBnbG9iYWxfMS5TeW1ib2w7XG5cdHZhciBzdG9yZSQxID0gc2hhcmVkKCd3a3MnKTtcblxuXHR2YXIgd2VsbEtub3duU3ltYm9sID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICByZXR1cm4gc3RvcmUkMVtuYW1lXSB8fCAoc3RvcmUkMVtuYW1lXSA9IG5hdGl2ZVN5bWJvbCAmJiBTeW1ib2wkMVtuYW1lXVxuXHQgICAgfHwgKG5hdGl2ZVN5bWJvbCA/IFN5bWJvbCQxIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG5cdH07XG5cblx0dmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuXHQvLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cdHZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG5cdCAgdmFyIEM7XG5cdCAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcblx0ICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuXHQgICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcblx0ICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG5cdCAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuXHQgICAgICBDID0gQ1tTUEVDSUVTXTtcblx0ICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgfSByZXR1cm4gbmV3IChDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEMpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xuXHR9O1xuXG5cdHZhciBwdXNoID0gW10ucHVzaDtcblxuXHQvLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXggfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXHR2YXIgY3JlYXRlTWV0aG9kJDEgPSBmdW5jdGlvbiAoVFlQRSkge1xuXHQgIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG5cdCAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcblx0ICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcblx0ICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG5cdCAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG5cdCAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcblx0ICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuXHQgICAgdmFyIHNlbGYgPSBpbmRleGVkT2JqZWN0KE8pO1xuXHQgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kQ29udGV4dChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcblx0ICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG5cdCAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcblx0ICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuXHQgICAgdmFyIHZhbHVlLCByZXN1bHQ7XG5cdCAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcblx0ICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcblx0ICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuXHQgICAgICBpZiAoVFlQRSkge1xuXHQgICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuXHQgICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG5cdCAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgLy8gc29tZVxuXHQgICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcblx0ICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcblx0ICAgICAgICAgIGNhc2UgMjogcHVzaC5jYWxsKHRhcmdldCwgdmFsdWUpOyAvLyBmaWx0ZXJcblx0ICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7ICAvLyBldmVyeVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuXHQgIH07XG5cdH07XG5cblx0dmFyIGFycmF5SXRlcmF0aW9uID0ge1xuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcblx0ICBmb3JFYWNoOiBjcmVhdGVNZXRob2QkMSgwKSxcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuXHQgIG1hcDogY3JlYXRlTWV0aG9kJDEoMSksXG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcblx0ICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCQxKDIpLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcblx0ICBzb21lOiBjcmVhdGVNZXRob2QkMSgzKSxcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcblx0ICBldmVyeTogY3JlYXRlTWV0aG9kJDEoNCksXG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuXHQgIGZpbmQ6IGNyZWF0ZU1ldGhvZCQxKDUpLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG5cdCAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QkMSg2KVxuXHR9O1xuXG5cdHZhciBzbG9wcHlBcnJheU1ldGhvZCA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcblx0ICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuXHQgIHJldHVybiAhbWV0aG9kIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsLG5vLXRocm93LWxpdGVyYWxcblx0ICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XG5cdCAgfSk7XG5cdH07XG5cblx0dmFyICRmb3JFYWNoID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcblxuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5cdHZhciBhcnJheUZvckVhY2ggPSBzbG9wcHlBcnJheU1ldGhvZCgnZm9yRWFjaCcpID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuXHQgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdH0gOiBbXS5mb3JFYWNoO1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFtdLmZvckVhY2ggIT0gYXJyYXlGb3JFYWNoIH0sIHtcblx0ICBmb3JFYWNoOiBhcnJheUZvckVhY2hcblx0fSk7XG5cblx0Ly8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG5cdC8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcblx0dmFyIGRvbUl0ZXJhYmxlcyA9IHtcblx0ICBDU1NSdWxlTGlzdDogMCxcblx0ICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuXHQgIENTU1ZhbHVlTGlzdDogMCxcblx0ICBDbGllbnRSZWN0TGlzdDogMCxcblx0ICBET01SZWN0TGlzdDogMCxcblx0ICBET01TdHJpbmdMaXN0OiAwLFxuXHQgIERPTVRva2VuTGlzdDogMSxcblx0ICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcblx0ICBGaWxlTGlzdDogMCxcblx0ICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcblx0ICBIVE1MQ29sbGVjdGlvbjogMCxcblx0ICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG5cdCAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG5cdCAgTWVkaWFMaXN0OiAwLFxuXHQgIE1pbWVUeXBlQXJyYXk6IDAsXG5cdCAgTmFtZWROb2RlTWFwOiAwLFxuXHQgIE5vZGVMaXN0OiAxLFxuXHQgIFBhaW50UmVxdWVzdExpc3Q6IDAsXG5cdCAgUGx1Z2luOiAwLFxuXHQgIFBsdWdpbkFycmF5OiAwLFxuXHQgIFNWR0xlbmd0aExpc3Q6IDAsXG5cdCAgU1ZHTnVtYmVyTGlzdDogMCxcblx0ICBTVkdQYXRoU2VnTGlzdDogMCxcblx0ICBTVkdQb2ludExpc3Q6IDAsXG5cdCAgU1ZHU3RyaW5nTGlzdDogMCxcblx0ICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuXHQgIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG5cdCAgU3R5bGVTaGVldExpc3Q6IDAsXG5cdCAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcblx0ICBUZXh0VHJhY2tMaXN0OiAwLFxuXHQgIFRvdWNoTGlzdDogMFxuXHR9O1xuXG5cdGZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBkb21JdGVyYWJsZXMpIHtcblx0ICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbF8xW0NPTExFQ1RJT05fTkFNRV07XG5cdCAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuXHQgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuXHQgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCAhPT0gYXJyYXlGb3JFYWNoKSB0cnkge1xuXHQgICAgaGlkZShDb2xsZWN0aW9uUHJvdG90eXBlLCAnZm9yRWFjaCcsIGFycmF5Rm9yRWFjaCk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCA9IGFycmF5Rm9yRWFjaDtcblx0ICB9XG5cdH1cblxuXHR2YXIgY2FuVXNlRE9NID0gISEoXG5cdCAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICB3aW5kb3cuZG9jdW1lbnQgJiZcblx0ICB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudFxuXHQpO1xuXG5cdHZhciBjYW5Vc2VEb20gPSBjYW5Vc2VET007XG5cblx0dmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5cdHZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG5cdCAgcmV0dXJuICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgYXJyYXkgPSBbXTtcblx0ICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG5cdCAgICBjb25zdHJ1Y3RvcltTUEVDSUVTJDFdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4geyBmb286IDEgfTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gYXJyYXlbTUVUSE9EX05BTUVdKEJvb2xlYW4pLmZvbyAhPT0gMTtcblx0ICB9KTtcblx0fTtcblxuXHR2YXIgJGZpbHRlciA9IGFycmF5SXRlcmF0aW9uLmZpbHRlcjtcblxuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuXHQvLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJykgfSwge1xuXHQgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG5cdCAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdCAgfVxuXHR9KTtcblxuXHQvLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuXHR2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuXHQgIHJldHVybiBvYmplY3RLZXlzSW50ZXJuYWwoTywgZW51bUJ1Z0tleXMpO1xuXHR9O1xuXG5cdC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG5cdHZhciBvYmplY3REZWZpbmVQcm9wZXJ0aWVzID0gZGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuXHQgIGFuT2JqZWN0KE8pO1xuXHQgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcblx0ICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdCAgdmFyIGluZGV4ID0gMDtcblx0ICB2YXIga2V5O1xuXHQgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgb2JqZWN0RGVmaW5lUHJvcGVydHkuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBQcm9wZXJ0aWVzW2tleV0pO1xuXHQgIHJldHVybiBPO1xuXHR9O1xuXG5cdHZhciBodG1sID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cblx0dmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG5cdHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblx0dmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG5cdC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcblx0dmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcblx0ICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0ICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuXHQgIHZhciBsdCA9ICc8Jztcblx0ICB2YXIgc2NyaXB0ID0gJ3NjcmlwdCc7XG5cdCAgdmFyIGd0ID0gJz4nO1xuXHQgIHZhciBqcyA9ICdqYXZhJyArIHNjcmlwdCArICc6Jztcblx0ICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG5cdCAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdCAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHQgIGlmcmFtZS5zcmMgPSBTdHJpbmcoanMpO1xuXHQgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG5cdCAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuXHQgIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgc2NyaXB0ICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnLycgKyBzY3JpcHQgKyBndCk7XG5cdCAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcblx0ICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcblx0ICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG5cdCAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcblx0fTtcblxuXHQvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcblx0dmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcblx0ICB2YXIgcmVzdWx0O1xuXHQgIGlmIChPICE9PSBudWxsKSB7XG5cdCAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG5cdCAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcblx0ICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuXHQgICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuXHQgICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG5cdCAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcblx0ICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogb2JqZWN0RGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xuXHR9O1xuXG5cdGhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuXHR2YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG5cdHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuXHQvLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblx0aWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcblx0ICBoaWRlKEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywgb2JqZWN0Q3JlYXRlKG51bGwpKTtcblx0fVxuXG5cdC8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cblx0dmFyIGFkZFRvVW5zY29wYWJsZXMgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xuXHR9O1xuXG5cdHZhciBpdGVyYXRvcnMgPSB7fTtcblxuXHR2YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuXHQgIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcblx0ICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcblx0fSk7XG5cblx0dmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cdHZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcblx0dmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gY29ycmVjdFByb3RvdHlwZUdldHRlciA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG5cdCAgTyA9IHRvT2JqZWN0KE8pO1xuXHQgIGlmIChoYXMoTywgSUVfUFJPVE8kMSkpIHJldHVybiBPW0lFX1BST1RPJDFdO1xuXHQgIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG5cdCAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cdCAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG5cdH07XG5cblx0dmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXHR2YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xuXG5cdHZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuXHQvLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG5cdHZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5cdGlmIChbXS5rZXlzKSB7XG5cdCAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcblx0ICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcblx0ICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuXHQgIGVsc2Uge1xuXHQgICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gb2JqZWN0R2V0UHJvdG90eXBlT2Yob2JqZWN0R2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuXHQgICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG5cdCAgfVxuXHR9XG5cblx0aWYgKEl0ZXJhdG9yUHJvdG90eXBlID09IHVuZGVmaW5lZCkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuXHQvLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuXHRpZiAoICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuXG5cdHZhciBpdGVyYXRvcnNDb3JlID0ge1xuXHQgIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcblx0ICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG5cdH07XG5cblx0dmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXG5cblx0dmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cblx0dmFyIHNldFRvU3RyaW5nVGFnID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuXHQgIGlmIChpdCAmJiAhaGFzKGl0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XG5cdCAgICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBJdGVyYXRvclByb3RvdHlwZSQxID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcblxuXG5cblxuXG5cdHZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5cdHZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcblx0ICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcblx0ICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG9iamVjdENyZWF0ZShJdGVyYXRvclByb3RvdHlwZSQxLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcblx0ICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSk7XG5cdCAgaXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuXHQgIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xuXHR9O1xuXG5cdHZhciBhUG9zc2libGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuXHQgICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nKGl0KSArICcgYXMgYSBwcm90b3R5cGUnKTtcblx0ICB9IHJldHVybiBpdDtcblx0fTtcblxuXHQvLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG5cdC8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXHR2YXIgb2JqZWN0U2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuXHQgIHZhciB0ZXN0ID0ge307XG5cdCAgdmFyIHNldHRlcjtcblx0ICB0cnkge1xuXHQgICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuXHQgICAgc2V0dGVyLmNhbGwodGVzdCwgW10pO1xuXHQgICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXHQgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuXHQgICAgYW5PYmplY3QoTyk7XG5cdCAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuXHQgICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XG5cdCAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG5cdCAgICByZXR1cm4gTztcblx0ICB9O1xuXHR9KCkgOiB1bmRlZmluZWQpO1xuXG5cdHZhciBJdGVyYXRvclByb3RvdHlwZSQyID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcblx0dmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IGl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcblx0dmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cdHZhciBLRVlTID0gJ2tleXMnO1xuXHR2YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cdHZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG5cdHZhciByZXR1cm5UaGlzJDIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5cdHZhciBkZWZpbmVJdGVyYXRvciA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcblx0ICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG5cdCAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG5cdCAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG5cdCAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG5cdCAgICBzd2l0Y2ggKEtJTkQpIHtcblx0ICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuXHQgICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuXHQgICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG5cdCAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcblx0ICB9O1xuXG5cdCAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG5cdCAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuXHQgIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcblx0ICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQxXVxuXHQgICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuXHQgICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcblx0ICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG5cdCAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuXHQgIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuXHQgIC8vIGZpeCBuYXRpdmVcblx0ICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcblx0ICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IG9iamVjdEdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcblx0ICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSQyICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG5cdCAgICAgIGlmICggb2JqZWN0R2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUkMikge1xuXHQgICAgICAgIGlmIChvYmplY3RTZXRQcm90b3R5cGVPZikge1xuXHQgICAgICAgICAgb2JqZWN0U2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSQyKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1IkMV0gIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgaGlkZShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SJDEsIHJldHVyblRoaXMkMik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcblx0ICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG5cdCAgaWYgKERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuXHQgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcblx0ICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG5cdCAgfVxuXG5cdCAgLy8gZGVmaW5lIGl0ZXJhdG9yXG5cdCAgaWYgKCBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQxXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG5cdCAgICBoaWRlKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiQxLCBkZWZhdWx0SXRlcmF0b3IpO1xuXHQgIH1cblx0ICBpdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cblx0ICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG5cdCAgaWYgKERFRkFVTFQpIHtcblx0ICAgIG1ldGhvZHMgPSB7XG5cdCAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG5cdCAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcblx0ICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG5cdCAgICB9O1xuXHQgICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuXHQgICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcblx0ICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgX2V4cG9ydCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcblx0ICB9XG5cblx0ICByZXR1cm4gbWV0aG9kcztcblx0fTtcblxuXHR2YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xuXHR2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuc2V0O1xuXHR2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuXHQvLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuXHQvLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuXHQvLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcblx0Ly8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5cdC8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxuXHR2YXIgZXNfYXJyYXlfaXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG5cdCAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG5cdCAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcblx0ICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG5cdCAgICBpbmRleDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcblx0ICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuXHQgIH0pO1xuXHQvLyBgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxuXHR9LCBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcblx0ICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuXHQgIHZhciBraW5kID0gc3RhdGUua2luZDtcblx0ICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuXHQgIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcblx0ICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcblx0ICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcblx0ICB9XG5cdCAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG5cdCAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuXHQgIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xuXHR9LCAndmFsdWVzJyk7XG5cblx0Ly8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuXHRpdGVyYXRvcnMuQXJndW1lbnRzID0gaXRlcmF0b3JzLkFycmF5O1xuXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cdGFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcblx0YWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5cdGFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXHR2YXIgbmF0aXZlQXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuXHQvLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cblx0Ly8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5cdHZhciBvYmplY3RBc3NpZ24gPSAhbmF0aXZlQXNzaWduIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgQSA9IHt9O1xuXHQgIHZhciBCID0ge307XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdCAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuXHQgIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdCAgQVtzeW1ib2xdID0gNztcblx0ICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG5cdCAgcmV0dXJuIG5hdGl2ZUFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMobmF0aXZlQXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG5cdH0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdCAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgdmFyIGluZGV4ID0gMTtcblx0ICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmY7XG5cdCAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZjtcblx0ICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcblx0ICAgIHZhciBTID0gaW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuXHQgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBvYmplY3RLZXlzKFMpLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcblx0ICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0ICAgIHZhciBqID0gMDtcblx0ICAgIHZhciBrZXk7XG5cdCAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuXHQgICAgICBrZXkgPSBrZXlzW2orK107XG5cdCAgICAgIGlmICghZGVzY3JpcHRvcnMgfHwgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG5cdCAgICB9XG5cdCAgfSByZXR1cm4gVDtcblx0fSA6IG5hdGl2ZUFzc2lnbjtcblxuXHQvLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cblx0X2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gb2JqZWN0QXNzaWduIH0sIHtcblx0ICBhc3NpZ246IG9iamVjdEFzc2lnblxuXHR9KTtcblxuXHR2YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXHQvLyBFUzMgd3JvbmcgaGVyZVxuXHR2YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuXHQvLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxuXHR2YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuIGl0W2tleV07XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXHR9O1xuXG5cdC8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcblx0dmFyIGNsYXNzb2YgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICB2YXIgTywgdGFnLCByZXN1bHQ7XG5cdCAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG5cdCAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2Vcblx0ICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRPX1NUUklOR19UQUckMSkpID09ICdzdHJpbmcnID8gdGFnXG5cdCAgICAvLyBidWlsdGluVGFnIGNhc2Vcblx0ICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG5cdCAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG5cdCAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xuXHR9O1xuXG5cdHZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cdHZhciB0ZXN0ID0ge307XG5cblx0dGVzdFtUT19TVFJJTkdfVEFHJDJdID0gJ3onO1xuXG5cdC8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuXHR2YXIgb2JqZWN0VG9TdHJpbmcgPSBTdHJpbmcodGVzdCkgIT09ICdbb2JqZWN0IHpdJyA/IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcblx0fSA6IHRlc3QudG9TdHJpbmc7XG5cblx0dmFyIE9iamVjdFByb3RvdHlwZSQxID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcblx0aWYgKG9iamVjdFRvU3RyaW5nICE9PSBPYmplY3RQcm90b3R5cGUkMS50b1N0cmluZykge1xuXHQgIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSQxLCAndG9TdHJpbmcnLCBvYmplY3RUb1N0cmluZywgeyB1bnNhZmU6IHRydWUgfSk7XG5cdH1cblxuXHQvLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuXHR2YXIgd2hpdGVzcGFjZXMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cblx0dmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyArICddJztcblx0dmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcblx0dmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXHR2YXIgY3JlYXRlTWV0aG9kJDIgPSBmdW5jdGlvbiAoVFlQRSkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcblx0ICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuXHQgICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuXHQgICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuXHQgICAgcmV0dXJuIHN0cmluZztcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBzdHJpbmdUcmltID0ge1xuXHQgIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcblx0ICBzdGFydDogY3JlYXRlTWV0aG9kJDIoMSksXG5cdCAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuXHQgIGVuZDogY3JlYXRlTWV0aG9kJDIoMiksXG5cdCAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG5cdCAgdHJpbTogY3JlYXRlTWV0aG9kJDIoMylcblx0fTtcblxuXHR2YXIgdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcblxuXG5cdHZhciBuYXRpdmVQYXJzZUludCA9IGdsb2JhbF8xLnBhcnNlSW50O1xuXHR2YXIgaGV4ID0gL15bKy1dPzBbWHhdLztcblx0dmFyIEZPUkNFRCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzA4JykgIT09IDggfHwgbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMHgxNicpICE9PSAyMjtcblxuXHQvLyBgcGFyc2VJbnRgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblx0dmFyIF9wYXJzZUludCA9IEZPUkNFRCA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgpIHtcblx0ICB2YXIgUyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuXHQgIHJldHVybiBuYXRpdmVQYXJzZUludChTLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChTKSA/IDE2IDogMTApKTtcblx0fSA6IG5hdGl2ZVBhcnNlSW50O1xuXG5cdC8vIGBwYXJzZUludGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxuXHRfZXhwb3J0KHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlSW50ICE9IF9wYXJzZUludCB9LCB7XG5cdCAgcGFyc2VJbnQ6IF9wYXJzZUludFxuXHR9KTtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS57IGNvZGVQb2ludEF0LCBhdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cdHZhciBjcmVhdGVNZXRob2QkMyA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuXHQgICAgdmFyIFMgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuXHQgICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG5cdCAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuXHQgICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG5cdCAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuXHQgICAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuXHQgICAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxuXHQgICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuXHQgICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxuXHQgICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBzdHJpbmdNdWx0aWJ5dGUgPSB7XG5cdCAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcblx0ICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZCQzKGZhbHNlKSxcblx0ICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuXHQgIGNoYXJBdDogY3JlYXRlTWV0aG9kJDModHJ1ZSlcblx0fTtcblxuXHR2YXIgY2hhckF0ID0gc3RyaW5nTXVsdGlieXRlLmNoYXJBdDtcblxuXG5cblx0dmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xuXHR2YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gaW50ZXJuYWxTdGF0ZS5zZXQ7XG5cdHZhciBnZXRJbnRlcm5hbFN0YXRlJDEgPSBpbnRlcm5hbFN0YXRlLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5cdGRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuXHQgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG5cdCAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG5cdCAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG5cdCAgICBpbmRleDogMFxuXHQgIH0pO1xuXHQvLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG5cdH0sIGZ1bmN0aW9uIG5leHQoKSB7XG5cdCAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpO1xuXHQgIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG5cdCAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG5cdCAgdmFyIHBvaW50O1xuXHQgIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG5cdCAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG5cdCAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuXHQgIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcblx0fSk7XG5cblx0dmFyIHJlZGVmaW5lQWxsID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG5cdCAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcblx0ICByZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdHZhciBmcmVlemluZyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG5cdH0pO1xuXG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHR2YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG5cblxuXHR2YXIgTUVUQURBVEEgPSB1aWQoJ21ldGEnKTtcblx0dmFyIGlkID0gMDtcblxuXHR2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cblx0dmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgZGVmaW5lUHJvcGVydHkoaXQsIE1FVEFEQVRBLCB7IHZhbHVlOiB7XG5cdCAgICBvYmplY3RJRDogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG5cdCAgICB3ZWFrRGF0YToge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcblx0ICB9IH0pO1xuXHR9O1xuXG5cdHZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcblx0ICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcblx0ICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcblx0ICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG5cdCAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuXHQgICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuXHQgICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblx0ICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuXHQgICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblx0ICAgIHNldE1ldGFkYXRhKGl0KTtcblx0ICAvLyByZXR1cm4gb2JqZWN0IElEXG5cdCAgfSByZXR1cm4gaXRbTUVUQURBVEFdLm9iamVjdElEO1xuXHR9O1xuXG5cdHZhciBnZXRXZWFrRGF0YSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG5cdCAgaWYgKCFoYXMoaXQsIE1FVEFEQVRBKSkge1xuXHQgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3Rcblx0ICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG5cdCAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXHQgICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcblx0ICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cdCAgICBzZXRNZXRhZGF0YShpdCk7XG5cdCAgLy8gcmV0dXJuIHRoZSBzdG9yZSBvZiB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuXHQgIH0gcmV0dXJuIGl0W01FVEFEQVRBXS53ZWFrRGF0YTtcblx0fTtcblxuXHQvLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcblx0dmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKGZyZWV6aW5nICYmIG1ldGEuUkVRVUlSRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBREFUQSkpIHNldE1ldGFkYXRhKGl0KTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cblx0dmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBSRVFVSVJFRDogZmFsc2UsXG5cdCAgZmFzdEtleTogZmFzdEtleSxcblx0ICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXG5cdCAgb25GcmVlemU6IG9uRnJlZXplXG5cdH07XG5cblx0aGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuXHR9KTtcblx0dmFyIGludGVybmFsTWV0YWRhdGFfMSA9IGludGVybmFsTWV0YWRhdGEuUkVRVUlSRUQ7XG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhXzIgPSBpbnRlcm5hbE1ldGFkYXRhLmZhc3RLZXk7XG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhXzMgPSBpbnRlcm5hbE1ldGFkYXRhLmdldFdlYWtEYXRhO1xuXHR2YXIgaW50ZXJuYWxNZXRhZGF0YV80ID0gaW50ZXJuYWxNZXRhZGF0YS5vbkZyZWV6ZTtcblxuXHR2YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblx0dmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cblx0Ly8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxuXHR2YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKGl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGUkMVtJVEVSQVRPUiQyXSA9PT0gaXQpO1xuXHR9O1xuXG5cdHZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5cdHZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUiQzXVxuXHQgICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuXHQgICAgfHwgaXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcblx0fTtcblxuXHQvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG5cdHZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcblx0ICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICB2YXIgcmV0dXJuTWV0aG9kID0gaXRlcmF0b3JbJ3JldHVybiddO1xuXHQgICAgaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXR1cm5NZXRob2QuY2FsbChpdGVyYXRvcikpO1xuXHQgICAgdGhyb3cgZXJyb3I7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBpdGVyYXRlXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdHZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG5cdCAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcblx0ICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcblx0fTtcblxuXHR2YXIgaXRlcmF0ZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBmbiwgdGhhdCwgQVNfRU5UUklFUywgSVNfSVRFUkFUT1IpIHtcblx0ICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmRDb250ZXh0KGZuLCB0aGF0LCBBU19FTlRSSUVTID8gMiA6IDEpO1xuXHQgIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIHN0ZXA7XG5cblx0ICBpZiAoSVNfSVRFUkFUT1IpIHtcblx0ICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcblx0ICAgIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZScpO1xuXHQgICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcblx0ICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuXHQgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcblx0ICAgICAgICByZXN1bHQgPSBBU19FTlRSSUVTXG5cdCAgICAgICAgICA/IGJvdW5kRnVuY3Rpb24oYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pXG5cdCAgICAgICAgICA6IGJvdW5kRnVuY3Rpb24oaXRlcmFibGVbaW5kZXhdKTtcblx0ICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG5cdCAgICB9XG5cdCAgICBpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTtcblx0ICB9XG5cblx0ICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG5cdCAgICByZXN1bHQgPSBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBib3VuZEZ1bmN0aW9uLCBzdGVwLnZhbHVlLCBBU19FTlRSSUVTKTtcblx0ICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXHQgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuXHR9O1xuXG5cdGl0ZXJhdGUuc3RvcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCByZXN1bHQpO1xuXHR9O1xuXHR9KTtcblxuXHR2YXIgYW5JbnN0YW5jZSA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcblx0ICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuXHQgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgJyArIChuYW1lID8gbmFtZSArICcgJyA6ICcnKSArICdpbnZvY2F0aW9uJyk7XG5cdCAgfSByZXR1cm4gaXQ7XG5cdH07XG5cblx0dmFyIElURVJBVE9SJDQgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cdHZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxuXHR0cnkge1xuXHQgIHZhciBjYWxsZWQgPSAwO1xuXHQgIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG5cdCAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcblx0ICAgIH0sXG5cdCAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuXHQgICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDRdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHQgIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xuXHR9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cblx0dmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcblx0ICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG5cdCAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBvYmplY3QgPSB7fTtcblx0ICAgIG9iamVjdFtJVEVSQVRPUiQ0XSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgZXhlYyhvYmplY3QpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblx0ICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG5cdH07XG5cblx0Ly8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xuXHR2YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG5cdCAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuXHQgIGlmIChcblx0ICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuXHQgICAgb2JqZWN0U2V0UHJvdG90eXBlT2YgJiZcblx0ICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcblx0ICAgIHR5cGVvZiAoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpID09ICdmdW5jdGlvbicgJiZcblx0ICAgIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJlxuXHQgICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcblx0ICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcblx0ICApIG9iamVjdFNldFByb3RvdHlwZU9mKCR0aGlzLCBOZXdUYXJnZXRQcm90b3R5cGUpO1xuXHQgIHJldHVybiAkdGhpcztcblx0fTtcblxuXHR2YXIgY29sbGVjdGlvbiA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FLCB3cmFwcGVyLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuXHQgIHZhciBOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbF8xW0NPTlNUUlVDVE9SX05BTUVdO1xuXHQgIHZhciBOYXRpdmVQcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3RvciAmJiBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cdCAgdmFyIENvbnN0cnVjdG9yID0gTmF0aXZlQ29uc3RydWN0b3I7XG5cdCAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcblx0ICB2YXIgZXhwb3J0ZWQgPSB7fTtcblxuXHQgIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG5cdCAgICB2YXIgbmF0aXZlTWV0aG9kID0gTmF0aXZlUHJvdG90eXBlW0tFWV07XG5cdCAgICByZWRlZmluZShOYXRpdmVQcm90b3R5cGUsIEtFWSxcblx0ICAgICAgS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG5cdCAgICAgICAgbmF0aXZlTWV0aG9kLmNhbGwodGhpcywgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9IDogS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcblx0ICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChrZXkpIHtcblx0ICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IHVuZGVmaW5lZCA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuXHQgICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGtleSkge1xuXHQgICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcblx0ICAgICAgfSA6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG5cdCAgICAgICAgbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cdCAgICApO1xuXHQgIH07XG5cblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuXHQgIGlmIChpc0ZvcmNlZF8xKENPTlNUUlVDVE9SX05BTUUsIHR5cGVvZiBOYXRpdmVDb25zdHJ1Y3RvciAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcblx0ICB9KSkpKSB7XG5cdCAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuXHQgICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG5cdCAgICBpbnRlcm5hbE1ldGFkYXRhLlJFUVVJUkVEID0gdHJ1ZTtcblx0ICB9IGVsc2UgaWYgKGlzRm9yY2VkXzEoQ09OU1RSVUNUT1JfTkFNRSwgdHJ1ZSkpIHtcblx0ICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuXHQgICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuXHQgICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcblx0ICAgIC8vIFY4IH4gQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG5cdCAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG5cdCAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG5cdCAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGl0ZXJhYmxlKTsgfSk7XG5cdCAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcblx0ICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcblx0ICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuXHQgICAgICB2YXIgaW5kZXggPSA1O1xuXHQgICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuXHQgICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuXHQgICAgfSk7XG5cblx0ICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuXHQgICAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBpdGVyYWJsZSkge1xuXHQgICAgICAgIGFuSW5zdGFuY2UoZHVtbXksIENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcblx0ICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLCBkdW1teSwgQ29uc3RydWN0b3IpO1xuXHQgICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGVfMShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHRoYXQsIElTX01BUCk7XG5cdCAgICAgICAgcmV0dXJuIHRoYXQ7XG5cdCAgICAgIH0pO1xuXHQgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBOYXRpdmVQcm90b3R5cGU7XG5cdCAgICAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuXHQgICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuXHQgICAgICBmaXhNZXRob2QoJ2hhcycpO1xuXHQgICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG5cblx0ICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG5cdCAgICBpZiAoSVNfV0VBSyAmJiBOYXRpdmVQcm90b3R5cGUuY2xlYXIpIGRlbGV0ZSBOYXRpdmVQcm90b3R5cGUuY2xlYXI7XG5cdCAgfVxuXG5cdCAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3Rvcjtcblx0ICBfZXhwb3J0KHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IENvbnN0cnVjdG9yICE9IE5hdGl2ZUNvbnN0cnVjdG9yIH0sIGV4cG9ydGVkKTtcblxuXHQgIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcblxuXHQgIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKTtcblxuXHQgIHJldHVybiBDb25zdHJ1Y3Rvcjtcblx0fTtcblxuXHR2YXIgZ2V0V2Vha0RhdGEgPSBpbnRlcm5hbE1ldGFkYXRhLmdldFdlYWtEYXRhO1xuXG5cblxuXG5cblxuXG5cblx0dmFyIHNldEludGVybmFsU3RhdGUkMiA9IGludGVybmFsU3RhdGUuc2V0O1xuXHR2YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yO1xuXHR2YXIgZmluZCA9IGFycmF5SXRlcmF0aW9uLmZpbmQ7XG5cdHZhciBmaW5kSW5kZXggPSBhcnJheUl0ZXJhdGlvbi5maW5kSW5kZXg7XG5cdHZhciBpZCQxID0gMDtcblxuXHQvLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcblx0dmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoc3RvcmUpIHtcblx0ICByZXR1cm4gc3RvcmUuZnJvemVuIHx8IChzdG9yZS5mcm96ZW4gPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcblx0fTtcblxuXHR2YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmVudHJpZXMgPSBbXTtcblx0fTtcblxuXHR2YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcblx0ICByZXR1cm4gZmluZChzdG9yZS5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuXHQgIH0pO1xuXHR9O1xuXG5cdFVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuXHQgIGdldDogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG5cdCAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcblx0ICB9LFxuXHQgIGhhczogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG5cdCAgfSxcblx0ICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcblx0ICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcblx0ICAgIGVsc2UgdGhpcy5lbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcblx0ICB9LFxuXHQgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcblx0ICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG5cdCAgICB9KTtcblx0ICAgIGlmICh+aW5kZXgpIHRoaXMuZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgcmV0dXJuICEhfmluZGV4O1xuXHQgIH1cblx0fTtcblxuXHR2YXIgY29sbGVjdGlvbldlYWsgPSB7XG5cdCAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG5cdCAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG5cdCAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgQ09OU1RSVUNUT1JfTkFNRSk7XG5cdCAgICAgIHNldEludGVybmFsU3RhdGUkMih0aGF0LCB7XG5cdCAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcblx0ICAgICAgICBpZDogaWQkMSsrLFxuXHQgICAgICAgIGZyb3plbjogdW5kZWZpbmVkXG5cdCAgICAgIH0pO1xuXHQgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlXzEoaXRlcmFibGUsIHRoYXRbQURERVJdLCB0aGF0LCBJU19NQVApO1xuXHQgICAgfSk7XG5cblx0ICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcblxuXHQgICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG5cdCAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG5cdCAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG5cdCAgICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgICAgIGVsc2UgZGF0YVtzdGF0ZS5pZF0gPSB2YWx1ZTtcblx0ICAgICAgcmV0dXJuIHRoYXQ7XG5cdCAgICB9O1xuXG5cdCAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuXHQgICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuXHQgICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG5cdCAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcblx0ICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG5cdCAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKVsnZGVsZXRlJ10oa2V5KTtcblx0ICAgICAgICByZXR1cm4gZGF0YSAmJiBoYXMoZGF0YSwgc3RhdGUuaWQpICYmIGRlbGV0ZSBkYXRhW3N0YXRlLmlkXTtcblx0ICAgICAgfSxcblx0ICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcblx0ICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuXHQgICAgICBoYXM6IGZ1bmN0aW9uIGhhcyQxKGtleSkge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuXHQgICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuaGFzKGtleSk7XG5cdCAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzKGRhdGEsIHN0YXRlLmlkKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBJU19NQVAgPyB7XG5cdCAgICAgIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcblx0ICAgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcblx0ICAgICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuZ2V0KGtleSk7XG5cdCAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGFbc3RhdGUuaWRdIDogdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG5cdCAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICB9IDoge1xuXHQgICAgICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG5cdCAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gQztcblx0ICB9XG5cdH07XG5cblx0dmFyIGVzX3dlYWtNYXAgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cblxuXG5cblxuXG5cdHZhciBlbmZvcmNlSXRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5lbmZvcmNlO1xuXG5cblx0dmFyIElTX0lFMTEgPSAhZ2xvYmFsXzEuQWN0aXZlWE9iamVjdCAmJiAnQWN0aXZlWE9iamVjdCcgaW4gZ2xvYmFsXzE7XG5cdHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXHR2YXIgSW50ZXJuYWxXZWFrTWFwO1xuXG5cdHZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuXHQgICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcblx0ICB9O1xuXHR9O1xuXG5cdC8vIGBXZWFrTWFwYCBjb25zdHJ1Y3RvclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13ZWFrbWFwLWNvbnN0cnVjdG9yXG5cdHZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gY29sbGVjdGlvbignV2Vha01hcCcsIHdyYXBwZXIsIGNvbGxlY3Rpb25XZWFrLCB0cnVlLCB0cnVlKTtcblxuXHQvLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5cdC8vIFdlIGNhbid0IHVzZSBmZWF0dXJlIGRldGVjdGlvbiBiZWNhdXNlIGl0IGNyYXNoIHNvbWUgb2xkIElFIGJ1aWxkc1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDg1XG5cdGlmIChuYXRpdmVXZWFrTWFwICYmIElTX0lFMTEpIHtcblx0ICBJbnRlcm5hbFdlYWtNYXAgPSBjb2xsZWN0aW9uV2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCAnV2Vha01hcCcsIHRydWUpO1xuXHQgIGludGVybmFsTWV0YWRhdGEuUkVRVUlSRUQgPSB0cnVlO1xuXHQgIHZhciBXZWFrTWFwUHJvdG90eXBlID0gJFdlYWtNYXAucHJvdG90eXBlO1xuXHQgIHZhciBuYXRpdmVEZWxldGUgPSBXZWFrTWFwUHJvdG90eXBlWydkZWxldGUnXTtcblx0ICB2YXIgbmF0aXZlSGFzID0gV2Vha01hcFByb3RvdHlwZS5oYXM7XG5cdCAgdmFyIG5hdGl2ZUdldCA9IFdlYWtNYXBQcm90b3R5cGUuZ2V0O1xuXHQgIHZhciBuYXRpdmVTZXQgPSBXZWFrTWFwUHJvdG90eXBlLnNldDtcblx0ICByZWRlZmluZUFsbChXZWFrTWFwUHJvdG90eXBlLCB7XG5cdCAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuXHQgICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG5cdCAgICAgICAgcmV0dXJuIG5hdGl2ZURlbGV0ZS5jYWxsKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuWydkZWxldGUnXShrZXkpO1xuXHQgICAgICB9IHJldHVybiBuYXRpdmVEZWxldGUuY2FsbCh0aGlzLCBrZXkpO1xuXHQgICAgfSxcblx0ICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuXHQgICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuXHQgICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG5cdCAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuLmhhcyhrZXkpO1xuXHQgICAgICB9IHJldHVybiBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpO1xuXHQgICAgfSxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuXHQgICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuXHQgICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG5cdCAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSkgPyBuYXRpdmVHZXQuY2FsbCh0aGlzLCBrZXkpIDogc3RhdGUuZnJvemVuLmdldChrZXkpO1xuXHQgICAgICB9IHJldHVybiBuYXRpdmVHZXQuY2FsbCh0aGlzLCBrZXkpO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcblx0ICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTtcblx0ICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuXHQgICAgICAgIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSkgPyBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKSA6IHN0YXRlLmZyb3plbi5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgICAgIH0gZWxzZSBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblx0fSk7XG5cblx0dmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cdHZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cdHZhciBBcnJheVZhbHVlcyA9IGVzX2FycmF5X2l0ZXJhdG9yLnZhbHVlcztcblxuXHRmb3IgKHZhciBDT0xMRUNUSU9OX05BTUUkMSBpbiBkb21JdGVyYWJsZXMpIHtcblx0ICB2YXIgQ29sbGVjdGlvbiQxID0gZ2xvYmFsXzFbQ09MTEVDVElPTl9OQU1FJDFdO1xuXHQgIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlJDEgPSBDb2xsZWN0aW9uJDEgJiYgQ29sbGVjdGlvbiQxLnByb3RvdHlwZTtcblx0ICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSQxKSB7XG5cdCAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3Rcblx0ICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlJDFbSVRFUkFUT1IkNV0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuXHQgICAgICBoaWRlKENvbGxlY3Rpb25Qcm90b3R5cGUkMSwgSVRFUkFUT1IkNSwgQXJyYXlWYWx1ZXMpO1xuXHQgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgQ29sbGVjdGlvblByb3RvdHlwZSQxW0lURVJBVE9SJDVdID0gQXJyYXlWYWx1ZXM7XG5cdCAgICB9XG5cdCAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGUkMVtUT19TVFJJTkdfVEFHJDNdKSBoaWRlKENvbGxlY3Rpb25Qcm90b3R5cGUkMSwgVE9fU1RSSU5HX1RBRyQzLCBDT0xMRUNUSU9OX05BTUUkMSk7XG5cdCAgICBpZiAoZG9tSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRSQxXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gZXNfYXJyYXlfaXRlcmF0b3IpIHtcblx0ICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG5cdCAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlJDFbTUVUSE9EX05BTUVdICE9PSBlc19hcnJheV9pdGVyYXRvcltNRVRIT0RfTkFNRV0pIHRyeSB7XG5cdCAgICAgICAgaGlkZShDb2xsZWN0aW9uUHJvdG90eXBlJDEsIE1FVEhPRF9OQU1FLCBlc19hcnJheV9pdGVyYXRvcltNRVRIT0RfTkFNRV0pO1xuXHQgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGUkMVtNRVRIT0RfTkFNRV0gPSBlc19hcnJheV9pdGVyYXRvcltNRVRIT0RfTkFNRV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuXHQgKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2Bcblx0ICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG5cdCAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cblx0ICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cblx0ICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG5cdCAqL1xuXG5cdC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG5cdHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBOQU4gPSAwIC8gMDtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuXHQvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xuXHR2YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuXHR2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuXHQvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuXHR2YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cblx0dmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cblx0LyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG5cdHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICogb2YgdmFsdWVzLlxuXHQgKi9cblx0dmFyIG9iamVjdFRvU3RyaW5nJDEgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG5cdHZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcblx0ICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2Vcblx0ICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDIuNC4wXG5cdCAqIEBjYXRlZ29yeSBEYXRlXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuXHQgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG5cdCAqIH0sIF8ubm93KCkpO1xuXHQgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuXHQgKi9cblx0dmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiByb290LkRhdGUubm93KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuXHQgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcblx0ICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuXHQgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cblx0ICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG5cdCAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcblx0ICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuXHQgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuXHQgKiBpbnZvY2F0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG5cdCAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG5cdCAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cblx0ICpcblx0ICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG5cdCAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cblx0ICpcblx0ICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG5cdCAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuXHQgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cblx0ICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG5cdCAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG5cdCAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG5cdCAqXG5cdCAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuXHQgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG5cdCAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuXHQgKiAgICd0cmFpbGluZyc6IGZhbHNlXG5cdCAqIH0pKTtcblx0ICpcblx0ICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cblx0ICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG5cdCAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcblx0ICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuXHQgKlxuXHQgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuXHQgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcblx0ICovXG5cdGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcblx0ICB2YXIgbGFzdEFyZ3MsXG5cdCAgICAgIGxhc3RUaGlzLFxuXHQgICAgICBtYXhXYWl0LFxuXHQgICAgICByZXN1bHQsXG5cdCAgICAgIHRpbWVySWQsXG5cdCAgICAgIGxhc3RDYWxsVGltZSxcblx0ICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuXHQgICAgICBsZWFkaW5nID0gZmFsc2UsXG5cdCAgICAgIG1heGluZyA9IGZhbHNlLFxuXHQgICAgICB0cmFpbGluZyA9IHRydWU7XG5cblx0ICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgIH1cblx0ICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcblx0ICBpZiAoaXNPYmplY3QkMShvcHRpb25zKSkge1xuXHQgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuXHQgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG5cdCAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuXHQgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcblx0ICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG5cdCAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG5cdCAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuXHQgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuXHQgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuXHQgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cblx0ICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcblx0ICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG5cdCAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG5cdCAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG5cdCAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuXHQgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG5cdCAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG5cdCAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG5cdCAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuXHQgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cblx0ICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG5cdCAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuXHQgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuXHQgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcblx0ICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG5cdCAgICB2YXIgdGltZSA9IG5vdygpO1xuXHQgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuXHQgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuXHQgICAgfVxuXHQgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG5cdCAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG5cdCAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG5cdCAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG5cdCAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cblx0ICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuXHQgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcblx0ICAgIH1cblx0ICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcblx0ICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuXHQgICAgfVxuXHQgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuXHQgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZmx1c2goKSB7XG5cdCAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG5cdCAgICB2YXIgdGltZSA9IG5vdygpLFxuXHQgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cblx0ICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuXHQgICAgbGFzdFRoaXMgPSB0aGlzO1xuXHQgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuXHQgICAgaWYgKGlzSW52b2tpbmcpIHtcblx0ICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChtYXhpbmcpIHtcblx0ICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuXHQgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG5cdCAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cdCAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcblx0ICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcblx0ICByZXR1cm4gZGVib3VuY2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcblx0ICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcblx0ICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuXHQgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Bcblx0ICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuXHQgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG5cdCAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcblx0ICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG5cdCAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG5cdCAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cblx0ICpcblx0ICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG5cdCAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cblx0ICpcblx0ICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG5cdCAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG5cdCAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cblx0ICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cblx0ICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuXHQgKlxuXHQgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cblx0ICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuXHQgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcblx0ICpcblx0ICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cblx0ICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG5cdCAqL1xuXHRmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG5cdCAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuXHQgICAgICB0cmFpbGluZyA9IHRydWU7XG5cblx0ICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgIH1cblx0ICBpZiAoaXNPYmplY3QkMShvcHRpb25zKSkge1xuXHQgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuXHQgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcblx0ICB9XG5cdCAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcblx0ICAgICdsZWFkaW5nJzogbGVhZGluZyxcblx0ICAgICdtYXhXYWl0Jzogd2FpdCxcblx0ICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG5cdCAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcblx0ICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3Qoe30pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdChudWxsKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0JDEodmFsdWUpIHtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuXHQgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuXHQgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzU3ltYm9sKCdhYmMnKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuXHQgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy50b051bWJlcigzLjIpO1xuXHQgKiAvLyA9PiAzLjJcblx0ICpcblx0ICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcblx0ICogLy8gPT4gNWUtMzI0XG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuXHQgKiAvLyA9PiBJbmZpbml0eVxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKCczLjInKTtcblx0ICogLy8gPT4gMy4yXG5cdCAqL1xuXHRmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIE5BTjtcblx0ICB9XG5cdCAgaWYgKGlzT2JqZWN0JDEodmFsdWUpKSB7XG5cdCAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG5cdCAgICB2YWx1ZSA9IGlzT2JqZWN0JDEob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuXHQgIH1cblx0ICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG5cdCAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcblx0ICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcblx0ICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuXHQgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG5cdH1cblxuXHR2YXIgbG9kYXNoX3Rocm90dGxlID0gdGhyb3R0bGU7XG5cblx0LyoqXG5cdCAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cblx0ICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG5cdCAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuXHQgKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG5cdCAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG5cdCAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuXHQgKi9cblxuXHQvKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xuXHR2YXIgRlVOQ19FUlJPUl9URVhUJDEgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBOQU4kMSA9IDAgLyAwO1xuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHN5bWJvbFRhZyQxID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cblx0LyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cblx0dmFyIHJlVHJpbSQxID0gL15cXHMrfFxccyskL2c7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNCYWRIZXgkMSA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNCaW5hcnkkMSA9IC9eMGJbMDFdKyQvaTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNPY3RhbCQxID0gL14wb1swLTddKyQvaTtcblxuXHQvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuXHR2YXIgZnJlZVBhcnNlSW50JDEgPSBwYXJzZUludDtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuXHR2YXIgZnJlZUdsb2JhbCQxID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG5cdHZhciBmcmVlU2VsZiQxID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cblx0LyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG5cdHZhciByb290JDEgPSBmcmVlR2xvYmFsJDEgfHwgZnJlZVNlbGYkMSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG5cdCAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuXHQgKiBvZiB2YWx1ZXMuXG5cdCAqL1xuXHR2YXIgb2JqZWN0VG9TdHJpbmckMiA9IG9iamVjdFByb3RvJDEudG9TdHJpbmc7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXHR2YXIgbmF0aXZlTWF4JDEgPSBNYXRoLm1heCxcblx0ICAgIG5hdGl2ZU1pbiQxID0gTWF0aC5taW47XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuXHQgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMi40LjBcblx0ICogQGNhdGVnb3J5IERhdGVcblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG5cdCAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcblx0ICogfSwgXy5ub3coKSk7XG5cdCAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG5cdCAqL1xuXHR2YXIgbm93JDEgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gcm9vdCQxLkRhdGUubm93KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuXHQgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcblx0ICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuXHQgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cblx0ICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG5cdCAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcblx0ICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuXHQgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuXHQgKiBpbnZvY2F0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG5cdCAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG5cdCAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cblx0ICpcblx0ICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG5cdCAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cblx0ICpcblx0ICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG5cdCAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuXHQgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cblx0ICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG5cdCAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG5cdCAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG5cdCAqXG5cdCAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuXHQgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG5cdCAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuXHQgKiAgICd0cmFpbGluZyc6IGZhbHNlXG5cdCAqIH0pKTtcblx0ICpcblx0ICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cblx0ICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG5cdCAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcblx0ICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuXHQgKlxuXHQgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuXHQgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcblx0ICovXG5cdGZ1bmN0aW9uIGRlYm91bmNlJDEoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuXHQgIHZhciBsYXN0QXJncyxcblx0ICAgICAgbGFzdFRoaXMsXG5cdCAgICAgIG1heFdhaXQsXG5cdCAgICAgIHJlc3VsdCxcblx0ICAgICAgdGltZXJJZCxcblx0ICAgICAgbGFzdENhbGxUaW1lLFxuXHQgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG5cdCAgICAgIGxlYWRpbmcgPSBmYWxzZSxcblx0ICAgICAgbWF4aW5nID0gZmFsc2UsXG5cdCAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuXHQgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCQxKTtcblx0ICB9XG5cdCAgd2FpdCA9IHRvTnVtYmVyJDEod2FpdCkgfHwgMDtcblx0ICBpZiAoaXNPYmplY3QkMihvcHRpb25zKSkge1xuXHQgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuXHQgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG5cdCAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4JDEodG9OdW1iZXIkMShvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcblx0ICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG5cdCAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuXHQgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuXHQgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcblx0ICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcblx0ICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcblx0ICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG5cdCAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG5cdCAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuXHQgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcblx0ICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuXHQgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuXHQgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcblx0ICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuXHQgICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuXHQgICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbiQxKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG5cdCAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuXHQgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cblx0ICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG5cdCAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuXHQgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuXHQgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcblx0ICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG5cdCAgICB2YXIgdGltZSA9IG5vdyQxKCk7XG5cdCAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG5cdCAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG5cdCAgICB9XG5cdCAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cblx0ICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcblx0ICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cblx0ICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cblx0ICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuXHQgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG5cdCAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuXHQgICAgfVxuXHQgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY2FuY2VsKCkge1xuXHQgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG5cdCAgICB9XG5cdCAgICBsYXN0SW52b2tlVGltZSA9IDA7XG5cdCAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBmbHVzaCgpIHtcblx0ICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93JDEoKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuXHQgICAgdmFyIHRpbWUgPSBub3ckMSgpLFxuXHQgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cblx0ICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuXHQgICAgbGFzdFRoaXMgPSB0aGlzO1xuXHQgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuXHQgICAgaWYgKGlzSW52b2tpbmcpIHtcblx0ICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChtYXhpbmcpIHtcblx0ICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuXHQgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG5cdCAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cdCAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcblx0ICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcblx0ICByZXR1cm4gZGVib3VuY2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuXHQgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG5cdCAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KHt9KTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdChfLm5vb3ApO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3QobnVsbCk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc09iamVjdCQyKHZhbHVlKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcblx0ICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5pc09iamVjdExpa2Uoe30pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICpcblx0ICogXy5pc09iamVjdExpa2UobnVsbCk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc09iamVjdExpa2UkMSh2YWx1ZSkge1xuXHQgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzU3ltYm9sKCdhYmMnKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzU3ltYm9sJDEodmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG5cdCAgICAoaXNPYmplY3RMaWtlJDEodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nJDIuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnJDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy50b051bWJlcigzLjIpO1xuXHQgKiAvLyA9PiAzLjJcblx0ICpcblx0ICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcblx0ICogLy8gPT4gNWUtMzI0XG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuXHQgKiAvLyA9PiBJbmZpbml0eVxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKCczLjInKTtcblx0ICogLy8gPT4gMy4yXG5cdCAqL1xuXHRmdW5jdGlvbiB0b051bWJlciQxKHZhbHVlKSB7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaXNTeW1ib2wkMSh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBOQU4kMTtcblx0ICB9XG5cdCAgaWYgKGlzT2JqZWN0JDIodmFsdWUpKSB7XG5cdCAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG5cdCAgICB2YWx1ZSA9IGlzT2JqZWN0JDIob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuXHQgIH1cblx0ICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltJDEsICcnKTtcblx0ICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5JDEudGVzdCh2YWx1ZSk7XG5cdCAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwkMS50ZXN0KHZhbHVlKSlcblx0ICAgID8gZnJlZVBhcnNlSW50JDEodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG5cdCAgICA6IChyZUlzQmFkSGV4JDEudGVzdCh2YWx1ZSkgPyBOQU4kMSA6ICt2YWx1ZSk7XG5cdH1cblxuXHR2YXIgbG9kYXNoX2RlYm91bmNlID0gZGVib3VuY2UkMTtcblxuXHQvKipcblx0ICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuXHQgKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2Bcblx0ICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG5cdCAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cblx0ICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cblx0ICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG5cdCAqL1xuXG5cdC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG5cdHZhciBGVU5DX0VSUk9SX1RFWFQkMiA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuXHQvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG5cdHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcblx0ICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcblx0ICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG5cdCAqL1xuXHR2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cblx0dmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblx0dmFyIGZyZWVHbG9iYWwkMiA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuXHR2YXIgZnJlZVNlbGYkMiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG5cdC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuXHR2YXIgcm9vdCQyID0gZnJlZUdsb2JhbCQyIHx8IGZyZWVTZWxmJDIgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcblx0ICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuXHQgIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG5cdCAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cblx0ICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cdCAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG5cdCAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG5cdCAgICBvYmplY3RQcm90byQyID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG5cdHZhciBjb3JlSnNEYXRhID0gcm9vdCQyWydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuXHR2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuXHQgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcblx0fSgpKTtcblxuXHQvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG5cdHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICogb2YgdmFsdWVzLlxuXHQgKi9cblx0dmFyIG9iamVjdFRvU3RyaW5nJDMgPSBvYmplY3RQcm90byQyLnRvU3RyaW5nO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG5cdHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG5cdCAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkkMSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuXHQgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuXHQpO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuXHR2YXIgTWFwJDEgPSBnZXROYXRpdmUocm9vdCQyLCAnTWFwJyksXG5cdCAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cblx0ICB0aGlzLmNsZWFyKCk7XG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuXHQgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgY2xlYXJcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICovXG5cdGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcblx0ICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGRlbGV0ZVxuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuXHQgIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGdldFxuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcblx0ICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuXHQgIH1cblx0ICByZXR1cm4gaGFzT3duUHJvcGVydHkkMS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBoYXNcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXHQgIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5JDEuY2FsbChkYXRhLCBrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgc2V0XG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5cdEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuXHRIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuXHRIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuXHRIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuXHRIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG5cdCAgdGhpcy5jbGVhcigpO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcblx0ICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGNsZWFyXG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuXHQgIHRoaXMuX19kYXRhX18gPSBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZGVsZXRlXG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cblx0ICBpZiAoaW5kZXggPCAwKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG5cdCAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuXHQgICAgZGF0YS5wb3AoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuXHQgIH1cblx0ICByZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZ2V0XG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cblx0ICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBoYXNcblx0ICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuXHQgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgc2V0XG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5cdExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcblx0TGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5cdExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuXHRMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcblx0TGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG5cdCAgdGhpcy5jbGVhcigpO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcblx0ICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgY2xlYXJcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuXHQgIHRoaXMuX19kYXRhX18gPSB7XG5cdCAgICAnaGFzaCc6IG5ldyBIYXNoLFxuXHQgICAgJ21hcCc6IG5ldyAoTWFwJDEgfHwgTGlzdENhY2hlKSxcblx0ICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuXHQgIH07XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZGVsZXRlXG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG5cdCAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBnZXRcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcblx0ICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBoYXNcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcblx0ICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBzZXRcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcblx0ICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cblx0TWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcblx0TWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuXHRNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5cdE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcblx0TWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuXHQgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuXHQgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdCAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuXHQgICAgICByZXR1cm4gbGVuZ3RoO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gLTE7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG5cdCAqICBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcblx0ICBpZiAoIWlzT2JqZWN0JDModmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG5cdCAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcblx0ICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcblx0ICByZXR1cm4gaXNLZXlhYmxlKGtleSlcblx0ICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG5cdCAgICA6IGRhdGEubWFwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuXHQgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcblx0ICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcblx0ICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcblx0ICAgIDogKHZhbHVlID09PSBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG5cdCAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cblx0ICovXG5cdGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcblx0ICBpZiAoZnVuYyAhPSBudWxsKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9XG5cdCAgcmV0dXJuICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG5cdCAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcblx0ICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG5cdCAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG5cdCAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG5cdCAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuXHQgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuXHQgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuXHQgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcblx0ICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuXHQgKlxuXHQgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcblx0ICogdmFsdWVzKG9iamVjdCk7XG5cdCAqIC8vID0+IFsxLCAyXVxuXHQgKlxuXHQgKiB2YWx1ZXMob3RoZXIpO1xuXHQgKiAvLyA9PiBbMywgNF1cblx0ICpcblx0ICogb2JqZWN0LmEgPSAyO1xuXHQgKiB2YWx1ZXMob2JqZWN0KTtcblx0ICogLy8gPT4gWzEsIDJdXG5cdCAqXG5cdCAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuXHQgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG5cdCAqIHZhbHVlcyhvYmplY3QpO1xuXHQgKiAvLyA9PiBbJ2EnLCAnYiddXG5cdCAqXG5cdCAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG5cdCAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG5cdCAqL1xuXHRmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG5cdCAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQkMik7XG5cdCAgfVxuXHQgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdCAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG5cdCAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuXHQgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG5cdCAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHQgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcblx0ICByZXR1cm4gbWVtb2l6ZWQ7XG5cdH1cblxuXHQvLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG5cdG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuXHQvKipcblx0ICogUGVyZm9ybXMgYVxuXHQgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuXHQgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cblx0ICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG5cdCAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG5cdCAqXG5cdCAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqXG5cdCAqIF8uZXEoJ2EnLCAnYScpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqXG5cdCAqIF8uZXEoTmFOLCBOYU4pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqL1xuXHRmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcblx0ICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNGdW5jdGlvbihfKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuXHQgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuXHQgIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cblx0ICB2YXIgdGFnID0gaXNPYmplY3QkMyh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZyQzLmNhbGwodmFsdWUpIDogJyc7XG5cdCAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG5cdCAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcblx0ICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3Qoe30pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdChudWxsKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0JDModmFsdWUpIHtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuXHR9XG5cblx0dmFyIGxvZGFzaF9tZW1vaXplID0gbWVtb2l6ZTtcblxuXHQvKipcclxuXHQgKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG5cdCAqXHJcblx0ICogVGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBSZXNpemVPYnNlcnZlclxyXG5cdCAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcblx0ICovXHJcblx0LyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYywgdmFsaWQtanNkb2MgKi9cclxuXHR2YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgcmV0dXJuIE1hcDtcclxuXHQgICAgfVxyXG5cdCAgICAvKipcclxuXHQgICAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuXHQgICAgICogQHBhcmFtIHsqfSBrZXlcclxuXHQgICAgICogQHJldHVybnMge251bWJlcn1cclxuXHQgICAgICovXHJcblx0ICAgIGZ1bmN0aW9uIGdldEluZGV4KGFyciwga2V5KSB7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcblx0ICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcblx0ICAgICAgICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG5cdCAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcblx0ICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuXHQgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuXHQgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcblx0ICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuXHQgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XHJcblx0ICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG5cdCAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuXHQgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG5cdCAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcblx0ICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcblx0ICAgICAgICAgICAgaWYgKGN0eCA9PT0gdm9pZCAwKSB7IGN0eCA9IG51bGw7IH1cclxuXHQgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZW50cnlbMV0sIGVudHJ5WzBdKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcblx0ICAgIH0oKSk7XHJcblx0fSkoKTtcblxuXHQvKipcclxuXHQgKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuXHQgKi9cclxuXHR2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50O1xuXG5cdC8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcblx0dmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5NYXRoID09PSBNYXRoKSB7XHJcblx0ICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoKSB7XHJcblx0ICAgICAgICByZXR1cm4gc2VsZjtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGgpIHtcclxuXHQgICAgICAgIHJldHVybiB3aW5kb3c7XHJcblx0ICAgIH1cclxuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcblx0ICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG5cdH0pKCk7XG5cblx0LyoqXHJcblx0ICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuXHQgKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG5cdCAqL1xyXG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcblx0ICAgICAgICAvLyBhbiBcIkludmFsaWQgY2FsbGluZyBvYmplY3RcIiBlcnJvciBpZiByQUYgaXMgaW52b2tlZCB3aXRob3V0IHRoZSBnbG9iYWxcclxuXHQgICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcblx0ICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcblx0fSkoKTtcblxuXHQvLyBEZWZpbmVzIG1pbmltdW0gdGltZW91dCBiZWZvcmUgYWRkaW5nIGEgdHJhaWxpbmcgY2FsbC5cclxuXHR2YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG5cdCAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdGhyb3R0bGUkMSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcblx0ICAgIHZhciBsZWFkaW5nQ2FsbCA9IGZhbHNlLCB0cmFpbGluZ0NhbGwgPSBmYWxzZSwgbGFzdENhbGxUaW1lID0gMDtcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuXHQgICAgICogdGhlIFwicHJveHlcIiB3YXMgY2FsbGVkIGR1cmluZyBjdXJyZW50IHJlcXVlc3QuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgKi9cclxuXHQgICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcblx0ICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuXHQgICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHJhaWxpbmdDYWxsKSB7XHJcblx0ICAgICAgICAgICAgcHJveHkoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICAvKipcclxuXHQgICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuXHQgICAgICogaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGVsZWdhdGluZyBpdCB0byB0aGVcclxuXHQgICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuXHQgICAgICovXHJcblx0ICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuXHQgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxKHJlc29sdmVQZW5kaW5nKTtcclxuXHQgICAgfVxyXG5cdCAgICAvKipcclxuXHQgICAgICogU2NoZWR1bGVzIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuXHQgICAgICovXHJcblx0ICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG5cdCAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcblx0ICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuXHQgICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG5cdCAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG5cdCAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBcInRyYW5zaXRpb25zXCIgd2hpY2ggbmV2ZXIgYWN0dWFsbHkgc3RhcnRcclxuXHQgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG5cdCAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuXHQgICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHByb3h5O1xyXG5cdH1cblxuXHQvLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxuXHR2YXIgUkVGUkVTSF9ERUxBWSA9IDIwO1xyXG5cdC8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcblx0Ly8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcblx0dmFyIHRyYW5zaXRpb25LZXlzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3NpemUnLCAnd2VpZ2h0J107XHJcblx0Ly8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcblx0dmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcblx0LyoqXHJcblx0ICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuXHQgKi9cclxuXHR2YXIgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAvKipcclxuXHQgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwcml2YXRlXHJcblx0ICAgICAqL1xyXG5cdCAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHRoaXMub2JzZXJ2ZXJzXyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcblx0ICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSQxKHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpLCBSRUZSRVNIX0RFTEFZKTtcclxuXHQgICAgfVxyXG5cdCAgICAvKipcclxuXHQgICAgICogQWRkcyBvYnNlcnZlciB0byBvYnNlcnZlcnMgbGlzdC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuXHQgICAgICogQHJldHVybnMge3ZvaWR9XHJcblx0ICAgICAqL1xyXG5cdCAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcblx0ICAgICAgICBpZiAoIX50aGlzLm9ic2VydmVyc18uaW5kZXhPZihvYnNlcnZlcikpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBBZGQgbGlzdGVuZXJzIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGFkZGVkIHlldC5cclxuXHQgICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvKipcclxuXHQgICAgICogUmVtb3ZlcyBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcblx0ICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG5cdCAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXztcclxuXHQgICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuXHQgICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcblx0ICAgICAgICBpZiAofmluZGV4KSB7XHJcblx0ICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIGlmIGNvbnRyb2xsZXIgaGFzIG5vIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcblx0ICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvKipcclxuXHQgICAgICogSW52b2tlcyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy4gSXQgd2lsbCBjb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaW5zb2ZhclxyXG5cdCAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoYW5nZXNEZXRlY3RlZCA9IHRoaXMudXBkYXRlT2JzZXJ2ZXJzXygpO1xyXG5cdCAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcblx0ICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG5cdCAgICAgICAgaWYgKGNoYW5nZXNEZXRlY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvKipcclxuXHQgICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG5cdCAgICAgKiBlbnRyaWVzLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcHJpdmF0ZVxyXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBcInRydWVcIiBpZiBhbnkgb2JzZXJ2ZXIgaGFzIGRldGVjdGVkIGNoYW5nZXMgaW5cclxuXHQgICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcblx0ICAgICAqL1xyXG5cdCAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc18gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuXHQgICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5nYXRoZXJBY3RpdmUoKSwgb2JzZXJ2ZXIuaGFzQWN0aXZlKCk7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG5cdCAgICAgICAgLy8gY29sbGlzaW9ucyBiZXR3ZWVuIG9ic2VydmVycywgZS5nLiB3aGVuIG11bHRpcGxlIGluc3RhbmNlcyBvZlxyXG5cdCAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuXHQgICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcblx0ICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbm90aWZpY2F0aW9ucyBiZWluZyBibG9ja2VkIGZvciB0aGUgcmVzdCBvZiBvYnNlcnZlcnMuXHJcblx0ICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuXHQgICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuXHQgICAgfTtcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwcml2YXRlXHJcblx0ICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG5cdCAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgYWRkZWQuXHJcblx0ICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuXHQgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG5cdCAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG5cdCAgICAgICAgLy8gZmluYWwgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuXHQgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG5cdCAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcblx0ICAgICAgICBpZiAobXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuXHQgICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcblx0ICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuXHQgICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcblx0ICAgIH07XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwcml2YXRlXHJcblx0ICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5kaXNjb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG5cdCAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuXHQgICAgICAgIGlmICghaXNCcm93c2VyIHx8ICF0aGlzLmNvbm5lY3RlZF8pIHtcclxuXHQgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuXHQgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8uZGlzY29ubmVjdCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuXHQgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcblx0ICAgIH07XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcHJpdmF0ZVxyXG5cdCAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuXHQgICAgICogQHJldHVybnMge3ZvaWR9XHJcblx0ICAgICAqL1xyXG5cdCAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuXHQgICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcblx0ICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciB0cmFuc2l0aW9uIG1heSBhZmZlY3QgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50LlxyXG5cdCAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgdGhlIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuXHQgICAgICpcclxuXHQgICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuXHQgICAgICovXHJcblx0ICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLmluc3RhbmNlXyA9IG5ldyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuXHQgICAgfTtcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmluc3RhbmNlXyA9IG51bGw7XHJcblx0ICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcblx0fSgpKTtcblxuXHQvKipcclxuXHQgKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IGZvciB3aGljaCB0byBkZWZpbmUgcHJvcGVydGllcy5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcblx0ICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuXHQgKi9cclxuXHR2YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcblx0ICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcblx0ICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcblx0ICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRhcmdldDtcclxuXHR9KTtcblxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XHJcblx0ICovXHJcblx0dmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHQgICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG5cdCAgICAvLyBoYXMgdGhlIFwib3duZXJEb2N1bWVudFwiIHByb3BlcnR5IGZyb20gd2hpY2ggd2UgY2FuIHJldHJpZXZlIGFcclxuXHQgICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG5cdCAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcblx0ICAgIC8vIFJldHVybiB0aGUgbG9jYWwgZ2xvYmFsIG9iamVjdCBpZiBpdCdzIG5vdCBwb3NzaWJsZSBleHRyYWN0IG9uZSBmcm9tXHJcblx0ICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcblx0ICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxuXHR9KTtcblxuXHQvLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxuXHR2YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xyXG5cdCAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxuXHR9XHJcblx0LyoqXHJcblx0ICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuXHQgKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG5cdCAgICB2YXIgcG9zaXRpb25zID0gW107XHJcblx0ICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcblx0ICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBvc2l0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcblx0ICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG5cdCAgICB9LCAwKTtcclxuXHR9XHJcblx0LyoqXHJcblx0ICogRXh0cmFjdHMgcGFkZGluZ3Mgc2l6ZXMgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFBhZGRpbmdzIGJveC5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuXHQgICAgdmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XHJcblx0ICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG5cdCAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG5cdCAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zXzFbX2ldO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcblx0ICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gcGFkZGluZ3M7XHJcblx0fVxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1NWR0dyYXBoaWNzRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkc1xyXG5cdCAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuXHQgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcblx0ICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuXHQgICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcclxuXHR9XHJcblx0LyoqXHJcblx0ICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBIVE1MRWxlbWVudC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcblx0ICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcblx0ICAgIC8vIENsaWVudCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGNhbid0IGJlXHJcblx0ICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG5cdCAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcblx0ICAgIC8vIEJ5IHRoaXMgY29uZGl0aW9uIHdlIGNhbiBjYXRjaCBhbGwgbm9uLXJlcGxhY2VkIGlubGluZSwgaGlkZGVuIGFuZFxyXG5cdCAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcblx0ICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG5cdCAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcblx0ICAgIC8vIGVmZmVjdGl2ZSB0ZXN0IGZvciBoaWRkZW4gZWxlbWVudHMuIEUuZy4gZXZlbiBqUXVlcnkncyAnOnZpc2libGUnIGZpbHRlclxyXG5cdCAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcblx0ICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG5cdCAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcblx0ICAgIHZhciBwYWRkaW5ncyA9IGdldFBhZGRpbmdzKHN0eWxlcyk7XHJcblx0ICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuXHQgICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcblx0ICAgIC8vIENvbXB1dGVkIHN0eWxlcyBvZiB3aWR0aCAmIGhlaWdodCBhcmUgYmVpbmcgdXNlZCBiZWNhdXNlIHRoZXkgYXJlIHRoZVxyXG5cdCAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcblx0ICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuXHQgICAgLy8gYWZmZWN0ZWQgYnkgQ1NTIHRyYW5zZm9ybWF0aW9ucyBsZXQgYWxvbmUgcGFkZGluZ3MsIGJvcmRlcnMgYW5kIHNjcm9sbCBiYXJzLlxyXG5cdCAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcblx0ICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG5cdCAgICAvLyBtb2RlbCBpcyBhcHBsaWVkIChleGNlcHQgZm9yIElFKS5cclxuXHQgICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG5cdCAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG5cdCAgICAgICAgLy8gZG9lc24ndCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHRvIGNvbXB1dGVkIENTUyBkaW1lbnNpb25zLlxyXG5cdCAgICAgICAgLy9cclxuXHQgICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG5cdCAgICAgICAgLy8gcHJvcGVydGllcyB0aGVuIGl0J3MgZWl0aGVyIElFLCBhbmQgdGh1cyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0XHJcblx0ICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG5cdCAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcblx0ICAgICAgICAgICAgd2lkdGggLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAnbGVmdCcsICdyaWdodCcpICsgaG9yaXpQYWQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcblx0ICAgICAgICAgICAgaGVpZ2h0IC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3RvcCcsICdib3R0b20nKSArIHZlcnRQYWQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgLy8gRm9sbG93aW5nIHN0ZXBzIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50J3Mgcm9vdCBlbGVtZW50IGFzIGl0c1xyXG5cdCAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcblx0ICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcblx0ICAgIC8vIHJlbmRlcmVkIHNjcm9sbCBiYXJzIG5vciBpdCBjYW4gYmUgY2xpcHBlZC5cclxuXHQgICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcblx0ICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuXHQgICAgICAgIC8vIGluY2x1ZGUgc2Nyb2xsIGJhcnMgc2l6ZSB3aGljaCBjYW4gYmUgcmVtb3ZlZCBhdCB0aGlzIHN0ZXAgYXMgc2Nyb2xsXHJcblx0ICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuXHQgICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcblx0ICAgICAgICB2YXIgdmVydFNjcm9sbGJhciA9IE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgLSBjbGllbnRXaWR0aDtcclxuXHQgICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcblx0ICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuXHQgICAgICAgIC8vIEUuZy4gZm9yIGFuIGVsZW1lbnQgd2l0aCBjb250ZW50IHdpZHRoIG9mIDMxNC4ycHggaXQgc29tZXRpbWVzIGdpdmVzXHJcblx0ICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuXHQgICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcblx0ICAgICAgICAvLyBhcyBhIG5vbi1yZWxldmFudC5cclxuXHQgICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG5cdCAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcblx0ICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG5cdH1cclxuXHQvKipcclxuXHQgKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHR2YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG5cdCAgICAvLyBpbnRlcmZhY2UuXHJcblx0ICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG5cdCAgICB9XHJcblx0ICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG5cdCAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXHJcblx0ICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcblx0ICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG5cdH0pKCk7XHJcblx0LyoqXHJcblx0ICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuXHQgICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0fVxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuXHQgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcblx0ICAgIGlmICghaXNCcm93c2VyKSB7XHJcblx0ICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcblx0ICAgICAgICByZXR1cm4gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG5cdH1cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG5cdCAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkb21yZWN0cmVhZG9ubHlcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG5cdCAqIEByZXR1cm5zIHtET01SZWN0UmVhZE9ubHl9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcblx0ICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuXHQgICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcblx0ICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuXHQgICAgdmFyIHJlY3QgPSBPYmplY3QuY3JlYXRlKENvbnN0ci5wcm90b3R5cGUpO1xyXG5cdCAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG5cdCAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG5cdCAgICAgICAgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCxcclxuXHQgICAgICAgIHRvcDogeSxcclxuXHQgICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcblx0ICAgICAgICBib3R0b206IGhlaWdodCArIHksXHJcblx0ICAgICAgICBsZWZ0OiB4XHJcblx0ICAgIH0pO1xyXG5cdCAgICByZXR1cm4gcmVjdDtcclxuXHR9XHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBET01SZWN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMgYW5kIHRoZSB4L3kgY29vcmRpbmF0ZXMuXHJcblx0ICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBSZWN0YW5nbGUncyBoZWlnaHQuXHJcblx0ICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGNyZWF0ZVJlY3RJbml0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuXHQgICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cdH1cblxuXHQvKipcclxuXHQgKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcblx0ICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuXHQgKi9cclxuXHR2YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmF0aW9uLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcblx0ICAgICAqL1xyXG5cdCAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQnJvYWRjYXN0ZWQgd2lkdGggb2YgY29udGVudCByZWN0YW5nbGUuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIEJyb2FkY2FzdGVkIGhlaWdodCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcblx0ICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuXHQgICAgfVxyXG5cdCAgICAvKipcclxuXHQgICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcblx0ICAgICAqIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBicm9hZGNhc3QuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XHJcblx0ICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuXHQgICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvKipcclxuXHQgICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcblx0ICAgICAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuXHQgICAgICpcclxuXHQgICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG5cdCAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IHJlY3Qud2lkdGg7XHJcblx0ICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG5cdCAgICAgICAgcmV0dXJuIHJlY3Q7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxuXHR9KCkpO1xuXG5cdHZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAvKipcclxuXHQgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuXHQgICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcblx0ICAgICAqL1xyXG5cdCAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuXHQgICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcblx0ICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb24gZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZVxyXG5cdCAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcblx0ICAgICAgICAvL1xyXG5cdCAgICAgICAgLy8gUHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgYmVpbmcgdXNlZCBhcyB0aGV5J2QgcmVxdWlyZSB0byBkZWZpbmUgYVxyXG5cdCAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcblx0ICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuXHQgICAgICAgIGRlZmluZUNvbmZpZ3VyYWJsZSh0aGlzLCB7IHRhcmdldDogdGFyZ2V0LCBjb250ZW50UmVjdDogY29udGVudFJlY3QgfSk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcblx0fSgpKTtcblxuXHR2YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcblx0ICAgICAqICAgICAgd2hlbiBvbmUgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZXMgaXQncyBjb250ZW50IGRpbWVuc2lvbnMuXHJcblx0ICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG5cdCAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuXHQgICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gY2FsbGJhY2tDdHggLSBSZWZlcmVuY2UgdG8gdGhlIHB1YmxpY1xyXG5cdCAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG5cdCAgICAgKi9cclxuXHQgICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIGNhbGxiYWNrQ3R4KSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcblx0ICAgICAgICAgKiBvZiBlbGVtZW50cy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogUmVnaXN0cnkgb2YgdGhlIFJlc2l6ZU9ic2VydmF0aW9uIGluc3RhbmNlcy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuXHQgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG5cdCAgICAgICAgdGhpcy5jb250cm9sbGVyXyA9IGNvbnRyb2xsZXI7XHJcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG5cdCAgICB9XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuXHQgICAgICogQHJldHVybnMge3ZvaWR9XHJcblx0ICAgICAqL1xyXG5cdCAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHQgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuXHQgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLlxyXG5cdCAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG5cdCAgICAgICAgLy8gRm9yY2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZhdGlvbnMuXHJcblx0ICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuXHQgICAgfTtcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXHJcblx0ICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHQgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuXHQgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBub3QgYmVpbmcgb2JzZXJ2ZWQuXHJcblx0ICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuXHQgICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvKipcclxuXHQgICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuXHQgICAgICpcclxuXHQgICAgICogQHJldHVybnMge3ZvaWR9XHJcblx0ICAgICAqL1xyXG5cdCAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuXHQgICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG5cdCAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuXHQgICAgfTtcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcblx0ICAgICAqIGl0J3MgY29udGVudCByZWN0YW5nbGUuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG5cdCAgICAgKi9cclxuXHQgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblx0ICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcblx0ICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuXHQgICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnB1c2gob2JzZXJ2YXRpb24pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvKipcclxuXHQgICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuXHQgICAgICogaW5zdGFuY2VzIGNvbGxlY3RlZCBmcm9tIGFjdGl2ZSByZXNpemUgb2JzZXJ2YXRpb25zLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuXHQgICAgICovXHJcblx0ICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG5cdCAgICAgICAgaWYgKCF0aGlzLmhhc0FjdGl2ZSgpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FsbGJhY2tDdHhfO1xyXG5cdCAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuXHQgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob2JzZXJ2YXRpb24udGFyZ2V0LCBvYnNlcnZhdGlvbi5icm9hZGNhc3RSZWN0KCkpO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuXHQgICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuXHQgICAgfTtcclxuXHQgICAgLyoqXHJcblx0ICAgICAqIENsZWFycyB0aGUgY29sbGVjdGlvbiBvZiBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuXHQgICAgICovXHJcblx0ICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgICAgICovXHJcblx0ICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5oYXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBSZXNpemVPYnNlcnZlclNQSTtcclxuXHR9KCkpO1xuXG5cdC8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuXHQvLyBmb3IgdGhlIE1hcCBjb2xsZWN0aW9uIGFzIGl0IGhhcyBhbGwgcmVxdWlyZWQgbWV0aG9kcyBhbmQgYmVjYXVzZSBXZWFrTWFwXHJcblx0Ly8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcblx0dmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG5cdC8qKlxyXG5cdCAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuXHQgKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuXHQgKi9cclxuXHR2YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuXHQgICAgICogICAgICBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2UuXHJcblx0ICAgICAqL1xyXG5cdCAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG5cdCAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc2l6ZU9ic2VydmVyKSkge1xyXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjb250cm9sbGVyID0gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcblx0ICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG5cdCAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG5cdH0oKSk7XHJcblx0Ly8gRXhwb3NlIHB1YmxpYyBtZXRob2RzIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG5cdFtcclxuXHQgICAgJ29ic2VydmUnLFxyXG5cdCAgICAndW5vYnNlcnZlJyxcclxuXHQgICAgJ2Rpc2Nvbm5lY3QnXHJcblx0XS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuXHQgICAgUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgX2E7XHJcblx0ICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuXHQgICAgfTtcclxuXHR9KTtcblxuXHR2YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAvLyBFeHBvcnQgZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gaWYgYXZhaWxhYmxlLlxyXG5cdCAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxuXHR9KSgpO1xuXG5cdHZhciBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IG51bGw7XG5cdHZhciBjYWNoZWREZXZpY2VQaXhlbFJhdGlvID0gbnVsbDtcblxuXHRpZiAoY2FuVXNlRG9tKSB7XG5cdCAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChjYWNoZWREZXZpY2VQaXhlbFJhdGlvICE9PSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuXHQgICAgICBjYWNoZWREZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cdCAgICAgIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gbnVsbDtcblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjcm9sbGJhcldpZHRoKCkge1xuXHQgIGlmIChjYWNoZWRTY3JvbGxiYXJXaWR0aCA9PT0gbnVsbCkge1xuXHQgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSAwO1xuXHQgICAgICByZXR1cm4gY2FjaGVkU2Nyb2xsYmFyV2lkdGg7XG5cdCAgICB9XG5cblx0ICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0ICAgIHZhciBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICAgIGJveC5jbGFzc0xpc3QuYWRkKCdzaW1wbGViYXItaGlkZS1zY3JvbGxiYXInKTtcblx0ICAgIGJvZHkuYXBwZW5kQ2hpbGQoYm94KTtcblx0ICAgIHZhciB3aWR0aCA9IGJveC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodDtcblx0ICAgIGJvZHkucmVtb3ZlQ2hpbGQoYm94KTtcblx0ICAgIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gd2lkdGg7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xuXHR9XG5cblx0Ly8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXHR2YXIgY3JlYXRlTWV0aG9kJDQgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuXHQgICAgYUZ1bmN0aW9uJDEoY2FsbGJhY2tmbik7XG5cdCAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuXHQgICAgdmFyIHNlbGYgPSBpbmRleGVkT2JqZWN0KE8pO1xuXHQgICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcblx0ICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG5cdCAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuXHQgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG5cdCAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuXHQgICAgICAgIGluZGV4ICs9IGk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgaW5kZXggKz0gaTtcblx0ICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG5cdCAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZvciAoO0lTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuXHQgICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG1lbW87XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgYXJyYXlSZWR1Y2UgPSB7XG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2Vcblx0ICBsZWZ0OiBjcmVhdGVNZXRob2QkNChmYWxzZSksXG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG5cdCAgcmlnaHQ6IGNyZWF0ZU1ldGhvZCQ0KHRydWUpXG5cdH07XG5cblx0dmFyICRyZWR1Y2UgPSBhcnJheVJlZHVjZS5sZWZ0O1xuXG5cblx0Ly8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IHNsb3BweUFycmF5TWV0aG9kKCdyZWR1Y2UnKSB9LCB7XG5cdCAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuXHQgICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG5cdHZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblx0dmFyIEZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmcgPSBGdW5jdGlvblByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcblx0dmFyIE5BTUUgPSAnbmFtZSc7XG5cblx0Ly8gRnVuY3Rpb24gaW5zdGFuY2VzIGAubmFtZWAgcHJvcGVydHlcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnVuY3Rpb24taW5zdGFuY2VzLW5hbWVcblx0aWYgKGRlc2NyaXB0b3JzICYmICEoTkFNRSBpbiBGdW5jdGlvblByb3RvdHlwZSkpIHtcblx0ICBkZWZpbmVQcm9wZXJ0eSQxKEZ1bmN0aW9uUHJvdG90eXBlLCBOQU1FLCB7XG5cdCAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZy5jYWxsKHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG5cdCAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgcmV0dXJuICcnO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblxuXHQvLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5cdHZhciByZWdleHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuXHQgIHZhciByZXN1bHQgPSAnJztcblx0ICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG5cdCAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcblx0ICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG5cdCAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuXHQgIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG5cdCAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0dmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG5cdC8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuXHQvLyBTdHJpbmcjcmVwbGFjZSBwb2x5ZmlsbCB1c2VzIC4vZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyxcblx0Ly8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxuXHR2YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxuXHR2YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xuXG5cdHZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuXHQgIHZhciByZTEgPSAvYS87XG5cdCAgdmFyIHJlMiA9IC9iKi9nO1xuXHQgIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG5cdCAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcblx0ICByZXR1cm4gcmUxLmxhc3RJbmRleCAhPT0gMCB8fCByZTIubGFzdEluZGV4ICE9PSAwO1xuXHR9KSgpO1xuXG5cdC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cblx0dmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxuXHR2YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuXHRpZiAoUEFUQ0gpIHtcblx0ICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyKSB7XG5cdCAgICB2YXIgcmUgPSB0aGlzO1xuXHQgICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcblxuXHQgICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcblx0ICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcblx0ICAgIH1cblx0ICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcblxuXHQgICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwocmUsIHN0cik7XG5cblx0ICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcblx0ICAgICAgcmUubGFzdEluZGV4ID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG5cdCAgICB9XG5cdCAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG5cdCAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG5cdCAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuXHQgICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtYXRjaDtcblx0ICB9O1xuXHR9XG5cblx0dmFyIHJlZ2V4cEV4ZWMgPSBwYXRjaGVkRXhlYztcblxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IHJlZ2V4cEV4ZWMgfSwge1xuXHQgIGV4ZWM6IHJlZ2V4cEV4ZWNcblx0fSk7XG5cblx0dmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5cdHZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gI3JlcGxhY2UgbmVlZHMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgbmFtZWQgZ3JvdXBzLlxuXHQgIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcblx0ICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cblx0ICB2YXIgcmUgPSAvLi87XG5cdCAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHQgIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG5cdH0pO1xuXG5cdC8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuXHQvLyBXZWV4IEpTIGhhcyBmcm96ZW4gYnVpbHQtaW4gcHJvdG90eXBlcywgc28gdXNlIHRyeSAvIGNhdGNoIHdyYXBwZXJcblx0dmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHJlID0gLyg/OikvO1xuXHQgIHZhciBvcmlnaW5hbEV4ZWMgPSByZS5leGVjO1xuXHQgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcblx0ICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG5cdCAgcmV0dXJuIHJlc3VsdC5sZW5ndGggIT09IDIgfHwgcmVzdWx0WzBdICE9PSAnYScgfHwgcmVzdWx0WzFdICE9PSAnYic7XG5cdH0pO1xuXG5cdHZhciBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYywgc2hhbSkge1xuXHQgIHZhciBTWU1CT0wgPSB3ZWxsS25vd25TeW1ib2woS0VZKTtcblxuXHQgIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcblx0ICAgIHZhciBPID0ge307XG5cdCAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuXHQgICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcblx0ICB9KTtcblxuXHQgIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG5cdCAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuXHQgICAgdmFyIHJlID0gL2EvO1xuXHQgICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuXG5cdCAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG5cdCAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG5cdCAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cblx0ICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcblx0ICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFUyQyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuXHQgICAgfVxuXG5cdCAgICByZVtTWU1CT0xdKCcnKTtcblx0ICAgIHJldHVybiAhZXhlY0NhbGxlZDtcblx0ICB9KTtcblxuXHQgIGlmIChcblx0ICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG5cdCAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcblx0ICAgIChLRVkgPT09ICdyZXBsYWNlJyAmJiAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMpIHx8XG5cdCAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG5cdCAgKSB7XG5cdCAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG5cdCAgICB2YXIgbWV0aG9kcyA9IGV4ZWMoU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiAobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcblx0ICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG5cdCAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG5cdCAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcblx0ICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cblx0ICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG5cdCAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuXHQgICAgfSk7XG5cdCAgICB2YXIgc3RyaW5nTWV0aG9kID0gbWV0aG9kc1swXTtcblx0ICAgIHZhciByZWdleE1ldGhvZCA9IG1ldGhvZHNbMV07XG5cblx0ICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyaW5nTWV0aG9kKTtcblx0ICAgIHJlZGVmaW5lKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcblx0ICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuXHQgICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuXHQgICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcmVnZXhNZXRob2QuY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cblx0ICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG5cdCAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcblx0ICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcyk7IH1cblx0ICAgICk7XG5cdCAgICBpZiAoc2hhbSkgaGlkZShSZWdFeHAucHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBjaGFyQXQkMSA9IHN0cmluZ011bHRpYnl0ZS5jaGFyQXQ7XG5cblx0Ly8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxuXHR2YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG5cdCAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQkMShTLCBpbmRleCkubGVuZ3RoIDogMSk7XG5cdH07XG5cblx0Ly8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5cdHZhciByZWdleHBFeGVjQWJzdHJhY3QgPSBmdW5jdGlvbiAoUiwgUykge1xuXHQgIHZhciBleGVjID0gUi5leGVjO1xuXHQgIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcblx0ICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCBleGVjIG1ldGhvZCByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBPYmplY3Qgb3IgbnVsbCcpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cblx0ICBpZiAoY2xhc3NvZlJhdyhSKSAhPT0gJ1JlZ0V4cCcpIHtcblx0ICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuXHQgIH1cblxuXHQgIHJldHVybiByZWdleHBFeGVjLmNhbGwoUiwgUyk7XG5cdH07XG5cblx0Ly8gQEBtYXRjaCBsb2dpY1xuXHRmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYygnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoTUFUQ0gsIG5hdGl2ZU1hdGNoLCBtYXliZUNhbGxOYXRpdmUpIHtcblx0ICByZXR1cm4gW1xuXHQgICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5tYXRjaFxuXHQgICAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG5cdCAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcblx0ICAgICAgdmFyIG1hdGNoZXIgPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcblx0ICAgICAgcmV0dXJuIG1hdGNoZXIgIT09IHVuZGVmaW5lZCA/IG1hdGNoZXIuY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuXHQgICAgfSxcblx0ICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdYCBtZXRob2Rcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuXHQgICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuXHQgICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1hdGNoLCByZWdleHAsIHRoaXMpO1xuXHQgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cblx0ICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcblx0ICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG5cblx0ICAgICAgaWYgKCFyeC5nbG9iYWwpIHJldHVybiByZWdleHBFeGVjQWJzdHJhY3QocngsIFMpO1xuXG5cdCAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG5cdCAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG5cdCAgICAgIHZhciBBID0gW107XG5cdCAgICAgIHZhciBuID0gMDtcblx0ICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWdleHBFeGVjQWJzdHJhY3QocngsIFMpKSAhPT0gbnVsbCkge1xuXHQgICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuXHQgICAgICAgIEFbbl0gPSBtYXRjaFN0cjtcblx0ICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuXHQgICAgICAgIG4rKztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbiA9PT0gMCA/IG51bGwgOiBBO1xuXHQgICAgfVxuXHQgIF07XG5cdH0pO1xuXG5cdHZhciBtYXgkMSA9IE1hdGgubWF4O1xuXHR2YXIgbWluJDIgPSBNYXRoLm1pbjtcblx0dmFyIGZsb29yJDEgPSBNYXRoLmZsb29yO1xuXHR2YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJidgXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG5cdHZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmJ2BdfFxcZFxcZD8pL2c7XG5cblx0dmFyIG1heWJlVG9TdHJpbmcgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcblx0fTtcblxuXHQvLyBAQHJlcGxhY2UgbG9naWNcblx0Zml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoUkVQTEFDRSwgbmF0aXZlUmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlKSB7XG5cdCAgcmV0dXJuIFtcblx0ICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG5cdCAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcblx0ICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuXHQgICAgICB2YXIgcmVwbGFjZXIgPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcblx0ICAgICAgcmV0dXJuIHJlcGxhY2VyICE9PSB1bmRlZmluZWRcblx0ICAgICAgICA/IHJlcGxhY2VyLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcblx0ICAgICAgICA6IG5hdGl2ZVJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuXHQgICAgfSxcblx0ICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV1gIG1ldGhvZFxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2Vcblx0ICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuXHQgICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcblx0ICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG5cdCAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG5cdCAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuXG5cdCAgICAgIHZhciBmdW5jdGlvbmFsUmVwbGFjZSA9IHR5cGVvZiByZXBsYWNlVmFsdWUgPT09ICdmdW5jdGlvbic7XG5cdCAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG5cdCAgICAgIHZhciBnbG9iYWwgPSByeC5nbG9iYWw7XG5cdCAgICAgIGlmIChnbG9iYWwpIHtcblx0ICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuXHQgICAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gcmVnZXhwRXhlY0Fic3RyYWN0KHJ4LCBTKTtcblx0ICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSBicmVhaztcblxuXHQgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuXHQgICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuXHQgICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuXHQgICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgYWNjdW11bGF0ZWRSZXN1bHQgPSAnJztcblx0ICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV07XG5cblx0ICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuXHQgICAgICAgIHZhciBwb3NpdGlvbiA9IG1heCQxKG1pbiQyKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuXHQgICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuXHQgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuXHQgICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG5cdCAgICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG5cdCAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuXHQgICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIGNhcHR1cmVzLnB1c2gobWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcblx0ICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG5cdCAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG5cdCAgICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gW21hdGNoZWRdLmNvbmNhdChjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xuXHQgICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG5cdCAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuXHQgICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuXHQgICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuXHQgICAgfVxuXHQgIF07XG5cblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cblx0ICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG5cdCAgICB2YXIgdGFpbFBvcyA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG5cdCAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcblx0ICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG5cdCAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcblx0ICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5hdGl2ZVJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuXHQgICAgICB2YXIgY2FwdHVyZTtcblx0ICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcblx0ICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcblx0ICAgICAgICBjYXNlICcmJzogcmV0dXJuIG1hdGNoZWQ7XG5cdCAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuXHQgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG5cdCAgICAgICAgY2FzZSAnPCc6XG5cdCAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDogLy8gXFxkXFxkP1xuXHQgICAgICAgICAgdmFyIG4gPSArY2g7XG5cdCAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuXHQgICAgICAgICAgaWYgKG4gPiBtKSB7XG5cdCAgICAgICAgICAgIHZhciBmID0gZmxvb3IkMShuIC8gMTApO1xuXHQgICAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuXHQgICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG5cdCAgICAgICAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcblx0ICAgIH0pO1xuXHQgIH1cblx0fSk7XG5cblx0Ly8gSGVscGVyIGZ1bmN0aW9uIHRvIHJldHJpZXZlIG9wdGlvbnMgZnJvbSBlbGVtZW50IGF0dHJpYnV0ZXNcblx0dmFyIGdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zKG9iaikge1xuXHQgIHZhciBvcHRpb25zID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKG9iaiwgZnVuY3Rpb24gKGFjYywgYXR0cmlidXRlKSB7XG5cdCAgICB2YXIgb3B0aW9uID0gYXR0cmlidXRlLm5hbWUubWF0Y2goL2RhdGEtc2ltcGxlYmFyLSguKykvKTtcblxuXHQgICAgaWYgKG9wdGlvbikge1xuXHQgICAgICB2YXIga2V5ID0gb3B0aW9uWzFdLnJlcGxhY2UoL1xcVysoLikvZywgZnVuY3Rpb24gKHgsIGNocikge1xuXHQgICAgICAgIHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0ICAgICAgfSk7XG5cblx0ICAgICAgc3dpdGNoIChhdHRyaWJ1dGUudmFsdWUpIHtcblx0ICAgICAgICBjYXNlICd0cnVlJzpcblx0ICAgICAgICAgIGFjY1trZXldID0gdHJ1ZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSAnZmFsc2UnOlxuXHQgICAgICAgICAgYWNjW2tleV0gPSBmYWxzZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG5cdCAgICAgICAgICBhY2Nba2V5XSA9IHRydWU7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICBhY2Nba2V5XSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYWNjO1xuXHQgIH0sIHt9KTtcblx0ICByZXR1cm4gb3B0aW9ucztcblx0fTtcblx0ZnVuY3Rpb24gZ2V0RWxlbWVudFdpbmRvdyhlbGVtZW50KSB7XG5cdCAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgIWVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuXHQgICAgcmV0dXJuIHdpbmRvdztcblx0ICB9XG5cblx0ICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHR9XG5cdGZ1bmN0aW9uIGdldEVsZW1lbnREb2N1bWVudChlbGVtZW50KSB7XG5cdCAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lm93bmVyRG9jdW1lbnQpIHtcblx0ICAgIHJldHVybiBkb2N1bWVudDtcblx0ICB9XG5cblx0ICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50O1xuXHR9XG5cblx0dmFyIFNpbXBsZUJhciA9XG5cdC8qI19fUFVSRV9fKi9cblx0ZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIFNpbXBsZUJhcihlbGVtZW50LCBvcHRpb25zKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICB0aGlzLm9uU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KF90aGlzLmVsKTtcblxuXHQgICAgICBpZiAoIV90aGlzLnNjcm9sbFhUaWNraW5nKSB7XG5cdCAgICAgICAgZWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnNjcm9sbFgpO1xuXHQgICAgICAgIF90aGlzLnNjcm9sbFhUaWNraW5nID0gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghX3RoaXMuc2Nyb2xsWVRpY2tpbmcpIHtcblx0ICAgICAgICBlbFdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuc2Nyb2xsWSk7XG5cdCAgICAgICAgX3RoaXMuc2Nyb2xsWVRpY2tpbmcgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLnNjcm9sbFggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChfdGhpcy5heGlzLnguaXNPdmVyZmxvd2luZykge1xuXHQgICAgICAgIF90aGlzLnNob3dTY3JvbGxiYXIoJ3gnKTtcblxuXHQgICAgICAgIF90aGlzLnBvc2l0aW9uU2Nyb2xsYmFyKCd4Jyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBfdGhpcy5zY3JvbGxYVGlja2luZyA9IGZhbHNlO1xuXHQgICAgfTtcblxuXHQgICAgdGhpcy5zY3JvbGxZID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoX3RoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcpIHtcblx0ICAgICAgICBfdGhpcy5zaG93U2Nyb2xsYmFyKCd5Jyk7XG5cblx0ICAgICAgICBfdGhpcy5wb3NpdGlvblNjcm9sbGJhcigneScpO1xuXHQgICAgICB9XG5cblx0ICAgICAgX3RoaXMuc2Nyb2xsWVRpY2tpbmcgPSBmYWxzZTtcblx0ICAgIH07XG5cblx0ICAgIHRoaXMub25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBfdGhpcy5zaG93U2Nyb2xsYmFyKCd4Jyk7XG5cblx0ICAgICAgX3RoaXMuc2hvd1Njcm9sbGJhcigneScpO1xuXHQgICAgfTtcblxuXHQgICAgdGhpcy5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIF90aGlzLm1vdXNlWCA9IGUuY2xpZW50WDtcblx0ICAgICAgX3RoaXMubW91c2VZID0gZS5jbGllbnRZO1xuXG5cdCAgICAgIGlmIChfdGhpcy5heGlzLnguaXNPdmVyZmxvd2luZyB8fCBfdGhpcy5heGlzLnguZm9yY2VWaXNpYmxlKSB7XG5cdCAgICAgICAgX3RoaXMub25Nb3VzZU1vdmVGb3JBeGlzKCd4Jyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoX3RoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgfHwgX3RoaXMuYXhpcy55LmZvcmNlVmlzaWJsZSkge1xuXHQgICAgICAgIF90aGlzLm9uTW91c2VNb3ZlRm9yQXhpcygneScpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX3RoaXMub25Nb3VzZU1vdmUuY2FuY2VsKCk7XG5cblx0ICAgICAgaWYgKF90aGlzLmF4aXMueC5pc092ZXJmbG93aW5nIHx8IF90aGlzLmF4aXMueC5mb3JjZVZpc2libGUpIHtcblx0ICAgICAgICBfdGhpcy5vbk1vdXNlTGVhdmVGb3JBeGlzKCd4Jyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoX3RoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgfHwgX3RoaXMuYXhpcy55LmZvcmNlVmlzaWJsZSkge1xuXHQgICAgICAgIF90aGlzLm9uTW91c2VMZWF2ZUZvckF4aXMoJ3knKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIF90aGlzLm1vdXNlWCA9IC0xO1xuXHQgICAgICBfdGhpcy5tb3VzZVkgPSAtMTtcblx0ICAgIH07XG5cblx0ICAgIHRoaXMub25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vIFJlY2FsY3VsYXRlIHNjcm9sbGJhcldpZHRoIGluIGNhc2UgaXQncyBhIHpvb21cblx0ICAgICAgX3RoaXMuc2Nyb2xsYmFyV2lkdGggPSBfdGhpcy5nZXRTY3JvbGxiYXJXaWR0aCgpO1xuXG5cdCAgICAgIF90aGlzLmhpZGVOYXRpdmVTY3JvbGxiYXIoKTtcblx0ICAgIH07XG5cblx0ICAgIHRoaXMuaGlkZVNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzLmF4aXMueC50cmFjay5yZWN0ID0gX3RoaXMuYXhpcy54LnRyYWNrLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICBfdGhpcy5heGlzLnkudHJhY2sucmVjdCA9IF90aGlzLmF4aXMueS50cmFjay5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHQgICAgICBpZiAoIV90aGlzLmlzV2l0aGluQm91bmRzKF90aGlzLmF4aXMueS50cmFjay5yZWN0KSkge1xuXHQgICAgICAgIF90aGlzLmF4aXMueS5zY3JvbGxiYXIuZWwuY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5jbGFzc05hbWVzLnZpc2libGUpO1xuXG5cdCAgICAgICAgX3RoaXMuYXhpcy55LmlzVmlzaWJsZSA9IGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFfdGhpcy5pc1dpdGhpbkJvdW5kcyhfdGhpcy5heGlzLngudHJhY2sucmVjdCkpIHtcblx0ICAgICAgICBfdGhpcy5heGlzLnguc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMuY2xhc3NOYW1lcy52aXNpYmxlKTtcblxuXHQgICAgICAgIF90aGlzLmF4aXMueC5pc1Zpc2libGUgPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgdGhpcy5vblBvaW50ZXJFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBpc1dpdGhpblRyYWNrWEJvdW5kcywgaXNXaXRoaW5UcmFja1lCb3VuZHM7XG5cdCAgICAgIF90aGlzLmF4aXMueC50cmFjay5yZWN0ID0gX3RoaXMuYXhpcy54LnRyYWNrLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICBfdGhpcy5heGlzLnkudHJhY2sucmVjdCA9IF90aGlzLmF4aXMueS50cmFjay5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHQgICAgICBpZiAoX3RoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgfHwgX3RoaXMuYXhpcy54LmZvcmNlVmlzaWJsZSkge1xuXHQgICAgICAgIGlzV2l0aGluVHJhY2tYQm91bmRzID0gX3RoaXMuaXNXaXRoaW5Cb3VuZHMoX3RoaXMuYXhpcy54LnRyYWNrLnJlY3QpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKF90aGlzLmF4aXMueS5pc092ZXJmbG93aW5nIHx8IF90aGlzLmF4aXMueS5mb3JjZVZpc2libGUpIHtcblx0ICAgICAgICBpc1dpdGhpblRyYWNrWUJvdW5kcyA9IF90aGlzLmlzV2l0aGluQm91bmRzKF90aGlzLmF4aXMueS50cmFjay5yZWN0KTtcblx0ICAgICAgfSAvLyBJZiBhbnkgcG9pbnRlciBldmVudCBpcyBjYWxsZWQgb24gdGhlIHNjcm9sbGJhclxuXG5cblx0ICAgICAgaWYgKGlzV2l0aGluVHJhY2tYQm91bmRzIHx8IGlzV2l0aGluVHJhY2tZQm91bmRzKSB7XG5cdCAgICAgICAgLy8gUHJldmVudGluZyB0aGUgZXZlbnQncyBkZWZhdWx0IGFjdGlvbiBzdG9wcyB0ZXh0IGJlaW5nXG5cdCAgICAgICAgLy8gc2VsZWN0YWJsZSBkdXJpbmcgdGhlIGRyYWcuXG5cdCAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGV2ZW50IGxlYWtpbmdcblxuXHQgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0ICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuXHQgICAgICAgICAgaWYgKGlzV2l0aGluVHJhY2tYQm91bmRzKSB7XG5cdCAgICAgICAgICAgIF90aGlzLmF4aXMueC5zY3JvbGxiYXIucmVjdCA9IF90aGlzLmF4aXMueC5zY3JvbGxiYXIuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0ICAgICAgICAgICAgaWYgKF90aGlzLmlzV2l0aGluQm91bmRzKF90aGlzLmF4aXMueC5zY3JvbGxiYXIucmVjdCkpIHtcblx0ICAgICAgICAgICAgICBfdGhpcy5vbkRyYWdTdGFydChlLCAneCcpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIF90aGlzLm9uVHJhY2tDbGljayhlLCAneCcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChpc1dpdGhpblRyYWNrWUJvdW5kcykge1xuXHQgICAgICAgICAgICBfdGhpcy5heGlzLnkuc2Nyb2xsYmFyLnJlY3QgPSBfdGhpcy5heGlzLnkuc2Nyb2xsYmFyLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5pc1dpdGhpbkJvdW5kcyhfdGhpcy5heGlzLnkuc2Nyb2xsYmFyLnJlY3QpKSB7XG5cdCAgICAgICAgICAgICAgX3RoaXMub25EcmFnU3RhcnQoZSwgJ3knKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBfdGhpcy5vblRyYWNrQ2xpY2soZSwgJ3knKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgdGhpcy5kcmFnID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIGV2ZW50T2Zmc2V0O1xuXHQgICAgICB2YXIgdHJhY2sgPSBfdGhpcy5heGlzW190aGlzLmRyYWdnZWRBeGlzXS50cmFjaztcblx0ICAgICAgdmFyIHRyYWNrU2l6ZSA9IHRyYWNrLnJlY3RbX3RoaXMuYXhpc1tfdGhpcy5kcmFnZ2VkQXhpc10uc2l6ZUF0dHJdO1xuXHQgICAgICB2YXIgc2Nyb2xsYmFyID0gX3RoaXMuYXhpc1tfdGhpcy5kcmFnZ2VkQXhpc10uc2Nyb2xsYmFyO1xuXHQgICAgICB2YXIgY29udGVudFNpemUgPSBfdGhpcy5jb250ZW50V3JhcHBlckVsW190aGlzLmF4aXNbX3RoaXMuZHJhZ2dlZEF4aXNdLnNjcm9sbFNpemVBdHRyXTtcblx0ICAgICAgdmFyIGhvc3RTaXplID0gcGFyc2VJbnQoX3RoaXMuZWxTdHlsZXNbX3RoaXMuYXhpc1tfdGhpcy5kcmFnZ2VkQXhpc10uc2l6ZUF0dHJdLCAxMCk7XG5cdCAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHQgICAgICBpZiAoX3RoaXMuZHJhZ2dlZEF4aXMgPT09ICd5Jykge1xuXHQgICAgICAgIGV2ZW50T2Zmc2V0ID0gZS5wYWdlWTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBldmVudE9mZnNldCA9IGUucGFnZVg7XG5cdCAgICAgIH0gLy8gQ2FsY3VsYXRlIGhvdyBmYXIgdGhlIHVzZXIncyBtb3VzZSBpcyBmcm9tIHRoZSB0b3AvbGVmdCBvZiB0aGUgc2Nyb2xsYmFyIChtaW51cyB0aGUgZHJhZ09mZnNldCkuXG5cblxuXHQgICAgICB2YXIgZHJhZ1BvcyA9IGV2ZW50T2Zmc2V0IC0gdHJhY2sucmVjdFtfdGhpcy5heGlzW190aGlzLmRyYWdnZWRBeGlzXS5vZmZzZXRBdHRyXSAtIF90aGlzLmF4aXNbX3RoaXMuZHJhZ2dlZEF4aXNdLmRyYWdPZmZzZXQ7IC8vIENvbnZlcnQgdGhlIG1vdXNlIHBvc2l0aW9uIGludG8gYSBwZXJjZW50YWdlIG9mIHRoZSBzY3JvbGxiYXIgaGVpZ2h0L3dpZHRoLlxuXG5cdCAgICAgIHZhciBkcmFnUGVyYyA9IGRyYWdQb3MgLyAodHJhY2tTaXplIC0gc2Nyb2xsYmFyLnNpemUpOyAvLyBTY3JvbGwgdGhlIGNvbnRlbnQgYnkgdGhlIHNhbWUgcGVyY2VudGFnZS5cblxuXHQgICAgICB2YXIgc2Nyb2xsUG9zID0gZHJhZ1BlcmMgKiAoY29udGVudFNpemUgLSBob3N0U2l6ZSk7IC8vIEZpeCBicm93c2VycyBpbmNvbnNpc3RlbmN5IG9uIFJUTFxuXG5cdCAgICAgIGlmIChfdGhpcy5kcmFnZ2VkQXhpcyA9PT0gJ3gnKSB7XG5cdCAgICAgICAgc2Nyb2xsUG9zID0gX3RoaXMuaXNSdGwgJiYgU2ltcGxlQmFyLmdldFJ0bEhlbHBlcnMoKS5pc1J0bFNjcm9sbGJhckludmVydGVkID8gc2Nyb2xsUG9zIC0gKHRyYWNrU2l6ZSArIHNjcm9sbGJhci5zaXplKSA6IHNjcm9sbFBvcztcblx0ICAgICAgICBzY3JvbGxQb3MgPSBfdGhpcy5pc1J0bCAmJiBTaW1wbGVCYXIuZ2V0UnRsSGVscGVycygpLmlzUnRsU2Nyb2xsaW5nSW52ZXJ0ZWQgPyAtc2Nyb2xsUG9zIDogc2Nyb2xsUG9zO1xuXHQgICAgICB9XG5cblx0ICAgICAgX3RoaXMuY29udGVudFdyYXBwZXJFbFtfdGhpcy5heGlzW190aGlzLmRyYWdnZWRBeGlzXS5zY3JvbGxPZmZzZXRBdHRyXSA9IHNjcm9sbFBvcztcblx0ICAgIH07XG5cblx0ICAgIHRoaXMub25FbmREcmFnID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIGVsRG9jdW1lbnQgPSBnZXRFbGVtZW50RG9jdW1lbnQoX3RoaXMuZWwpO1xuXHQgICAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KF90aGlzLmVsKTtcblx0ICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdCAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMuY2xhc3NOYW1lcy5kcmFnZ2luZyk7XG5cblx0ICAgICAgZWxEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5kcmFnLCB0cnVlKTtcblx0ICAgICAgZWxEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMub25FbmREcmFnLCB0cnVlKTtcblx0ICAgICAgX3RoaXMucmVtb3ZlUHJldmVudENsaWNrSWQgPSBlbFdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBSZW1vdmUgdGhlc2UgYXN5bmNocm9ub3VzbHkgc28gd2Ugc3RpbGwgc3VwcHJlc3MgY2xpY2sgZXZlbnRzXG5cdCAgICAgICAgLy8gZ2VuZXJhdGVkIHNpbXVsdGFuZW91c2x5IHdpdGggbW91c2V1cC5cblx0ICAgICAgICBlbERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMucHJldmVudENsaWNrLCB0cnVlKTtcblx0ICAgICAgICBlbERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgX3RoaXMucHJldmVudENsaWNrLCB0cnVlKTtcblx0ICAgICAgICBfdGhpcy5yZW1vdmVQcmV2ZW50Q2xpY2tJZCA9IG51bGw7XG5cdCAgICAgIH0pO1xuXHQgICAgfTtcblxuXHQgICAgdGhpcy5wcmV2ZW50Q2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLmVsID0gZWxlbWVudDtcblx0ICAgIHRoaXMubWluU2Nyb2xsYmFyV2lkdGggPSAyMDtcblx0ICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIFNpbXBsZUJhci5kZWZhdWx0T3B0aW9ucywge30sIG9wdGlvbnMpO1xuXHQgICAgdGhpcy5jbGFzc05hbWVzID0gT2JqZWN0LmFzc2lnbih7fSwgU2ltcGxlQmFyLmRlZmF1bHRPcHRpb25zLmNsYXNzTmFtZXMsIHt9LCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lcyk7XG5cdCAgICB0aGlzLmF4aXMgPSB7XG5cdCAgICAgIHg6IHtcblx0ICAgICAgICBzY3JvbGxPZmZzZXRBdHRyOiAnc2Nyb2xsTGVmdCcsXG5cdCAgICAgICAgc2l6ZUF0dHI6ICd3aWR0aCcsXG5cdCAgICAgICAgc2Nyb2xsU2l6ZUF0dHI6ICdzY3JvbGxXaWR0aCcsXG5cdCAgICAgICAgb2Zmc2V0U2l6ZUF0dHI6ICdvZmZzZXRXaWR0aCcsXG5cdCAgICAgICAgb2Zmc2V0QXR0cjogJ2xlZnQnLFxuXHQgICAgICAgIG92ZXJmbG93QXR0cjogJ292ZXJmbG93WCcsXG5cdCAgICAgICAgZHJhZ09mZnNldDogMCxcblx0ICAgICAgICBpc092ZXJmbG93aW5nOiB0cnVlLFxuXHQgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG5cdCAgICAgICAgZm9yY2VWaXNpYmxlOiBmYWxzZSxcblx0ICAgICAgICB0cmFjazoge30sXG5cdCAgICAgICAgc2Nyb2xsYmFyOiB7fVxuXHQgICAgICB9LFxuXHQgICAgICB5OiB7XG5cdCAgICAgICAgc2Nyb2xsT2Zmc2V0QXR0cjogJ3Njcm9sbFRvcCcsXG5cdCAgICAgICAgc2l6ZUF0dHI6ICdoZWlnaHQnLFxuXHQgICAgICAgIHNjcm9sbFNpemVBdHRyOiAnc2Nyb2xsSGVpZ2h0Jyxcblx0ICAgICAgICBvZmZzZXRTaXplQXR0cjogJ29mZnNldEhlaWdodCcsXG5cdCAgICAgICAgb2Zmc2V0QXR0cjogJ3RvcCcsXG5cdCAgICAgICAgb3ZlcmZsb3dBdHRyOiAnb3ZlcmZsb3dZJyxcblx0ICAgICAgICBkcmFnT2Zmc2V0OiAwLFxuXHQgICAgICAgIGlzT3ZlcmZsb3dpbmc6IHRydWUsXG5cdCAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcblx0ICAgICAgICBmb3JjZVZpc2libGU6IGZhbHNlLFxuXHQgICAgICAgIHRyYWNrOiB7fSxcblx0ICAgICAgICBzY3JvbGxiYXI6IHt9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICB0aGlzLnJlbW92ZVByZXZlbnRDbGlja0lkID0gbnVsbDsgLy8gRG9uJ3QgcmUtaW5zdGFudGlhdGUgb3ZlciBhbiBleGlzdGluZyBvbmVcblxuXHQgICAgaWYgKFNpbXBsZUJhci5pbnN0YW5jZXMuaGFzKHRoaXMuZWwpKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5yZWNhbGN1bGF0ZSA9IGxvZGFzaF90aHJvdHRsZSh0aGlzLnJlY2FsY3VsYXRlLmJpbmQodGhpcyksIDY0KTtcblx0ICAgIHRoaXMub25Nb3VzZU1vdmUgPSBsb2Rhc2hfdGhyb3R0bGUodGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpLCA2NCk7XG5cdCAgICB0aGlzLmhpZGVTY3JvbGxiYXJzID0gbG9kYXNoX2RlYm91bmNlKHRoaXMuaGlkZVNjcm9sbGJhcnMuYmluZCh0aGlzKSwgdGhpcy5vcHRpb25zLnRpbWVvdXQpO1xuXHQgICAgdGhpcy5vbldpbmRvd1Jlc2l6ZSA9IGxvZGFzaF9kZWJvdW5jZSh0aGlzLm9uV2luZG93UmVzaXplLmJpbmQodGhpcyksIDY0LCB7XG5cdCAgICAgIGxlYWRpbmc6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgU2ltcGxlQmFyLmdldFJ0bEhlbHBlcnMgPSBsb2Rhc2hfbWVtb2l6ZShTaW1wbGVCYXIuZ2V0UnRsSGVscGVycyk7XG5cdCAgICB0aGlzLmluaXQoKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogU3RhdGljIHByb3BlcnRpZXNcblx0ICAgKi9cblxuXHQgIC8qKlxuXHQgICAqIEhlbHBlciB0byBmaXggYnJvd3NlcnMgaW5jb25zaXN0ZW5jeSBvbiBSVEw6XG5cdCAgICogIC0gRmlyZWZveCBpbnZlcnRzIHRoZSBzY3JvbGxiYXIgaW5pdGlhbCBwb3NpdGlvblxuXHQgICAqICAtIElFMTEgaW52ZXJ0cyBib3RoIHNjcm9sbGJhciBwb3NpdGlvbiBhbmQgc2Nyb2xsaW5nIG9mZnNldFxuXHQgICAqIERpcmVjdGx5IGluc3BpcmVkIGJ5IEBLaW5nU29yYSdzIE92ZXJsYXlTY3JvbGxiYXJzIGh0dHBzOi8vZ2l0aHViLmNvbS9LaW5nU29yYS9PdmVybGF5U2Nyb2xsYmFycy9ibG9iL21hc3Rlci9qcy9PdmVybGF5U2Nyb2xsYmFycy5qcyNMMTYzNFxuXHQgICAqL1xuXG5cblx0ICBTaW1wbGVCYXIuZ2V0UnRsSGVscGVycyA9IGZ1bmN0aW9uIGdldFJ0bEhlbHBlcnMoKSB7XG5cdCAgICB2YXIgZHVtbXlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICAgIGR1bW15RGl2LmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiaHMtZHVtbXktc2Nyb2xsYmFyLXNpemVcIj48ZGl2IHN0eWxlPVwiaGVpZ2h0OiAyMDAlOyB3aWR0aDogMjAwJTsgbWFyZ2luOiAxMHB4IDA7XCI+PC9kaXY+PC9kaXY+Jztcblx0ICAgIHZhciBzY3JvbGxiYXJEdW1teUVsID0gZHVtbXlEaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbGJhckR1bW15RWwpO1xuXHQgICAgdmFyIGR1bW15Q29udGFpbmVyQ2hpbGQgPSBzY3JvbGxiYXJEdW1teUVsLmZpcnN0RWxlbWVudENoaWxkO1xuXHQgICAgc2Nyb2xsYmFyRHVtbXlFbC5zY3JvbGxMZWZ0ID0gMDtcblx0ICAgIHZhciBkdW1teUNvbnRhaW5lck9mZnNldCA9IFNpbXBsZUJhci5nZXRPZmZzZXQoc2Nyb2xsYmFyRHVtbXlFbCk7XG5cdCAgICB2YXIgZHVtbXlDb250YWluZXJDaGlsZE9mZnNldCA9IFNpbXBsZUJhci5nZXRPZmZzZXQoZHVtbXlDb250YWluZXJDaGlsZCk7XG5cdCAgICBzY3JvbGxiYXJEdW1teUVsLnNjcm9sbExlZnQgPSA5OTk7XG5cdCAgICB2YXIgZHVtbXlDb250YWluZXJTY3JvbGxPZmZzZXRBZnRlclNjcm9sbCA9IFNpbXBsZUJhci5nZXRPZmZzZXQoZHVtbXlDb250YWluZXJDaGlsZCk7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAvLyBkZXRlcm1pbmVzIGlmIHRoZSBzY3JvbGxpbmcgaXMgcmVzcG9uZGluZyB3aXRoIG5lZ2F0aXZlIHZhbHVlc1xuXHQgICAgICBpc1J0bFNjcm9sbGluZ0ludmVydGVkOiBkdW1teUNvbnRhaW5lck9mZnNldC5sZWZ0ICE9PSBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0LmxlZnQgJiYgZHVtbXlDb250YWluZXJDaGlsZE9mZnNldC5sZWZ0IC0gZHVtbXlDb250YWluZXJTY3JvbGxPZmZzZXRBZnRlclNjcm9sbC5sZWZ0ICE9PSAwLFxuXHQgICAgICAvLyBkZXRlcm1pbmVzIGlmIHRoZSBvcmlnaW4gc2Nyb2xsYmFyIHBvc2l0aW9uIGlzIGludmVydGVkIG9yIG5vdCAocG9zaXRpb25lZCBvbiBsZWZ0IG9yIHJpZ2h0KVxuXHQgICAgICBpc1J0bFNjcm9sbGJhckludmVydGVkOiBkdW1teUNvbnRhaW5lck9mZnNldC5sZWZ0ICE9PSBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0LmxlZnRcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIFNpbXBsZUJhci5nZXRPZmZzZXQgPSBmdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcblx0ICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdCAgICB2YXIgZWxEb2N1bWVudCA9IGdldEVsZW1lbnREb2N1bWVudChlbCk7XG5cdCAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KGVsKTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHRvcDogcmVjdC50b3AgKyAoZWxXaW5kb3cucGFnZVlPZmZzZXQgfHwgZWxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSxcblx0ICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgKGVsV2luZG93LnBhZ2VYT2Zmc2V0IHx8IGVsRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpXG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICB2YXIgX3Byb3RvID0gU2ltcGxlQmFyLnByb3RvdHlwZTtcblxuXHQgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcblx0ICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlLCBzbyB3ZSBrbm93IHRoaXMgRE9NIG5vZGUgaGFzIGFscmVhZHkgYmVlbiBpbnN0YW5jaWVkXG5cdCAgICBTaW1wbGVCYXIuaW5zdGFuY2VzLnNldCh0aGlzLmVsLCB0aGlzKTsgLy8gV2Ugc3RvcCBoZXJlIG9uIHNlcnZlci1zaWRlXG5cblx0ICAgIGlmIChjYW5Vc2VEb20pIHtcblx0ICAgICAgdGhpcy5pbml0RE9NKCk7XG5cdCAgICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFNjcm9sbGJhcldpZHRoKCk7XG5cdCAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcblx0ICAgICAgdGhpcy5pbml0TGlzdGVuZXJzKCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5pbml0RE9NID0gZnVuY3Rpb24gaW5pdERPTSgpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICB2YXIgZWxEb2N1bWVudCA9IGdldEVsZW1lbnREb2N1bWVudCh0aGlzLmVsKTsgLy8gbWFrZSBzdXJlIHRoaXMgZWxlbWVudCBkb2Vzbid0IGhhdmUgdGhlIGVsZW1lbnRzIHlldFxuXG5cdCAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuZWwuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuXHQgICAgICByZXR1cm4gY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKF90aGlzMi5jbGFzc05hbWVzLndyYXBwZXIpO1xuXHQgICAgfSkubGVuZ3RoKSB7XG5cdCAgICAgIC8vIGFzc3VtZSB0aGF0IGVsZW1lbnQgaGFzIGhpcyBET00gYWxyZWFkeSBpbml0aWF0ZWRcblx0ICAgICAgdGhpcy53cmFwcGVyRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMud3JhcHBlcik7XG5cdCAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbCA9IHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlTm9kZSB8fCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMuY29udGVudFdyYXBwZXIpO1xuXHQgICAgICB0aGlzLmNvbnRlbnRFbCA9IHRoaXMub3B0aW9ucy5jb250ZW50Tm9kZSB8fCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMuY29udGVudEVsKTtcblx0ICAgICAgdGhpcy5vZmZzZXRFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy5vZmZzZXQpO1xuXHQgICAgICB0aGlzLm1hc2tFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy5tYXNrKTtcblx0ICAgICAgdGhpcy5wbGFjZWhvbGRlckVsID0gdGhpcy5maW5kQ2hpbGQodGhpcy53cmFwcGVyRWwsIFwiLlwiICsgdGhpcy5jbGFzc05hbWVzLnBsYWNlaG9sZGVyKTtcblx0ICAgICAgdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJXcmFwcGVyRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMuaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsKTtcblx0ICAgICAgdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbCk7XG5cdCAgICAgIHRoaXMuYXhpcy54LnRyYWNrLmVsID0gdGhpcy5maW5kQ2hpbGQodGhpcy5lbCwgXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMudHJhY2sgKyBcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy5ob3Jpem9udGFsKTtcblx0ICAgICAgdGhpcy5heGlzLnkudHJhY2suZWwgPSB0aGlzLmZpbmRDaGlsZCh0aGlzLmVsLCBcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy50cmFjayArIFwiLlwiICsgdGhpcy5jbGFzc05hbWVzLnZlcnRpY2FsKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFByZXBhcmUgRE9NXG5cdCAgICAgIHRoaXMud3JhcHBlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICB0aGlzLm9mZnNldEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMubWFza0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMuY29udGVudEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMucGxhY2Vob2xkZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMud3JhcHBlckVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLndyYXBwZXIpO1xuXHQgICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuY29udGVudFdyYXBwZXIpO1xuXHQgICAgICB0aGlzLm9mZnNldEVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLm9mZnNldCk7XG5cdCAgICAgIHRoaXMubWFza0VsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLm1hc2spO1xuXHQgICAgICB0aGlzLmNvbnRlbnRFbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5jb250ZW50RWwpO1xuXHQgICAgICB0aGlzLnBsYWNlaG9sZGVyRWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMucGxhY2Vob2xkZXIpO1xuXHQgICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5oZWlnaHRBdXRvT2JzZXJ2ZXJXcmFwcGVyRWwpO1xuXHQgICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlckVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmhlaWdodEF1dG9PYnNlcnZlckVsKTtcblxuXHQgICAgICB3aGlsZSAodGhpcy5lbC5maXJzdENoaWxkKSB7XG5cdCAgICAgICAgdGhpcy5jb250ZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbC5maXJzdENoaWxkKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbCk7XG5cdCAgICAgIHRoaXMub2Zmc2V0RWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50V3JhcHBlckVsKTtcblx0ICAgICAgdGhpcy5tYXNrRWwuYXBwZW5kQ2hpbGQodGhpcy5vZmZzZXRFbCk7XG5cdCAgICAgIHRoaXMuaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsLmFwcGVuZENoaWxkKHRoaXMuaGVpZ2h0QXV0b09ic2VydmVyRWwpO1xuXHQgICAgICB0aGlzLndyYXBwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLmhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbCk7XG5cdCAgICAgIHRoaXMud3JhcHBlckVsLmFwcGVuZENoaWxkKHRoaXMubWFza0VsKTtcblx0ICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5wbGFjZWhvbGRlckVsKTtcblx0ICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXJFbCk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5heGlzLngudHJhY2suZWwgfHwgIXRoaXMuYXhpcy55LnRyYWNrLmVsKSB7XG5cdCAgICAgIHZhciB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICB2YXIgc2Nyb2xsYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRyYWNrLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnRyYWNrKTtcblx0ICAgICAgc2Nyb2xsYmFyLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnNjcm9sbGJhcik7XG5cdCAgICAgIHRyYWNrLmFwcGVuZENoaWxkKHNjcm9sbGJhcik7XG5cdCAgICAgIHRoaXMuYXhpcy54LnRyYWNrLmVsID0gdHJhY2suY2xvbmVOb2RlKHRydWUpO1xuXHQgICAgICB0aGlzLmF4aXMueC50cmFjay5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5ob3Jpem9udGFsKTtcblx0ICAgICAgdGhpcy5heGlzLnkudHJhY2suZWwgPSB0cmFjay5jbG9uZU5vZGUodHJ1ZSk7XG5cdCAgICAgIHRoaXMuYXhpcy55LnRyYWNrLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnZlcnRpY2FsKTtcblx0ICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmF4aXMueC50cmFjay5lbCk7XG5cdCAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5heGlzLnkudHJhY2suZWwpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmF4aXMueC5zY3JvbGxiYXIuZWwgPSB0aGlzLmF4aXMueC50cmFjay5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgdGhpcy5jbGFzc05hbWVzLnNjcm9sbGJhcik7XG5cdCAgICB0aGlzLmF4aXMueS5zY3JvbGxiYXIuZWwgPSB0aGlzLmF4aXMueS50cmFjay5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgdGhpcy5jbGFzc05hbWVzLnNjcm9sbGJhcik7XG5cblx0ICAgIGlmICghdGhpcy5vcHRpb25zLmF1dG9IaWRlKSB7XG5cdCAgICAgIHRoaXMuYXhpcy54LnNjcm9sbGJhci5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy52aXNpYmxlKTtcblx0ICAgICAgdGhpcy5heGlzLnkuc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnZpc2libGUpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zaW1wbGViYXInLCAnaW5pdCcpO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uaW5pdExpc3RlbmVycyA9IGZ1bmN0aW9uIGluaXRMaXN0ZW5lcnMoKSB7XG5cdCAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuXHQgICAgdmFyIGVsV2luZG93ID0gZ2V0RWxlbWVudFdpbmRvdyh0aGlzLmVsKTsgLy8gRXZlbnQgbGlzdGVuZXJzXG5cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hpZGUpIHtcblx0ICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuXHQgICAgfVxuXG5cdCAgICBbJ21vdXNlZG93bicsICdjbGljaycsICdkYmxjbGljayddLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgX3RoaXMzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgX3RoaXMzLm9uUG9pbnRlckV2ZW50LCB0cnVlKTtcblx0ICAgIH0pO1xuXHQgICAgWyd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSddLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgX3RoaXMzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgX3RoaXMzLm9uUG9pbnRlckV2ZW50LCB7XG5cdCAgICAgICAgY2FwdHVyZTogdHJ1ZSxcblx0ICAgICAgICBwYXNzaXZlOiB0cnVlXG5cdCAgICAgIH0pO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuXHQgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuXHQgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwpOyAvLyBCcm93c2VyIHpvb20gdHJpZ2dlcnMgYSB3aW5kb3cgcmVzaXplXG5cblx0ICAgIGVsV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25XaW5kb3dSZXNpemUpOyAvLyBIYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9SZXNpemVPYnNlcnZlci9pc3N1ZXMvMzhcblxuXHQgICAgdmFyIHJlc2l6ZU9ic2VydmVyU3RhcnRlZCA9IGZhbHNlO1xuXHQgICAgdmFyIHJlc2l6ZU9ic2VydmVyID0gZWxXaW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgaW5kZXg7XG5cdCAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IHJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCFyZXNpemVPYnNlcnZlclN0YXJ0ZWQpIHJldHVybjtcblxuXHQgICAgICBfdGhpczMucmVjYWxjdWxhdGUoKTtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwpO1xuXHQgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY29udGVudEVsKTtcblx0ICAgIGVsV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJlc2l6ZU9ic2VydmVyU3RhcnRlZCA9IHRydWU7XG5cdCAgICB9KTsgLy8gVGhpcyBpcyByZXF1aXJlZCB0byBkZXRlY3QgaG9yaXpvbnRhbCBzY3JvbGwuIFZlcnRpY2FsIHNjcm9sbCBvbmx5IG5lZWRzIHRoZSByZXNpemVPYnNlcnZlci5cblxuXHQgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IGVsV2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWNhbGN1bGF0ZSk7XG5cdCAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNvbnRlbnRFbCwge1xuXHQgICAgICBjaGlsZExpc3Q6IHRydWUsXG5cdCAgICAgIHN1YnRyZWU6IHRydWUsXG5cdCAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiByZWNhbGN1bGF0ZSgpIHtcblx0ICAgIHZhciBlbFdpbmRvdyA9IGdldEVsZW1lbnRXaW5kb3codGhpcy5lbCk7XG5cdCAgICB0aGlzLmVsU3R5bGVzID0gZWxXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKTtcblx0ICAgIHRoaXMuaXNSdGwgPSB0aGlzLmVsU3R5bGVzLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG5cdCAgICB2YXIgaXNIZWlnaHRBdXRvID0gdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbC5vZmZzZXRIZWlnaHQgPD0gMTtcblx0ICAgIHZhciBpc1dpZHRoQXV0byA9IHRoaXMuaGVpZ2h0QXV0b09ic2VydmVyRWwub2Zmc2V0V2lkdGggPD0gMTtcblx0ICAgIHZhciBjb250ZW50RWxPZmZzZXRXaWR0aCA9IHRoaXMuY29udGVudEVsLm9mZnNldFdpZHRoO1xuXHQgICAgdmFyIGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRXaWR0aCA9IHRoaXMuY29udGVudFdyYXBwZXJFbC5vZmZzZXRXaWR0aDtcblx0ICAgIHZhciBlbE92ZXJmbG93WCA9IHRoaXMuZWxTdHlsZXMub3ZlcmZsb3dYO1xuXHQgICAgdmFyIGVsT3ZlcmZsb3dZID0gdGhpcy5lbFN0eWxlcy5vdmVyZmxvd1k7XG5cdCAgICB0aGlzLmNvbnRlbnRFbC5zdHlsZS5wYWRkaW5nID0gdGhpcy5lbFN0eWxlcy5wYWRkaW5nVG9wICsgXCIgXCIgKyB0aGlzLmVsU3R5bGVzLnBhZGRpbmdSaWdodCArIFwiIFwiICsgdGhpcy5lbFN0eWxlcy5wYWRkaW5nQm90dG9tICsgXCIgXCIgKyB0aGlzLmVsU3R5bGVzLnBhZGRpbmdMZWZ0O1xuXHQgICAgdGhpcy53cmFwcGVyRWwuc3R5bGUubWFyZ2luID0gXCItXCIgKyB0aGlzLmVsU3R5bGVzLnBhZGRpbmdUb3AgKyBcIiAtXCIgKyB0aGlzLmVsU3R5bGVzLnBhZGRpbmdSaWdodCArIFwiIC1cIiArIHRoaXMuZWxTdHlsZXMucGFkZGluZ0JvdHRvbSArIFwiIC1cIiArIHRoaXMuZWxTdHlsZXMucGFkZGluZ0xlZnQ7XG5cdCAgICB2YXIgY29udGVudEVsU2Nyb2xsSGVpZ2h0ID0gdGhpcy5jb250ZW50RWwuc2Nyb2xsSGVpZ2h0O1xuXHQgICAgdmFyIGNvbnRlbnRFbFNjcm9sbFdpZHRoID0gdGhpcy5jb250ZW50RWwuc2Nyb2xsV2lkdGg7XG5cdCAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwuc3R5bGUuaGVpZ2h0ID0gaXNIZWlnaHRBdXRvID8gJ2F1dG8nIDogJzEwMCUnOyAvLyBEZXRlcm1pbmUgcGxhY2Vob2xkZXIgc2l6ZVxuXG5cdCAgICB0aGlzLnBsYWNlaG9sZGVyRWwuc3R5bGUud2lkdGggPSBpc1dpZHRoQXV0byA/IGNvbnRlbnRFbE9mZnNldFdpZHRoICsgXCJweFwiIDogJ2F1dG8nO1xuXHQgICAgdGhpcy5wbGFjZWhvbGRlckVsLnN0eWxlLmhlaWdodCA9IGNvbnRlbnRFbFNjcm9sbEhlaWdodCArIFwicHhcIjtcblx0ICAgIHZhciBjb250ZW50V3JhcHBlckVsT2Zmc2V0SGVpZ2h0ID0gdGhpcy5jb250ZW50V3JhcHBlckVsLm9mZnNldEhlaWdodDtcblx0ICAgIHRoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgPSBjb250ZW50RWxTY3JvbGxXaWR0aCA+IGNvbnRlbnRFbE9mZnNldFdpZHRoO1xuXHQgICAgdGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZyA9IGNvbnRlbnRFbFNjcm9sbEhlaWdodCA+IGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRIZWlnaHQ7IC8vIFNldCBpc092ZXJmbG93aW5nIHRvIGZhbHNlIGlmIHVzZXIgZXhwbGljaXRlbHkgc2V0IGhpZGRlbiBvdmVyZmxvd1xuXG5cdCAgICB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nID0gZWxPdmVyZmxvd1ggPT09ICdoaWRkZW4nID8gZmFsc2UgOiB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nO1xuXHQgICAgdGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZyA9IGVsT3ZlcmZsb3dZID09PSAnaGlkZGVuJyA/IGZhbHNlIDogdGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZztcblx0ICAgIHRoaXMuYXhpcy54LmZvcmNlVmlzaWJsZSA9IHRoaXMub3B0aW9ucy5mb3JjZVZpc2libGUgPT09ICd4JyB8fCB0aGlzLm9wdGlvbnMuZm9yY2VWaXNpYmxlID09PSB0cnVlO1xuXHQgICAgdGhpcy5heGlzLnkuZm9yY2VWaXNpYmxlID0gdGhpcy5vcHRpb25zLmZvcmNlVmlzaWJsZSA9PT0gJ3knIHx8IHRoaXMub3B0aW9ucy5mb3JjZVZpc2libGUgPT09IHRydWU7XG5cdCAgICB0aGlzLmhpZGVOYXRpdmVTY3JvbGxiYXIoKTsgLy8gU2V0IGlzT3ZlcmZsb3dpbmcgdG8gZmFsc2UgaWYgc2Nyb2xsYmFyIGlzIG5vdCBuZWNlc3NhcnkgKGNvbnRlbnQgaXMgc2hvcnRlciB0aGFuIG9mZnNldClcblxuXHQgICAgdmFyIG9mZnNldEZvclhTY3JvbGxiYXIgPSB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6IDA7XG5cdCAgICB2YXIgb2Zmc2V0Rm9yWVNjcm9sbGJhciA9IHRoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogMDtcblx0ICAgIHRoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgPSB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nICYmIGNvbnRlbnRFbFNjcm9sbFdpZHRoID4gY29udGVudFdyYXBwZXJFbE9mZnNldFdpZHRoIC0gb2Zmc2V0Rm9yWVNjcm9sbGJhcjtcblx0ICAgIHRoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgPSB0aGlzLmF4aXMueS5pc092ZXJmbG93aW5nICYmIGNvbnRlbnRFbFNjcm9sbEhlaWdodCA+IGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRIZWlnaHQgLSBvZmZzZXRGb3JYU2Nyb2xsYmFyO1xuXHQgICAgdGhpcy5heGlzLnguc2Nyb2xsYmFyLnNpemUgPSB0aGlzLmdldFNjcm9sbGJhclNpemUoJ3gnKTtcblx0ICAgIHRoaXMuYXhpcy55LnNjcm9sbGJhci5zaXplID0gdGhpcy5nZXRTY3JvbGxiYXJTaXplKCd5Jyk7XG5cdCAgICB0aGlzLmF4aXMueC5zY3JvbGxiYXIuZWwuc3R5bGUud2lkdGggPSB0aGlzLmF4aXMueC5zY3JvbGxiYXIuc2l6ZSArIFwicHhcIjtcblx0ICAgIHRoaXMuYXhpcy55LnNjcm9sbGJhci5lbC5zdHlsZS5oZWlnaHQgPSB0aGlzLmF4aXMueS5zY3JvbGxiYXIuc2l6ZSArIFwicHhcIjtcblx0ICAgIHRoaXMucG9zaXRpb25TY3JvbGxiYXIoJ3gnKTtcblx0ICAgIHRoaXMucG9zaXRpb25TY3JvbGxiYXIoJ3knKTtcblx0ICAgIHRoaXMudG9nZ2xlVHJhY2tWaXNpYmlsaXR5KCd4Jyk7XG5cdCAgICB0aGlzLnRvZ2dsZVRyYWNrVmlzaWJpbGl0eSgneScpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBDYWxjdWxhdGUgc2Nyb2xsYmFyIHNpemVcblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8uZ2V0U2Nyb2xsYmFyU2l6ZSA9IGZ1bmN0aW9uIGdldFNjcm9sbGJhclNpemUoYXhpcykge1xuXHQgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuXHQgICAgICBheGlzID0gJ3knO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRoaXMuYXhpc1theGlzXS5pc092ZXJmbG93aW5nKSB7XG5cdCAgICAgIHJldHVybiAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY29udGVudFNpemUgPSB0aGlzLmNvbnRlbnRFbFt0aGlzLmF4aXNbYXhpc10uc2Nyb2xsU2l6ZUF0dHJdO1xuXHQgICAgdmFyIHRyYWNrU2l6ZSA9IHRoaXMuYXhpc1theGlzXS50cmFjay5lbFt0aGlzLmF4aXNbYXhpc10ub2Zmc2V0U2l6ZUF0dHJdO1xuXHQgICAgdmFyIHNjcm9sbGJhclNpemU7XG5cdCAgICB2YXIgc2Nyb2xsYmFyUmF0aW8gPSB0cmFja1NpemUgLyBjb250ZW50U2l6ZTsgLy8gQ2FsY3VsYXRlIG5ldyBoZWlnaHQvcG9zaXRpb24gb2YgZHJhZyBoYW5kbGUuXG5cblx0ICAgIHNjcm9sbGJhclNpemUgPSBNYXRoLm1heCh+fihzY3JvbGxiYXJSYXRpbyAqIHRyYWNrU2l6ZSksIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJNaW5TaXplKTtcblxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxiYXJNYXhTaXplKSB7XG5cdCAgICAgIHNjcm9sbGJhclNpemUgPSBNYXRoLm1pbihzY3JvbGxiYXJTaXplLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFyTWF4U2l6ZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzY3JvbGxiYXJTaXplO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ucG9zaXRpb25TY3JvbGxiYXIgPSBmdW5jdGlvbiBwb3NpdGlvblNjcm9sbGJhcihheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5heGlzW2F4aXNdLmlzT3ZlcmZsb3dpbmcpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY29udGVudFNpemUgPSB0aGlzLmNvbnRlbnRXcmFwcGVyRWxbdGhpcy5heGlzW2F4aXNdLnNjcm9sbFNpemVBdHRyXTtcblx0ICAgIHZhciB0cmFja1NpemUgPSB0aGlzLmF4aXNbYXhpc10udHJhY2suZWxbdGhpcy5heGlzW2F4aXNdLm9mZnNldFNpemVBdHRyXTtcblx0ICAgIHZhciBob3N0U2l6ZSA9IHBhcnNlSW50KHRoaXMuZWxTdHlsZXNbdGhpcy5heGlzW2F4aXNdLnNpemVBdHRyXSwgMTApO1xuXHQgICAgdmFyIHNjcm9sbGJhciA9IHRoaXMuYXhpc1theGlzXS5zY3JvbGxiYXI7XG5cdCAgICB2YXIgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5jb250ZW50V3JhcHBlckVsW3RoaXMuYXhpc1theGlzXS5zY3JvbGxPZmZzZXRBdHRyXTtcblx0ICAgIHNjcm9sbE9mZnNldCA9IGF4aXMgPT09ICd4JyAmJiB0aGlzLmlzUnRsICYmIFNpbXBsZUJhci5nZXRSdGxIZWxwZXJzKCkuaXNSdGxTY3JvbGxpbmdJbnZlcnRlZCA/IC1zY3JvbGxPZmZzZXQgOiBzY3JvbGxPZmZzZXQ7XG5cdCAgICB2YXIgc2Nyb2xsUG91cmNlbnQgPSBzY3JvbGxPZmZzZXQgLyAoY29udGVudFNpemUgLSBob3N0U2l6ZSk7XG5cdCAgICB2YXIgaGFuZGxlT2Zmc2V0ID0gfn4oKHRyYWNrU2l6ZSAtIHNjcm9sbGJhci5zaXplKSAqIHNjcm9sbFBvdXJjZW50KTtcblx0ICAgIGhhbmRsZU9mZnNldCA9IGF4aXMgPT09ICd4JyAmJiB0aGlzLmlzUnRsICYmIFNpbXBsZUJhci5nZXRSdGxIZWxwZXJzKCkuaXNSdGxTY3JvbGxiYXJJbnZlcnRlZCA/IGhhbmRsZU9mZnNldCArICh0cmFja1NpemUgLSBzY3JvbGxiYXIuc2l6ZSkgOiBoYW5kbGVPZmZzZXQ7XG5cdCAgICBzY3JvbGxiYXIuZWwuc3R5bGUudHJhbnNmb3JtID0gYXhpcyA9PT0gJ3gnID8gXCJ0cmFuc2xhdGUzZChcIiArIGhhbmRsZU9mZnNldCArIFwicHgsIDAsIDApXCIgOiBcInRyYW5zbGF0ZTNkKDAsIFwiICsgaGFuZGxlT2Zmc2V0ICsgXCJweCwgMClcIjtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnRvZ2dsZVRyYWNrVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHRvZ2dsZVRyYWNrVmlzaWJpbGl0eShheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIHZhciB0cmFjayA9IHRoaXMuYXhpc1theGlzXS50cmFjay5lbDtcblx0ICAgIHZhciBzY3JvbGxiYXIgPSB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyLmVsO1xuXG5cdCAgICBpZiAodGhpcy5heGlzW2F4aXNdLmlzT3ZlcmZsb3dpbmcgfHwgdGhpcy5heGlzW2F4aXNdLmZvcmNlVmlzaWJsZSkge1xuXHQgICAgICB0cmFjay5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXHQgICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwuc3R5bGVbdGhpcy5heGlzW2F4aXNdLm92ZXJmbG93QXR0cl0gPSAnc2Nyb2xsJztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRyYWNrLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0ICAgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLnN0eWxlW3RoaXMuYXhpc1theGlzXS5vdmVyZmxvd0F0dHJdID0gJ2hpZGRlbic7XG5cdCAgICB9IC8vIEV2ZW4gaWYgZm9yY2VWaXNpYmxlIGlzIGVuYWJsZWQsIHNjcm9sbGJhciBpdHNlbGYgc2hvdWxkIGJlIGhpZGRlblxuXG5cblx0ICAgIGlmICh0aGlzLmF4aXNbYXhpc10uaXNPdmVyZmxvd2luZykge1xuXHQgICAgICBzY3JvbGxiYXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzY3JvbGxiYXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLmhpZGVOYXRpdmVTY3JvbGxiYXIgPSBmdW5jdGlvbiBoaWRlTmF0aXZlU2Nyb2xsYmFyKCkge1xuXHQgICAgdGhpcy5vZmZzZXRFbC5zdHlsZVt0aGlzLmlzUnRsID8gJ2xlZnQnIDogJ3JpZ2h0J10gPSB0aGlzLmF4aXMueS5pc092ZXJmbG93aW5nIHx8IHRoaXMuYXhpcy55LmZvcmNlVmlzaWJsZSA/IFwiLVwiICsgdGhpcy5zY3JvbGxiYXJXaWR0aCArIFwicHhcIiA6IDA7XG5cdCAgICB0aGlzLm9mZnNldEVsLnN0eWxlLmJvdHRvbSA9IHRoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgfHwgdGhpcy5heGlzLnguZm9yY2VWaXNpYmxlID8gXCItXCIgKyB0aGlzLnNjcm9sbGJhcldpZHRoICsgXCJweFwiIDogMDtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogT24gc2Nyb2xsIGV2ZW50IGhhbmRsaW5nXG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLm9uTW91c2VNb3ZlRm9yQXhpcyA9IGZ1bmN0aW9uIG9uTW91c2VNb3ZlRm9yQXhpcyhheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5yZWN0ID0gdGhpcy5heGlzW2F4aXNdLnRyYWNrLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5yZWN0ID0gdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICAgIHZhciBpc1dpdGhpblNjcm9sbGJhckJvdW5kc1ggPSB0aGlzLmlzV2l0aGluQm91bmRzKHRoaXMuYXhpc1theGlzXS5zY3JvbGxiYXIucmVjdCk7XG5cblx0ICAgIGlmIChpc1dpdGhpblNjcm9sbGJhckJvdW5kc1gpIHtcblx0ICAgICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLmhvdmVyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuaXNXaXRoaW5Cb3VuZHModGhpcy5heGlzW2F4aXNdLnRyYWNrLnJlY3QpKSB7XG5cdCAgICAgIHRoaXMuc2hvd1Njcm9sbGJhcihheGlzKTtcblx0ICAgICAgdGhpcy5heGlzW2F4aXNdLnRyYWNrLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmhvdmVyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5vbk1vdXNlTGVhdmVGb3JBeGlzID0gZnVuY3Rpb24gb25Nb3VzZUxlYXZlRm9yQXhpcyhheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG5cdCAgICB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLmhvdmVyKTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogU2hvdyBzY3JvbGxiYXJcblx0ICAgKi9cblx0ICBfcHJvdG8uc2hvd1Njcm9sbGJhciA9IGZ1bmN0aW9uIHNob3dTY3JvbGxiYXIoYXhpcykge1xuXHQgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuXHQgICAgICBheGlzID0gJ3knO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc2Nyb2xsYmFyID0gdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbDtcblxuXHQgICAgaWYgKCF0aGlzLmF4aXNbYXhpc10uaXNWaXNpYmxlKSB7XG5cdCAgICAgIHNjcm9sbGJhci5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy52aXNpYmxlKTtcblx0ICAgICAgdGhpcy5heGlzW2F4aXNdLmlzVmlzaWJsZSA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hpZGUpIHtcblx0ICAgICAgdGhpcy5oaWRlU2Nyb2xsYmFycygpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvKipcblx0ICAgKiBIaWRlIFNjcm9sbGJhclxuXHQgICAqL1xuXHQgIDtcblxuXHQgIC8qKlxuXHQgICAqIG9uIHNjcm9sbGJhciBoYW5kbGUgZHJhZyBtb3ZlbWVudCBzdGFydHNcblx0ICAgKi9cblx0ICBfcHJvdG8ub25EcmFnU3RhcnQgPSBmdW5jdGlvbiBvbkRyYWdTdGFydChlLCBheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIHZhciBlbERvY3VtZW50ID0gZ2V0RWxlbWVudERvY3VtZW50KHRoaXMuZWwpO1xuXHQgICAgdmFyIGVsV2luZG93ID0gZ2V0RWxlbWVudFdpbmRvdyh0aGlzLmVsKTtcblx0ICAgIHZhciBzY3JvbGxiYXIgPSB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyOyAvLyBNZWFzdXJlIGhvdyBmYXIgdGhlIHVzZXIncyBtb3VzZSBpcyBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcm9sbGJhciBkcmFnIGhhbmRsZS5cblxuXHQgICAgdmFyIGV2ZW50T2Zmc2V0ID0gYXhpcyA9PT0gJ3knID8gZS5wYWdlWSA6IGUucGFnZVg7XG5cdCAgICB0aGlzLmF4aXNbYXhpc10uZHJhZ09mZnNldCA9IGV2ZW50T2Zmc2V0IC0gc2Nyb2xsYmFyLnJlY3RbdGhpcy5heGlzW2F4aXNdLm9mZnNldEF0dHJdO1xuXHQgICAgdGhpcy5kcmFnZ2VkQXhpcyA9IGF4aXM7XG5cdCAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmRyYWdnaW5nKTtcblx0ICAgIGVsRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5kcmFnLCB0cnVlKTtcblx0ICAgIGVsRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25FbmREcmFnLCB0cnVlKTtcblxuXHQgICAgaWYgKHRoaXMucmVtb3ZlUHJldmVudENsaWNrSWQgPT09IG51bGwpIHtcblx0ICAgICAgZWxEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucHJldmVudENsaWNrLCB0cnVlKTtcblx0ICAgICAgZWxEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMucHJldmVudENsaWNrLCB0cnVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVsV2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlbW92ZVByZXZlbnRDbGlja0lkKTtcblx0ICAgICAgdGhpcy5yZW1vdmVQcmV2ZW50Q2xpY2tJZCA9IG51bGw7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIERyYWcgc2Nyb2xsYmFyIGhhbmRsZVxuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by5vblRyYWNrQ2xpY2sgPSBmdW5jdGlvbiBvblRyYWNrQ2xpY2soZSwgYXhpcykge1xuXHQgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cblx0ICAgIGlmIChheGlzID09PSB2b2lkIDApIHtcblx0ICAgICAgYXhpcyA9ICd5Jztcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuY2xpY2tPblRyYWNrKSByZXR1cm47XG5cdCAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KHRoaXMuZWwpO1xuXHQgICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5yZWN0ID0gdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICAgIHZhciBzY3JvbGxiYXIgPSB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyO1xuXHQgICAgdmFyIHNjcm9sbGJhck9mZnNldCA9IHNjcm9sbGJhci5yZWN0W3RoaXMuYXhpc1theGlzXS5vZmZzZXRBdHRyXTtcblx0ICAgIHZhciBob3N0U2l6ZSA9IHBhcnNlSW50KHRoaXMuZWxTdHlsZXNbdGhpcy5heGlzW2F4aXNdLnNpemVBdHRyXSwgMTApO1xuXHQgICAgdmFyIHNjcm9sbGVkID0gdGhpcy5jb250ZW50V3JhcHBlckVsW3RoaXMuYXhpc1theGlzXS5zY3JvbGxPZmZzZXRBdHRyXTtcblx0ICAgIHZhciB0ID0gYXhpcyA9PT0gJ3knID8gdGhpcy5tb3VzZVkgLSBzY3JvbGxiYXJPZmZzZXQgOiB0aGlzLm1vdXNlWCAtIHNjcm9sbGJhck9mZnNldDtcblx0ICAgIHZhciBkaXIgPSB0IDwgMCA/IC0xIDogMTtcblx0ICAgIHZhciBzY3JvbGxTaXplID0gZGlyID09PSAtMSA/IHNjcm9sbGVkIC0gaG9zdFNpemUgOiBzY3JvbGxlZCArIGhvc3RTaXplO1xuXHQgICAgdmFyIHNwZWVkID0gNDA7XG5cblx0ICAgIHZhciBzY3JvbGxUbyA9IGZ1bmN0aW9uIHNjcm9sbFRvKCkge1xuXHQgICAgICBpZiAoZGlyID09PSAtMSkge1xuXHQgICAgICAgIGlmIChzY3JvbGxlZCA+IHNjcm9sbFNpemUpIHtcblx0ICAgICAgICAgIHZhciBfdGhpczQkY29udGVudFdyYXBwZXI7XG5cblx0ICAgICAgICAgIHNjcm9sbGVkIC09IHNwZWVkO1xuXG5cdCAgICAgICAgICBfdGhpczQuY29udGVudFdyYXBwZXJFbC5zY3JvbGxUbygoX3RoaXM0JGNvbnRlbnRXcmFwcGVyID0ge30sIF90aGlzNCRjb250ZW50V3JhcHBlcltfdGhpczQuYXhpc1theGlzXS5vZmZzZXRBdHRyXSA9IHNjcm9sbGVkLCBfdGhpczQkY29udGVudFdyYXBwZXIpKTtcblxuXHQgICAgICAgICAgZWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbFRvKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHNjcm9sbGVkIDwgc2Nyb2xsU2l6ZSkge1xuXHQgICAgICAgICAgdmFyIF90aGlzNCRjb250ZW50V3JhcHBlcjI7XG5cblx0ICAgICAgICAgIHNjcm9sbGVkICs9IHNwZWVkO1xuXG5cdCAgICAgICAgICBfdGhpczQuY29udGVudFdyYXBwZXJFbC5zY3JvbGxUbygoX3RoaXM0JGNvbnRlbnRXcmFwcGVyMiA9IHt9LCBfdGhpczQkY29udGVudFdyYXBwZXIyW190aGlzNC5heGlzW2F4aXNdLm9mZnNldEF0dHJdID0gc2Nyb2xsZWQsIF90aGlzNCRjb250ZW50V3JhcHBlcjIpKTtcblxuXHQgICAgICAgICAgZWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbFRvKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHNjcm9sbFRvKCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIEdldHRlciBmb3IgY29udGVudCBlbGVtZW50XG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLmdldENvbnRlbnRFbGVtZW50ID0gZnVuY3Rpb24gZ2V0Q29udGVudEVsZW1lbnQoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jb250ZW50RWw7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIEdldHRlciBmb3Igb3JpZ2luYWwgc2Nyb2xsaW5nIGVsZW1lbnRcblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8uZ2V0U2Nyb2xsRWxlbWVudCA9IGZ1bmN0aW9uIGdldFNjcm9sbEVsZW1lbnQoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jb250ZW50V3JhcHBlckVsO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uZ2V0U2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aCgpIHtcblx0ICAgIC8vIFRyeS9jYXRjaCBmb3IgRkYgNTYgdGhyb3dpbmcgb24gdW5kZWZpbmVkIGNvbXB1dGVkU3R5bGVzXG5cdCAgICB0cnkge1xuXHQgICAgICAvLyBEZXRlY3QgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1Mgc2Nyb2xsYmFyIHN0eWxpbmcgYW5kIGRvIG5vdCBjYWxjdWxhdGVcblx0ICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUodGhpcy5jb250ZW50V3JhcHBlckVsLCAnOjotd2Via2l0LXNjcm9sbGJhcicpLmRpc3BsYXkgPT09ICdub25lJyB8fCAnc2Nyb2xsYmFyV2lkdGgnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSB8fCAnLW1zLW92ZXJmbG93LXN0eWxlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGgoKTtcblx0ICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGgoKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLnJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcblx0ICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG5cdCAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KHRoaXMuZWwpOyAvLyBFdmVudCBsaXN0ZW5lcnNcblxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGlkZSkge1xuXHQgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG5cdCAgICB9XG5cblx0ICAgIFsnbW91c2Vkb3duJywgJ2NsaWNrJywgJ2RibGNsaWNrJ10uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICBfdGhpczUuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBfdGhpczUub25Qb2ludGVyRXZlbnQsIHRydWUpO1xuXHQgICAgfSk7XG5cdCAgICBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ10uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICBfdGhpczUuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBfdGhpczUub25Qb2ludGVyRXZlbnQsIHtcblx0ICAgICAgICBjYXB0dXJlOiB0cnVlLFxuXHQgICAgICAgIHBhc3NpdmU6IHRydWVcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG5cdCAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG5cdCAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5vblNjcm9sbCk7XG5cdCAgICBlbFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplKTtcblx0ICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdCAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTsgLy8gQ2FuY2VsIGFsbCBkZWJvdW5jZWQgZnVuY3Rpb25zXG5cblx0ICAgIHRoaXMucmVjYWxjdWxhdGUuY2FuY2VsKCk7XG5cdCAgICB0aGlzLm9uTW91c2VNb3ZlLmNhbmNlbCgpO1xuXHQgICAgdGhpcy5oaWRlU2Nyb2xsYmFycy5jYW5jZWwoKTtcblx0ICAgIHRoaXMub25XaW5kb3dSZXNpemUuY2FuY2VsKCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFVuTW91bnQgbXV0YXRpb24gb2JzZXJ2ZXIgYW5kIGRlbGV0ZSBTaW1wbGVCYXIgaW5zdGFuY2UgZnJvbSBET00gZWxlbWVudFxuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by51bk1vdW50ID0gZnVuY3Rpb24gdW5Nb3VudCgpIHtcblx0ICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG5cdCAgICBTaW1wbGVCYXIuaW5zdGFuY2VzLmRlbGV0ZSh0aGlzLmVsKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQ2hlY2sgaWYgbW91c2UgaXMgd2l0aGluIGJvdW5kc1xuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by5pc1dpdGhpbkJvdW5kcyA9IGZ1bmN0aW9uIGlzV2l0aGluQm91bmRzKGJib3gpIHtcblx0ICAgIHJldHVybiB0aGlzLm1vdXNlWCA+PSBiYm94LmxlZnQgJiYgdGhpcy5tb3VzZVggPD0gYmJveC5sZWZ0ICsgYmJveC53aWR0aCAmJiB0aGlzLm1vdXNlWSA+PSBiYm94LnRvcCAmJiB0aGlzLm1vdXNlWSA8PSBiYm94LnRvcCArIGJib3guaGVpZ2h0O1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBGaW5kIGVsZW1lbnQgY2hpbGRyZW4gbWF0Y2hlcyBxdWVyeVxuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by5maW5kQ2hpbGQgPSBmdW5jdGlvbiBmaW5kQ2hpbGQoZWwsIHF1ZXJ5KSB7XG5cdCAgICB2YXIgbWF0Y2hlcyA9IGVsLm1hdGNoZXMgfHwgZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3Rvcjtcblx0ICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWwuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuXHQgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKGNoaWxkLCBxdWVyeSk7XG5cdCAgICB9KVswXTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFNpbXBsZUJhcjtcblx0fSgpO1xuXG5cdFNpbXBsZUJhci5kZWZhdWx0T3B0aW9ucyA9IHtcblx0ICBhdXRvSGlkZTogdHJ1ZSxcblx0ICBmb3JjZVZpc2libGU6IGZhbHNlLFxuXHQgIGNsaWNrT25UcmFjazogdHJ1ZSxcblx0ICBjbGFzc05hbWVzOiB7XG5cdCAgICBjb250ZW50RWw6ICdzaW1wbGViYXItY29udGVudCcsXG5cdCAgICBjb250ZW50V3JhcHBlcjogJ3NpbXBsZWJhci1jb250ZW50LXdyYXBwZXInLFxuXHQgICAgb2Zmc2V0OiAnc2ltcGxlYmFyLW9mZnNldCcsXG5cdCAgICBtYXNrOiAnc2ltcGxlYmFyLW1hc2snLFxuXHQgICAgd3JhcHBlcjogJ3NpbXBsZWJhci13cmFwcGVyJyxcblx0ICAgIHBsYWNlaG9sZGVyOiAnc2ltcGxlYmFyLXBsYWNlaG9sZGVyJyxcblx0ICAgIHNjcm9sbGJhcjogJ3NpbXBsZWJhci1zY3JvbGxiYXInLFxuXHQgICAgdHJhY2s6ICdzaW1wbGViYXItdHJhY2snLFxuXHQgICAgaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsOiAnc2ltcGxlYmFyLWhlaWdodC1hdXRvLW9ic2VydmVyLXdyYXBwZXInLFxuXHQgICAgaGVpZ2h0QXV0b09ic2VydmVyRWw6ICdzaW1wbGViYXItaGVpZ2h0LWF1dG8tb2JzZXJ2ZXInLFxuXHQgICAgdmlzaWJsZTogJ3NpbXBsZWJhci12aXNpYmxlJyxcblx0ICAgIGhvcml6b250YWw6ICdzaW1wbGViYXItaG9yaXpvbnRhbCcsXG5cdCAgICB2ZXJ0aWNhbDogJ3NpbXBsZWJhci12ZXJ0aWNhbCcsXG5cdCAgICBob3ZlcjogJ3NpbXBsZWJhci1ob3ZlcicsXG5cdCAgICBkcmFnZ2luZzogJ3NpbXBsZWJhci1kcmFnZ2luZydcblx0ICB9LFxuXHQgIHNjcm9sbGJhck1pblNpemU6IDI1LFxuXHQgIHNjcm9sbGJhck1heFNpemU6IDAsXG5cdCAgdGltZW91dDogMTAwMFxuXHR9O1xuXHRTaW1wbGVCYXIuaW5zdGFuY2VzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRTaW1wbGVCYXIuaW5pdERPTUxvYWRlZEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuXHQgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cdCAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cdCAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zaW1wbGViYXJdOm5vdChbZGF0YS1zaW1wbGViYXI9XCJpbml0XCJdKScpLCBmdW5jdGlvbiAoZWwpIHtcblx0ICAgIGlmICghU2ltcGxlQmFyLmluc3RhbmNlcy5oYXMoZWwpKSBuZXcgU2ltcGxlQmFyKGVsLCBnZXRPcHRpb25zKGVsLmF0dHJpYnV0ZXMpKTtcblx0ICB9KTtcblx0fTtcblxuXHRTaW1wbGVCYXIucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5nbG9iYWxPYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdH07XG5cblx0U2ltcGxlQmFyLmluaXRIdG1sQXBpID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzID0gdGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHMuYmluZCh0aGlzKTsgLy8gTXV0YXRpb25PYnNlcnZlciBpcyBJRTExK1xuXG5cdCAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgLy8gTXV0YXRpb24gb2JzZXJ2ZXIgdG8gb2JzZXJ2ZSBkeW5hbWljYWxseSBhZGRlZCBlbGVtZW50c1xuXHQgICAgdGhpcy5nbG9iYWxPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKFNpbXBsZUJhci5oYW5kbGVNdXRhdGlvbnMpO1xuXHQgICAgdGhpcy5nbG9iYWxPYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7XG5cdCAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcblx0ICAgICAgc3VidHJlZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgfSAvLyBUYWtlbiBmcm9tIGpRdWVyeSBgcmVhZHlgIGZ1bmN0aW9uXG5cdCAgLy8gSW5zdGFudGlhdGUgZWxlbWVudHMgYWxyZWFkeSBwcmVzZW50IG9uIHRoZSBwYWdlXG5cblxuXHQgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJyAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKSB7XG5cdCAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgaW5pdFxuXHQgICAgd2luZG93LnNldFRpbWVvdXQodGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHMpO1xuXHQgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cdCAgfVxuXHR9O1xuXG5cdFNpbXBsZUJhci5oYW5kbGVNdXRhdGlvbnMgPSBmdW5jdGlvbiAobXV0YXRpb25zKSB7XG5cdCAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XG5cdCAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG11dGF0aW9uLmFkZGVkTm9kZXMsIGZ1bmN0aW9uIChhZGRlZE5vZGUpIHtcblx0ICAgICAgaWYgKGFkZGVkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuXHQgICAgICAgIGlmIChhZGRlZE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNpbXBsZWJhcicpKSB7XG5cdCAgICAgICAgICAhU2ltcGxlQmFyLmluc3RhbmNlcy5oYXMoYWRkZWROb2RlKSAmJiBuZXcgU2ltcGxlQmFyKGFkZGVkTm9kZSwgZ2V0T3B0aW9ucyhhZGRlZE5vZGUuYXR0cmlidXRlcykpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFkZGVkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zaW1wbGViYXJdOm5vdChbZGF0YS1zaW1wbGViYXI9XCJpbml0XCJdKScpLCBmdW5jdGlvbiAoZWwpIHtcblx0ICAgICAgICAgICAgIVNpbXBsZUJhci5pbnN0YW5jZXMuaGFzKGVsKSAmJiBuZXcgU2ltcGxlQmFyKGVsLCBnZXRPcHRpb25zKGVsLmF0dHJpYnV0ZXMpKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG11dGF0aW9uLnJlbW92ZWROb2RlcywgZnVuY3Rpb24gKHJlbW92ZWROb2RlKSB7XG5cdCAgICAgIGlmIChyZW1vdmVkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuXHQgICAgICAgIGlmIChyZW1vdmVkTm9kZS5oYXNBdHRyaWJ1dGUoJ1tkYXRhLXNpbXBsZWJhcj1cImluaXRcIl0nKSkge1xuXHQgICAgICAgICAgU2ltcGxlQmFyLmluc3RhbmNlcy5oYXMocmVtb3ZlZE5vZGUpICYmIFNpbXBsZUJhci5pbnN0YW5jZXMuZ2V0KHJlbW92ZWROb2RlKS51bk1vdW50KCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocmVtb3ZlZE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2ltcGxlYmFyPVwiaW5pdFwiXScpLCBmdW5jdGlvbiAoZWwpIHtcblx0ICAgICAgICAgICAgU2ltcGxlQmFyLmluc3RhbmNlcy5oYXMoZWwpICYmIFNpbXBsZUJhci5pbnN0YW5jZXMuZ2V0KGVsKS51bk1vdW50KCk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH0pO1xuXHR9O1xuXG5cdFNpbXBsZUJhci5nZXRPcHRpb25zID0gZ2V0T3B0aW9ucztcblx0LyoqXG5cdCAqIEhUTUwgQVBJXG5cdCAqIENhbGxlZCBvbmx5IGluIGEgYnJvd3NlciBlbnYuXG5cdCAqL1xuXG5cdGlmIChjYW5Vc2VEb20pIHtcblx0ICBTaW1wbGVCYXIuaW5pdEh0bWxBcGkoKTtcblx0fVxuXG5cdHJldHVybiBTaW1wbGVCYXI7XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./public/backend/js/simplebar.js\n");

/***/ }),

/***/ "./resources/assets/backend/js/app.js":
/*!********************************************!*\
  !*** ./resources/assets/backend/js/app.js ***!
  \********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _public_backend_js_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../public/backend/js/main.js */ \"./public/backend/js/main.js\");\n/* harmony import */ var _public_backend_js_main_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_public_backend_js_main_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _public_backend_js_custom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../public/backend/js/custom.js */ \"./public/backend/js/custom.js\");\n/* harmony import */ var _public_backend_js_custom_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_public_backend_js_custom_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _public_backend_js_simplebar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../public/backend/js/simplebar.js */ \"./public/backend/js/simplebar.js\");\n/* harmony import */ var _public_backend_js_simplebar_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_public_backend_js_simplebar_js__WEBPACK_IMPORTED_MODULE_2__);\n// require('./bootstrap');\n // import '../../../../public/backend/js/sweetalert.min.js';\n// import '../../../../public/backend/js/jquery.dataTables.min.js';\n// import '../../../../public/backend/js/dataTables.bootstrap4.min.js';\n// import '../../../../public/backend/js/avro-v1.1.4.min.js';\n// import '../../../../public/backend/js/bootstrap-datepicker.min.js';\n// import '../../../../public/backend/js/select2.min.js';\n\n // import '../../../../public/backend/js/jquery.validate.js';\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2JhY2tlbmQvanMvYXBwLmpzPzZmY2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtDQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Q0FFQSIsImZpbGUiOiIuL3Jlc291cmNlcy9hc3NldHMvYmFja2VuZC9qcy9hcHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZXF1aXJlKCcuL2Jvb3RzdHJhcCcpO1xyXG5cclxuaW1wb3J0ICcuLi8uLi8uLi8uLi9wdWJsaWMvYmFja2VuZC9qcy9tYWluLmpzJztcclxuLy8gaW1wb3J0ICcuLi8uLi8uLi8uLi9wdWJsaWMvYmFja2VuZC9qcy9zd2VldGFsZXJ0Lm1pbi5qcyc7XHJcbi8vIGltcG9ydCAnLi4vLi4vLi4vLi4vcHVibGljL2JhY2tlbmQvanMvanF1ZXJ5LmRhdGFUYWJsZXMubWluLmpzJztcclxuLy8gaW1wb3J0ICcuLi8uLi8uLi8uLi9wdWJsaWMvYmFja2VuZC9qcy9kYXRhVGFibGVzLmJvb3RzdHJhcDQubWluLmpzJztcclxuLy8gaW1wb3J0ICcuLi8uLi8uLi8uLi9wdWJsaWMvYmFja2VuZC9qcy9hdnJvLXYxLjEuNC5taW4uanMnO1xyXG4vLyBpbXBvcnQgJy4uLy4uLy4uLy4uL3B1YmxpYy9iYWNrZW5kL2pzL2Jvb3RzdHJhcC1kYXRlcGlja2VyLm1pbi5qcyc7XHJcbi8vIGltcG9ydCAnLi4vLi4vLi4vLi4vcHVibGljL2JhY2tlbmQvanMvc2VsZWN0Mi5taW4uanMnO1xyXG5pbXBvcnQgJy4uLy4uLy4uLy4uL3B1YmxpYy9iYWNrZW5kL2pzL2N1c3RvbS5qcyc7XHJcbi8vIGltcG9ydCAnLi4vLi4vLi4vLi4vcHVibGljL2JhY2tlbmQvanMvanF1ZXJ5LnZhbGlkYXRlLmpzJztcclxuaW1wb3J0ICcuLi8uLi8uLi8uLi9wdWJsaWMvYmFja2VuZC9qcy9zaW1wbGViYXIuanMnOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/backend/js/app.js\n");

/***/ }),

/***/ 1:
/*!**************************************************!*\
  !*** multi ./resources/assets/backend/js/app.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! C:\xampp\htdocs\admin_6-0\resources\assets\backend\js\app.js */"./resources/assets/backend/js/app.js");


/***/ })

/******/ });